---
title: 数据库
tags:
  - 数据库
categories: 技术
mathjax: true
abbrlink: "0"
---

数据库是为了实现一定的目的按某种规则组织起来的数据的集合, 简单的说,数据库就是存储数据的库.

<!-- more -->

**常见数据库**

1 oracle公司的oracle数据库
2 IBM公司的DB2数据库
3 Informix公司的Informix数据库
4 sysbase公司的sysbase数据库
5 Microsoft公司的SQL Server
6 oracle的MySQL数据库（开始属于mysql公司，后来mysql被sun收购，sun又被oracle收购）
7 MongoDB数据库(json键值对的非关系数据库)

# oracle

Oracle是殷墟（yīn Xu）出土的甲骨文（oracle bone inscriptions）的英文翻译的第一个单词。

Oracle公司成立于1977年，总部位于美国加州；

Oracle数据库是Oracle（中文名称叫甲骨文）公司的核心产品，Oracle数据库是一个适合于大中型企业的数据库管理系统。在所有的数据库管理系统中（比如：微软的SQL Server，IBM的DB2等），Oracle的主要用户涉及面非常广, 包括: 银行、电信、移动通信、航空、保险、金融、电子商务和跨国公司等。

Oracle数据库的一些版本有：Oracle7、Oracle8i、Oracle9i，Oracle10g到Oracle11g，Oracle12c， 各个版本之间的操作存在一定的差别，但是**操作oracle数据库都使用的是标准的SQL语句，因此对于各个版本的差别不大**。

2008年1月16日 收购bea，目的是为了得到weblogic（web服务器的框架，免费的对应的tomcat）。
2008年1月16日 sun公司收购了mysql 。
2009年4月20日 oracle收购了sun 。

[官网安装路径](https://www.oracle.com/database/technologies/oracle-database-software-downloads.html)

**Oracle服务器**：是一个**数据管理系统(RDBMS)**，它提供开放的, 全面的, 近乎完整的信息管理。由**1个数据库和一个（或多个）实例(可以简单理解成就是进程)组成**。数据库位于硬盘上，实例位于内存中。

![image-20221012154245368](https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202210121542288.png)

oracle非常耗费内存

**表空间和数据文件**

逻辑概念：表空间是由多个数据文件组成，位于实例上，在内存中。
物理概念：数据文件，在磁盘上（/home/oracle_11/app/oradata/orcl目录中的.DBF文件）；
          一个表空间包含一个或者多个数据文件。

![image-20221015141839715](https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202210151419807.png)

段存在于表空间中，段是区的集合，区是数据块的集合，数据块会被映射到磁盘块。

![image-20221015142120134](https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202210151421976.png)

![image-20221015142151286](https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202210151421152.png)

## DBA

数据库管理员（Database Administrator，简称DBA），是从事管理和维护数据库管理系统(DBMS)的相关工作人员的统称，属于运维工程师的一个分支，主要负责业务数据库从设计、测试到部署交付的全生命周期管理。DBA的核心目标是保证数据库管理系统的稳定性、安全性、完整性和高性能。从时间开销上看：安装占用6%，创建和配置占用12%，装载和存档数据占6%, 软件维护占6%，管理数据库系统占55%，可见，管理数据库系统占用了大部分的时间开销。

![image-20221015142827073](https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202210151428318.png)

## 启动数据库服务

### Windows

windows下创建数据库参考[此处](https://blog.51cto.com/u_11682417/5792643)(注意,安装过程中主机名不要修改,默认的是对的,吃过亏了)

Windows启动oracle数据库服务：
启动服务：services.msc，找到下列两个服务，并启动。

- `OracleServiceORCL`： oracle数据库服务系统
- `home1TNSListene`： 监听服务，用于远程连接的侦听

注意：若把数据库默认设置为自启动，则开机时间会延长。

### Linux

Linux启动oracle数据库服务步骤(oracle数据库系统安装到linux系统上)

1. 执行`sqlplus / as sysdba`或`sqlplus sys/sys as sysdba`进入到命令行界面
2. 执行`startup`启动数据库服务
3. 执行`exit`退出`sqlplus命令行界面`
4. 执行`lsnrctl start`**启动监听服务**

注意：通过远程客户端连接oracle服务端必须要启动监听服务，否则客户端连接不上。

sqlplus命令行界面下还可以使用 `shutdown immeidate`停止数据库服务

## 容器数据库

[容器数据库（CDB）和可插拔数据库（PDB）](https://blog.csdn.net/weixin_42774383/article/details/82116377)是Oracle 12C引入的一种特性，它允许在CDB容器数据库中创建并维护多个数据库。这个特性的优点之一是可以在一个数据库服务器上创建多个独立的数据库，每个PDB在CDB中是相互独立存在的。这样可以更有效地利用服务器资源，避免浪费。此外，CDB根容器数据库的主要作用就是容纳所有相关的PDB元数据，以及在CDB中对现有PDB进行管理

MYSQL没有容器数据库的概念

- `ROOT`：ROOT容器数据库，是CDB环境中的根数据库，在根数据库中含有主数据字典视图，其中包含了与ROOT容器有关的元数据和CDB中包含的所有PDB信息，在CDB环境中被标识为**`CDB$ROOT`**，每个CDB环境中只能有一个ROOT容器数据库。
- `PDB SEED`:PDB SEED为PDB的种子，其中提供了数据文件，在PDB环境中被标识为`PDB$SEED`，是创建PDB的模板，可以连接PDB$SEED但是不能执行任何事务，因为PDB$SEED是只读的，不可修改。
- `PDBS`：PDBS数据库，在CDB环境中每个PDB都是独立存在的，与传统ORACLE数据库无差别，每个PDB拥有自己的数据文件和OBJECTS，唯一的区别就是PDB可以插入到CDB中，以及从CDB中拔出。当用户连接到PDB时不会感觉到根容器和其他PDB的存在。

### 容器数据库基本操作

- `show pdbs;`   查看当前数据库下有哪些PDB
- `show con_name;`  查看当前连接的是哪个数据库
- `alter session set container=数据库名;`   切换数据库
- [等等点击跳转详解](https://blog.csdn.net/weixin_42774383/article/details/82116377)

## 登录数据库服务

### 本机登陆

- 普通用户身份登陆

  `sqlplus 用户名/密码`，如sqlplus scott/tiger

- 以管理员身份登陆

  `sqlplus  /  as  sysdba`（此处不用输入密码，在安装的时候已经输入密码）

  `sqlplus sys/sys as sysdba`

**oracle自带两个用户**

- **`SYS`**用户是Oracle数据库的超级用户，它拥有最高权限，可以执行任何操作。`SYS`用户拥有所有的数据字典表和视图，这些对象都存储在`SYS`模式下。通常情况下，不建议使用`SYS`用户进行日常操作，因为它拥有非常高的权限，可能会对数据库造成不可逆的影响。
- **`SYSTEM`**用户也是一个具有高权限的用户，它主要用于执行数据库管理任务。与`SYS`用户不同的是，`SYSTEM`用户并不拥有所有的数据字典表和视图，它只能访问那些授权给它的对象。通常情况下，可以使用`SYSTEM`用户来执行一些日常的数据库管理任务。

### 远程登陆

 远程通过网络登陆数据库需要安装oracle客户端软件，并进行配置才能使用，可通过使用net manager进行配置，配置完成之后可以使用连接字符串进行登陆，连接字符串中包含了数据库服务的IP地址和端口，以及实例名。

注意：安装oracle客户端的时候，安装路径中不能出现中文和空格，安装的时候选择管理员模式。

- 普通用户登陆

  `sqlplus 用户名/密码@连接字符串`，如`sqlplus scott/tiger@oracle_orcl`

- 管理员用户登陆

  `sqlplus sys/sys@oracle_orcl as sysdba`

 此外：还可以执行： `sqlplus scott/tiger@//IP地址/实例名`        进行登陆。
    使用scott用户或者sys用户登陆完之后，可以使用`show user`测试一下，如果显示用户名就表明已经登陆成功了，或者是执行`select * from tab；`进行一次查询, 有结果显示就表名已经登陆成功了.

相关命令

- 解锁用户：`alter user scott account unlock` (管理员身份登陆，给scott用户解锁。用户默认锁定)

- 锁定用户：`alter user scott account lock`，（必须用管理员用户登陆）

- 修改用户密码：`alter user scott identified by 新密码`    (管理员身份登陆，给scott用户修改密码)

  修改用户密码也可以直接 `password scott 新密码`(scott用户本身修改自身密码的话可以省略scott)

- 查看当前语言环境：`select userenv('language') from dual;`

加锁后,对应加锁的用户就不能登录了,解锁后该用户才能登录

### oracle创建案例脚本

```sql
-- 01 创建表空间
-- 注意表空间的路径 根据实际安装环境进行调整

CREATE TABLESPACE ts_seckey_admin 
    LOGGING  
    DATAFILE '/u01/app/oracle/oradata/orcl/ts_seckeymng_admin.dbf' SIZE 50M 
    EXTENT MANAGEMENT LOCAL;
    

CREATE TABLESPACE ts_seckey_op
    LOGGING 
    DATAFILE '/u01/app/oracle/oradata/orcl/ts_seckeymng_op.dbf' SIZE 200M
    EXTENT MANAGEMENT LOCAL;
    
ALTER DATABASE DATAFILE '/u01/app/oracle/oradata/orcl/ts_seckeymng_admin.dbf' AUTOEXTEND ON NEXT   50M MAXSIZE UNLIMITED;
ALTER DATABASE DATAFILE '/u01/app/oracle/oradata/orcl/ts_seckeymng_op.dbf' AUTOEXTEND ON NEXT  200M MAXSIZE UNLIMITED; 

commit;


-- 02 创建方案 (创建用户)
CREATE USER SECMNG  PROFILE DEFAULT 
    IDENTIFIED BY SECMNG DEFAULT TABLESPACE USERS
    ACCOUNT UNLOCK;

-- 资源和登录权限
GRANT resource TO SECMNG;
GRANT create session TO SECMNG;


-- 创建 网点信息表 --编号 名称 描述 授权码 状态(0可用  1不可用)
CREATE TABLE SECMNG.SECNODE(
	id     				char(4) PRIMARY KEY, 
	name     			VARCHAR2(128) NOT NULL,
 	nodedesc      		VARCHAR2(512),
 	createtime			date,
 	authcode			NUMBER(12),
 	state     			NUMBER(4)
)TABLESPACE ts_seckey_admin;

INSERT INTO SECMNG.secnode VALUES('0001', '网银中心', '北京金融街23号', '15-7月-15', 1, 0);
INSERT INTO SECMNG.secnode VALUES('1111', '广东分中心1111', '广州天河金融', '15-7月-15', 1111, 0);
commit;

-- 创建 网点密钥表, 客户端网点 服务器端网点 密钥号 密钥产生时间 密钥状态 
CREATE TABLE SECMNG.SECKEYINFO(
	clientid          	char(4) constraint secmng_seckeynode_clientid_fk references SECMNG.SECNODE(id),
	serverid          	char(4) constraint secmng_seckeynode_serverid_fk references SECMNG.SECNODE(id),
	keyid            	NUMBER(9) PRIMARY KEY, 
	createtime			date,
	state				NUMBER(4),
	seckey				VARCHAR2(512)
)TABLESPACE ts_seckey_admin;

--创建索引 在新的表空间上
CREATE  INDEX SECMNG.IX_SECKEYINFO_clientid ON SECMNG.SECKEYINFO(clientid) TABLESPACE ts_seckey_admin;

commit;


-- keysn序列号
CREATE TABLE SECMNG.KEYSN(
	ikeysn 		number(12)  PRIMARY KEY
) TABLESPACE ts_seckey_admin;

INSERT INTO SECMNG.KEYSN(ikeysn) VALUES (1);
commit;


CREATE TABLE SECMNG.SRVCFG(
	key				VARCHAR2(64),
	valude			VARCHAR2(128)
)TABLESPACE ts_seckey_admin;
	
-- 创建 交易信息表 交易者 交易时间 交易事件 交易描述 （什么人 在什么时间 干了什么事）
CREATE TABLE SECMNG.TRAN(
	iID					Number(12) PRIMARY KEY,
 	tran_operator     	NUMBER,
 	trantime			date,
 	tranid          	NUMBER(4),
 	trandesc      		VARCHAR2(512)	
)TABLESPACE ts_seckey_op;


-- 创建索引
CREATE INDEX SECMNG.IX_TRAN_tran_operator ON SECMNG.TRAN(tran_operator) TABLESPACE ts_seckey_op;

-- 创建触发器 自增字段
CREATE SEQUENCE SECMNG.SEQiID INCREMENT BY 1 START WITH 1 
    MAXVALUE 1.0E28 MINVALUE 1 NOCYCLE 
    CACHE 20 NOORDER;
    
CREATE OR REPLACE TRIGGER SECMNG.SEQiID
  BEFORE INSERT ON SECMNG.TRAN
    for each row
begin
    select SECMNG.SEQiID.nextval into :new.iID from dual;
end;
/


INSERT INTO SECMNG.TRAN(tran_operator, trantime, tranid, trandesc) VALUES(1, '15-7月-15', 1, '创建网银总节点-测试数据');

commit;

------停止-----
-- 04创建新用户方案 	通过 SECMNGUSER1 来访问数据库, 让管理终端系统用   
CREATE USER "SECMNGADMIN"  PROFILE "DEFAULT" IDENTIFIED BY "123456" DEFAULT TABLESPACE "USERS" ACCOUNT UNLOCK;

GRANT "CONNECT" TO "SECMNGADMIN";
GRANT SELECT ANY TABLE TO "SECMNGADMIN";

GRANT resource TO SECMNGADMIN;
GRANT create session TO SECMNGADMIN;


GRANT DELETE ON SECMNG.SRVCFG TO "SECMNGADMIN";
GRANT INSERT ON SECMNG.SRVCFG TO "SECMNGADMIN";
GRANT UPDATE ON SECMNG.SRVCFG TO "SECMNGADMIN";


GRANT DELETE ON SECMNG.SECNODE TO "SECMNGADMIN";
GRANT INSERT ON SECMNG.SECNODE TO "SECMNGADMIN";
GRANT UPDATE ON SECMNG.SECNODE TO "SECMNGADMIN";

GRANT DELETE ON SECMNG.SECKEYINFO TO "SECMNGADMIN";
GRANT INSERT ON SECMNG.SECKEYINFO TO "SECMNGADMIN";
GRANT UPDATE ON SECMNG.SECKEYINFO TO "SECMNGADMIN";

GRANT DELETE ON SECMNG.TRAN TO "SECMNGADMIN";
GRANT INSERT ON SECMNG.TRAN TO "SECMNGADMIN";
GRANT UPDATE ON SECMNG.TRAN TO "SECMNGADMIN";

commit;

    
 
-- Insert Into SECMNG.SECKEYINFO(clientid, serverid, keyid, createtime, state, seckey)
-- values ('1111', '0001', 1, to_date('2015-07-14 21:09:09', 'yyyy-mm-dd hh24:mi:ss'), 0, 'zzz')  ;
```

# sql和sqlplus

sql和sqlplus的区别:

- SQL是语言，关键字不能缩写。
- sqlplus是oracle提供的工具，可在里面执行SQL语句，它配有自己的命令(ed、c、set、col、spool) 特点是缩写关键字。

## sqlplus常用命令

- 显示当前用户： 	`SQL> show user;`

- 查看当前用户下的表：	`SQL> select * from tab;`		

  ​	tab:	数据字典（记录数据库和应用程序源数据的目录），包含当前用户下的表。

- 查看员工表的结构：	`SQL> desc emp;`		(desc  →  description 描述)

- 设置行宽：`set linesize 120;`

- 设置页面：`set pagesize 100;`

  或者将上述两行写入如下两个配置文件，可永久设置：

  - `C:\app\Administrator\product\11.2.0\client_1\sqlplus\admin\glogin.sql` 
  - `C:\app\Administrator\product\11.2.0\dbhome_1\sqlplus\admin\glogin.sql`

- 设置员工名列宽：`col ename for a20`			(a表示字符串)

- 设置薪水列为4位数子：`col sal for 9999`		(一个9表示一位数字)

- 若想将显示结果保存到文件中

  ```sql
  spool d:\result.txt;
  select * from emp;
  spool off;
  ```

- ed(或者edit)命令打开文件来编写sql语句,注意, sql语句末尾不要加`;`  , 然后换行加上`/`表示结束

- 修改日期格式,日期格式默认为`DD-MON-RR`,修改日期格式方式为: `alter session set NLS_DATE_FORMAT = 'yyyy-mm-dd hh24:mi:ss';`  查看当前会话使用的日期格式 : `select * from v$nls_parameters;`

- 开关显示SQL的执行时间： `set timing on/off`

-  `/`表示重复刚刚执行过的sql语句.

- `start sql脚本路径`或 `@ sql脚本路径` 可以运行sql脚本

- `set feedback on/off`开关回显

### 管理员创建用户

`create user 用户名 identified by 密码;`  创建用户(刚创建的用户连连接数据库的权限都没有)

`grant connect ,resource to 用户名;`  一般都要赋予最基本的连接数据库权限`connect`和访问资源的权限 `resource`

赋予对USERS表空间的权限`ALTER USER 数据库用户名 QUOTA UNLIMITED ON USERS ;`

## SQL语言的类型

1. 数据库中，称呼 **[增](#sql插入相关) [删](#sql删除相关) [改](#sql修改相关) [查](#sql查询相关)**，为**DML语句**。(**Data Manipulation Language 数据操纵**
   **语言**)，就是指代：`insert`、`update`、`delete`、`select`这四个操作。
2. **[DDL语句](#数据库对象)**。(**Data Definition Language 数据定义语言**)。	
   如：`truncate table(截断/清空一张表)`
   	`create table(表)`、`create view(视图)`、`create index(索引)`、`create sequence(序列)`、
   	`create synonym(同义词)`、`alter table`、`drop table`。
3. **DCL语句**。DCL（**Data Control Language数据控制语言**）如：
   	`commit(提交)`、`rollback(回滚)` 

# 数据库对象

数据库对象共有12个,分别是:  表,视图,索引,序列,同义词,存储过程,存储函数,触发器,包,包体,数据库链路(datalink),快照

**常见的数据库对象**

- [表](#表)		    基本的数据存储集合，由行和列组成。
- 视图	    从表中抽出的逻辑上相关的数据集合。
- 序列	    提供有规律的数值。
- 索引        提高查询的效率
- 同义词	给对象起别名

## 表

基本的数据存储集合，由行和列组成。表名和列名遵循如下**命名规则**：

- 必须以字母开头
- 必须在 1–30 个字符之间
- 必须只能包含 A–Z, a–z, 0–9, _, $, 和#
- 必须不能和用户定义的其他对象重名
- 必须不能是Oracle 的保留字
- Oracle默认存储是都存为大写
- 数据库名只能是1~8位, datalink可以是128位, 和其他一些特殊字符

### 创建表

关键词   **`Create Table`**

创建一张表必须具备：1. Create Table的权限 2. 存储空间。

```sql
create table test1 (tid number, tname varchar2(20), hiredate date default sysdate);
```

`default`的作用是, 当向表中插入数据的时候, 没有指定时间的时候, 使用默认值`sysdate`。

创建表时，列所使用的数据类型：	

![image-20221026171754801](https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202210261717113.png)

- `varchar2(size)`中的`size`表示可变长的最大值

- `number(p,s)`中的p表示数值的总长度,s表示小数点长度(6200.00,p为6,s为2)

- `rowid`：行地址 ——伪列
  `select rowid, empno, deptno from emp;`
  看到该列存储的是一系列的地址(指针), 创建索引用.

  <img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202210261732808.png" alt="image-20221026173208069" style="zoom:67%;" />

**[ [注意] ]** `create table as select子句`的格式中,后面select后的**表达式要取别名(语法要求)**

[相关语法参考批处理标题](#批处理)

### 修改表

关键词	**`ALTER TABLE`**	

- **追加一列**: **`add`**  向test1表中加入新列 image 类型是blob

  `alter table test1 add image blob;`			

- **修改一列**: **`modify`**  将tname列的大小由20→40.

  `alter table test1 modify tname varchar2(40);`

- **删除一列**: **`dropcolumn`**  将刚加入的新列image删除.

  `alter table test1 dropcolumn image;`

- **重命名一列**: **`renamecolumn`**  将列tname重命名为username.

  `alter table test1 renamecolumn tname to username;`

**注意**: 若是修改表的字段的长度, 若是增加长度没有问题, 若是减少字段的长度, 有可能会报错.

修改表名:   `rename 原表名 to  新表名`

### 删除表

关键词   **`drop table`**

当表被删除：

- 数据和结构都被删除
- 所有正在运行的相关事物被提交
- 所有相关索引被删除
- `DROP TABLE`语句不能回滚，但是可以闪回

```sql
select * from tab;		查看当前用户下有哪些表, 拷贝保存表名。
drop table testsp;		将测试保存点的表删除。	
select * from tab;		再次查询跟刚刚保存的表名比对，少了testsp，但多了另外一张命名复杂的表。
```

#### Oracle的回收站

- 查看回收站：`show recyclebin`(sqlplus 命令)那个复杂的命名即是testsp在回收站中的名字。
- 清空回收站：`purge recyclebin`
- 将表从回收站**闪回**`flashback table t2 to before drop;`

**注意：并不是所有的用户都有“回收站”，对于没有回收站的用户（管理员）来说，删除操作是不可逆的.**

#### 两种删除方式

- `drop table tbl;`      删除的表可以闪回
- `drop table tbl purge;`       purge的作用:删除不经过回收站,删除的表不可以闪回

### 表的约束

表的约束有5种:   (**`关键词`**)

- **检查**   值是否符合预设的规则(比如性别只能男或女)  (**`check`**)
- **非空 **    (**`not null`**)
- **唯一**   不能重复   (**`unique`**)
- **主键**    非空+唯一   (**`primary key`**)
- **外键**(foreign key)    取值必须在另外一个表中存在  (**`references`**)

**[注意]   设置外键的目标必须是父表的主键.**

修改表增加主键约束

```sql
alter table dept_bak add constraint pk_dept_bak primary key (deptno);
```

create table中设置约束:

```sql
create table student 
(
		sid number constraint student_PK primary key,  			     
  	#学生Id主键约束
		sname varchar2(20) constraint student_name_notnull not null, 	
  	#学生姓名非空约束
		email varchar2(20) constraint student_email_unique unique		
  	#学生邮件唯一约束
		constraint student_email_notnull not null,
  	#同时邮件可再设非空，没有,
		age number constraint student_age_min check(age > 10),	      
  	#学生年龄设置check约束
		gender varchar2(6) constraint gender_female_or_male check(gender in ('男', '女')),
  	#学生性别设置check约束
		deptno number constraint student_FK references dept(deptno) ON DELETE SET NULL 
  	#学生部门号设置外键
);
```

上述代码中,`deptno number constraint student_FK references dept` 设置了删除了dept表中的某个deptno后,student表中的所有那个值的deptno的全部设置空.如果不加 `ON DELETE SET NULL`则删除dept表中的值会报错,除非删除行的deptno值在student表中不存在.

#### 外键的删除相关

- **cascade**  级联删除,主表记录删除的时候,子表引用了该字段的数据跟着删除

  `drop table dept_bak cascade constraints;`

- **set null**  设置为null,主表删除的时候,子表该字段设为null

- **默认方式**  主表删除的时候,如果子表引用了该字段的数据,不能删除,要先删子表

通过`references`定义外键的时候可以用如下参数

- `on delete cascade` 
- `on delete set null`(多数情况下使用这种方法)

#### check检查性约束

格式  **`check(条件)`**

违反检查约束插入报错: ORA-02290：违反检查约束条件

定义约束时没有显式指定名字，系统会默认给一个名称.**建议创建约束的时候自定义一个含义清晰的约束名**

**`constraint`**: 使用该关键字，来给约束起别名。

------

**查看指定表的约束:**

```sql
select constraint_name, constraint_Type, search_condition from user_constraints where table_name='STUDENT';	
```

**注意:上面STUDENT位置的表名必须大写**

## 视图

视图是一种常见数据库对象, 它是**从表中抽出的逻辑上相关的数据集合**。

- 视图基于表
- 视图是**逻辑概念**
- 视图本身没有数据

使用视图的好处:

- 可以简化查询,将视图看做是表的复杂的SQL一种封装
- 可以**限制用户对某些数据的访问**

[注意] 建议不要通过视图去修改表的数据,即使不是只读视图

### 视图相关操作

- **创建视图**    `create view 视图名 as  sql查询语句;`

  创建视图需要 `create view` 权限

  创建**只读视图**  `create view 视图名 as sql查询语句 with read only;`

  `with check option`  要符合视图创建时的条件才能修改原数据

- **创建或更新视图**  `create or replace view 视图名 as 查询语句;`   (`replace`不能单独使用)

- **查看所有已创建的视图**    `select view_name from user_views;`

- **删除视图**    `drop view 视图名;`

创建视图需要 `create view` 权限,添加权限步骤:

1. 使用管理员登陆：`sqlplus / as sysdba`
2. 给scott用户增加权限 `grant create view to scott;` (`revoke`关键词可以撤销权限)

视图中使用DML的规定：														
一：
当视图定义中包含以下元素之一时不能使用delete:
	组函数
	GROUP BY 子句
	DISTINCT 关键字
	ROWNUM 伪列
二：
	当视图定义中包含以下元素之一时不能使用update :
	组函数
	GROUP BY子句
	DISTINCT 关键字
	ROWNUM 伪列
	列的定义为表达式
三：
	当视图定义中包含以下元素之一时不能使用insert :
	组函数
	GROUP BY 子句
	DISTINCT 关键字
	ROWNUM 伪列
	列的定义为表达式
	表中非空的列在视图定义中未包括
总结一句话：**不通过视图做`insert`、`update`、`delete`操作。因为视图提供的目的就是为了简化查询。**

## 索引

索引，相当于书的目录，提高数据检索速度。提高效率（视图不可以提高效率）

- 一种独立于表的模式对象, 可以存储在与表不同的磁盘或表空间中
- 索引被删除或损坏, 不会对表产生影响, 其影响的只是查询的速度
- 索引一旦建立, Oracle 管理系统会对其进行自动维护, 而且由 Oracle 管理系统决定何时使用索引. 用户不用在查询语句中指定使用哪个索引
- 在删除一个表时, 所有基于该表的索引会自动被删除
- 通过指针加速 Oracle 服务器的查询速度
- 通过快速定位数据的方法，减少磁盘 I/O

**使用索引注意点**: 使用索引的列值的**分布要广泛**,重复的概率非常低,**唯一最好**.

索引的原理:若一个表有索引,则oracle会在内部维护一个索引表,查询的时候要使用索引的列,优先会到索引表中去查,通过索引的列找到对应的行地址,找到行地址就可以找到数据.

**索引表中的列的值是有序的.**

使用主键查询数据最快速，因为主键本身就是“唯一索引”，所以检索比较快

Oracle的数据库中，索引有 B树索引（默认）和位图索引两种。

推荐创建索引的三种情况:

- 列中数据值分布范围很广
- 列经常在 WHERE 子句或连接条件中出现
- 表经常被访问而且数据量很大, 访问的数据大概占数据总量的2%到4%

下列情况不要创建索引

- 表很小
- 列不经常作为连接条件或出现在WHERE子句中
- 查询的数据大于2%到4%
- 表经常更新

对索引的理解可以理解为: 系统自动维护的一张顺序表加快了他查询的速度.

### 索引的操作

- **查看所有已创建的索引**  `select index_name from user_indexes;`

- **创建索引**  `create index 索引名  on  表名(列名1，列名2…);` 

  **创键唯一索引**  `create unique index 索引名  on  表名(列名1，列名2…);`    (唯一索引要求列值不重复)

- 删除索引   `drop index 索引名;`

## 序列

可以理解成数组：默认，从[1]开始，长度[20]		[1, 2, 3, 4, 5, 6, …, 20]		在内存中。

由于序列是被保存在内存中，访问内存的速率要高于访问硬盘的速率。所以序列可以提高效率。

**序列的用处**:主要用于插入主键,并保证他的非空和唯一性

### 序列的操作

- **创建序列**  `create sequence 序列名;`
- **删除序列**  `drop sequence 序列名;`
- **显示所有已创建序列**   `select sequence_name from user_sequences;`

**序列的使用**

1. 初始状态下：指针*指向1前面的位置。欲取出第一个值，应该将指针向后移动。每取出一个值指针都向后移。
2. 常常用序列来指定表中的主键。	

创建序列的完整格式

```sql
CREATE SEQUENCE sequence
       [INCREMENT BY n]    #步长
       [START WITH n]      #起始值 
       [{MAXVALUE n | NOMAXVALUE}]    #最大值
       [{MINVALUE n | NOMINVALUE}]    #最小值
       [{CYCLE | NOCYCLE}]    #序列是否循环
       [{CACHE n | NOCACHE}]; #序列的项个数,默认20个(NOCACHE表示没有缓存，一次不产生20个，而只产生一个。)
```

序列的两个属性  

- `currval`    当前值
- `nextval`    下一个值

**`NextVal` 必须在`CurrVal`之前被指定**。因为初始状态下，CurrVal指向1前面的位置，无值

对于新创建的序列使用select myseq.currval from dual;		得到出错。
但select myseq.nextval from dual;		可以得到序列的第一值1.
此时再执行select myseq.currval from dual;	currval的值也得到1

只有nextval取完会向后移动，使用currval不会移动。

使用时按如下方式插入序列值

`insert into tableA values(myseq.nextval, &name)` 

**修改序列：**															
	必须是序列的拥有者或对序列有 ALTER 权限
	只有将来的序列值会被改变
	改变序列的初始值只能通过删除序列之后重建序列的方法实现

### 使用序列需要注意的问题

- 序列是公有对象，所以多张表同时使用序列，会造成主键不连续。

- 回滚也可能造成主键不连续。	

  如：多次调用insert操作使用序列创建主键。但是当执行了rollback后再次使用insert借助序列创建主键的时候，nextval不会随着回滚操作回退。

- 掉电等原因，也可能造成不连续。由于代表序列的数组保存在内存中，断电的时候内存的内容丢失。恢复供电时候，序列直接从21开始。

- 插入失败的情况,但序列的值已经取了,此时的情况也会造成主键不连续

## 同义词

**同义词**就是指表的别名。

### 使用场景

1. scott用户想访问hr用户下的表employees。默认是不能访问的。需要hr用户为scott用户授权.

   `sqplus hr/11`		或		`conn hr/11`（已登录界面，切换登陆）

2.  hr用户为scott用户开放了employees表的查询权限。

   授权  `grant select on employees to scott;`	

3. 这时scott用户就可以使用select语句，来查询hr用户下的employees表的信息了。

   `select count(*) from hr.employees;`   (若用户名叫zhangsanfeng则zhangsanfeng.employees)

4. hr.employees名字过长，为了方便操作，scott用户为它重设别名(**同义词**):
   `create synonym hremp for hr.employees;`  为hr.employees创建了同义词。

创建同义词需要权限:管理员添加设置同义词权限操作如下:

1. `conn / as sysdba`
2. `grant create synonym to scott;`
3. `select count(*) from hremp;`	使用同义词进行表查询操作。

同义词、视图等用法在数据**保密要求较高**的机构使用广泛，如银行机构。好处是既不影响对数据的操作，同时又能保证数据的安全。

### 同义词的操作

- 创建同义词  `create synonym 同义词名(想设置的别名) fot 表名`
- 删除同义词 `drop synonym 同义词名;`
- 查询所有已经创建的同义词  `select synonym_name from user_synonyms;`

#  sql插入相关

关键字: **`insert into`**

格式如下

```sql
INSERT INTO	table [(column [, column...])]
VALUES			(value [, value...]);
```

**案例**

- 插入**全部列**

  `insert into dept values(51,'51name','51loc');`

- 插入**部分列**(没有写出的列自动填NULL)

  `insert into dept(deptno,dname) values(55,'55name');`

- **&符号的使用** (使用&会让用户输入值)

  `insert into dept(deptno,dname,loc) values(&t1,&t2,&t3);`

&符号可以用于所有DML语句中供用户输入,并不仅仅是插入语句.

## 批处理

- 拷贝表结构(不拷贝数据)     通过`where 1=2`这个必定错条件不让数据拷贝过去

  `create table tname_YYYY_MM_DD as select * from tname_xxxxx where 1=2;`      (as不能省略)

- 拷贝表(拷贝数据)    

  `create table tname_YYYY_MM_DD as select * from tname_xxxxx; `        (as不能省略)

- 批量插入

  `insert into tname_bak select * from tname where .....;`

# sql修改相关

关键词 :  **`update`**

格式: `update 表名 set col=值 where condtion`

对于更新操作来说，一般会有一个“where”条件，如果没有这限制条件，更新的就是整张表[危险]。

案例  :  `update emp10 set sal=4000, comm=300 where ename = 'CLARK';`

# sql删除相关

关键词  :  **`delete`**

格式: `delete from 表名 where condtion`

注意: 如不加“where”会将整张表的数据删除。[危险]

`from`关键字在**Oracle**中可以省略不写，但**MySQL**中不可以;
但在使用的时候建议还是加上`from`. 

案例: `delete from emp10 where empno=7782;`

`truncate table dept_0915` 也可以清空一张表,但留下表结构

## truncate和delete的区别

1. delete 逐条删除表“内容”，truncate 先摧毁表再重建。
   (由于delete使用频繁，Oracle对delete优化后delete快于truncate)      **truncate不能加where条件,只能整张表删除**
2. `delete` 是**DML语句**，`truncate` 是**DDL语句**。
   **DML语句可以[闪回(flashback)](#Oracle的回收站)**，DDL语句不可以闪回。
   （闪回：做错了一个操作并且commit了，对应的撤销行为。了解）
3. 由于delete是逐条操作数据，所以delete会产生碎片，truncate不会产生碎片。
   （同样是由于Oracle对delete进行了优化，让delete不产生碎片）。
   	两个数据之间的数据被删除，删除的数据——碎片，整理碎片，数据连续，行移动
4. **delete不会释放空间，truncate 会释放空间**
   用delete删除一张10M的表，空间不会释放。而truncate会。所以当确定表不再使用，应truncate
5. **delete可以回滚rollback, truncate不可以回滚rollback。**

# sql查询相关

## 基本select语句

下面所有说法均以此图为案例

![image-20221015172212283](https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202210151722300.png)

```sql
Select语句的整体形式：
select col1, col2…  
from table_name
where condition
group by col…
having condtion
order by col…
```

p.s.  oracle中sql关键字不区分大小写

语法格式为：`SELECT  *|{[DISTINCT] column|expression [alias],...}FROM table;`

**字符和日期要包含在单引号中**  转义单引号本身使用两个单引号来完成转义

### 去重

`DISTINCT`表示去重

查看不同部门的不同工种

```sql
select distinct detpno,job from emp;
```

**`distinct`的作用范围是作用于后面出现的所有的列名和表达式.**   (有别于升降序是针对单个最近的列名)

上面的例句中,不会出现重复的[detpno和job的组合].

### 表达式

select后可以接列名或表达式

```c
select empno,ename,sal,comm,sal*12 年薪,sal*12+nvl 年收入 from emp;
```

![image-20221015173450512](https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202210151735254.png)

**包含NULL值的表达式都返回为空**,因此所有COMM为空的,年收入也为空

解决方案如下:

```sql
select empno,ename,sal,comm,sal*12 年薪,sal*12+nvl(comm,0) 年收入 from emp;
```

`nvl(comm,0)`表示`nvl`如果`comm`为空,则当成0处理   [滤空函数参考](#通用函数)

![image-20221015173808216](https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202210151738265.png)

### 别名

select后接的列名或表达式或from后接的表名([多表查询](#多表查询))可以起别名   关键词: `as`

```sql
select empno,ename,sal as 工资,comm 奖金,sal*12 "年 薪" from emp;
```

注意:  

- as可以省略
- 如果别名中间有空格,需要使用`""`引起来(不加双引号,英语别名统一显示为大写)

**别名不能在where中直接替代表达式和列名使用.**

### 过滤

使用关键词  **`where`**  过滤出需要的数据行

#### 比较运算符

```c
=  等于(不是==)		>	大于
>= 大于等于		    <	小于
<= 小于等于			  <>	不等于(也可以是!=)
between…and:介于两值之间,闭区间,包含两边的值.
//过滤col1为空的数据,不能使用 where col1 = null(不正确);
过滤col1为空的数据: where coll is null;
过滤col1不为空的数据: where coll is not null;
//col1 = null  和  col1 != null 的这两个条件都返回假,不管他col1是什么值
```

#### 集合运算符

- `IN`	等于列表中的任意一个
- `ANY`	和集合返回的任意一个值比较   [配合子查询使用](#多行子查询)
- `ALL`	和集合返回的所有值比较     [配合子查询使用](#多行子查询)

```sql
in：在集合中       not in 不在集合中
//col in(1,2)等同于 col=1 or col=2
//col not in(1,2)等同于col!=1 and col!=2
```

[ `not in` 的`null`注意点参考](#子查询中null)

#### 模糊查找

```sql
like：模糊查询  //%匹配任意多个字符,  _匹配一个字符, 使用escape表示转义字符(下面案例有使用方式),转义单引号本身使用两个单引号来完成转义
```

#### 逻辑运算

```json
AND		逻辑并  (优先级依次往下)
OR 		逻辑或
NOT		逻辑非
//小括号可以调整优先级
```

SQL优化：SQL在解析where的时候，是**从右至左解析**的。

所以： 

- `and`时应该将易假的值放在右侧;
- `or`时应该将易真的值放在右侧.

#### 案例

```sql
select * from emp where ename = 'KING';
select * from emp where hiredate= '17-11月-81'
日期格式要与查询的时候一样,日期格式默认是DD-MON-RR
select * from emp where sal>=1000 and sal<=2000
select * from emp where sal between 1000 and 2000
select * from where deptno in(10,20);
//查询员工首字母为S的员工信息
select * from emp where ename like 'S%';
//查询员工编号为79开头的员工信息
select * from emp where empno like '79%';
//查询员工姓名为4个字母长度的员工信息
select * from emp where ename like '____';
//查询员工姓名包含下划线_的员工信息
select * from emp where ename like '%\_%' escape '\';
//escape后接的字符表示他是转义字符
```

**[重点]** **escape后接的字符表示他是转义字符**

注意:表中的列的值是区分大小写的,但关键词不区分大小写

### 排序

关键词: `order by`

基本格式: `select ... from ... where condition order by colname|alias|expr(表达式)|number(序号)`   (序号表示select后面出现的次序,从1开始)

ORDER BY子句在**SELECT语句的最末尾**, 是对select查询的最后的结果进行排序.

使用 ORDER BY 子句排序
•	`ASC（ascend）`: 升序。默认采用升序方式。
•	`DESC（descend）`: 降序

```sql
//员工信息按入职日期先后排序
select * from emp order by hiredate asc;(asc可以省略)
//查询员工信息按奖金逆序
select * from emp order by comm desc nulls last;
//查询员工编号,员工姓名和工资,按照序号(工资)进行排序
select empno,ename,sal from emp order by 3;
```

**[注意]  NULL在排序中表现为无穷大**    可以使用`nulls last`使null的信息放到最后.

**多元素排序**  : 对多个元素进行排序时,优先排序第一个元素,仅在第一个元素相同时对第二个元素进行排序,以此类推.







### 分组

分组数据使用**`group by`**关键字.	可以配合[分组函数](#分组函数)使用
$$
select\ \ ...,count()\ \ from\ \ emp \ \ where\ \ ...\ \ group\ \ by\ \ ...
$$
按照group by 后给定的表达式，将from后面的table进行分组。针对每一组，使用[组函数](#分组函数), 即先分组, 再分组统计.([where过滤部分数据](#过滤)可写可不写)

**[ [注意] ]**    **select后面存在没有出现在分组函数中的列名,一定要出现在group by子句中**  ,不然会报错.(常数可以不出现在group by子句中)

因为分组数据会限制行数,如果select出现了别的列名,那么这一组的别的列名的值会出现多个,但只能显示一行,显然就冲突了.

案例: 统计各个部门的平均工资

```sql
select deptno,avg(sal) from emp group by deptno;
```

![image-20221019163924637](https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202210191639980.png)

------

统计各个部分不同工种的平均工资

```sql
select deptno, job, avg(sal) from emp group by deptno, job; 
```

按照**deptno, job的组合**来分组.

<img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202210191720152.png" alt="image-20221019172030679" style="zoom: 67%;" />

### 分组函数过滤

只有使用关键词 **`having`**才能对[**分组函数**](#分组函数)进行过滤.(不能用where)

**[注意]** 

- **having必须配合group by使用**   不能单独存在
- **having后面不能使用别名**(where可以),可以使用函数
- 不能在where中使用组函数,**可以在having中使用组函数**

p.s.分组的情况下,having和where均可以对**非分组函数**进行过滤,下面两句效果一致:

```sql
select deptno,avg(sal) from emp where deptno!=10 group by deptno;
select deptno,avg(sal) from emp group by deptno having deptno!=10;
```

**分组函数过滤案例**

查询平均薪水大于2000的部门 ：

```sql
select deptno, avg(sal) from emp group by deptno having avg(sal)>2000;
```

#### 优化

在子句中没有使用组函数的情况下，where、having都可以，应该怎么选择？	

SQL优化： **尽量采用where**。
如果有分组的话，where是先过滤再分组，而having是先分组再过滤。当数据量庞大如1亿条，where优势明显。

## 单行函数

单行函数:只对一行进行变换，产生一个结果。函数可以没有参数，但必须要有返回值。

- 操作数据对象
- 接受参数返回一个结果
- 只对一行进行变换
- 每行返回一个结果
- 可以转换数据类型
- 可以嵌套
- 参数可以是一列或一个值

### 字符函数

-  `lower` 小写, `upper` 大写, `initcap`单词的首字母大写

- `concat`(连接符`||`)

  concat函数只能连接两个字符串, 若想连接三个的话只能嵌套调用;`||` 可以连接多个字符串, 建议使用||来连接字符串.

- `substr(str,pos,len)`截取字符串str,从pos位置开始截取len个

  注意:pos是从1开始的, 若len为0表示从pos开始, 截取到最后, 若pos为负数, 表示从末尾倒数开始截取

-  `instr(str, substr)`:判断substr是否在str中存在, 若存在返回第一次出现的位置, 若不存在则返回0

- lpad和rpad--`l(r)pad(str, len, ch)`:返回len长度的字符串, 如果str不够len的话, 在左(右)填充ch这个字符

- `trim(str)`:去掉字符串str首部和尾部的空格,中间的空格不去掉

  也可以`trim(c from str)`:去掉str中的c字符

-  `replace(str, old, new)`:将str字符串中的old字符串替换成new字符串

- length和lengthb

  `select length('hello world') 字符数, lengthb('hello world') 字节数 from dual;`
  注意:**对于length函数一个汉字是一个字符**, **对于lengthb函数,一个汉字占两个**,这两个函数对于普通字符串没有什么区别.

### 数值函数 

-  `round(n,m)`: 四舍五入,对n这个数值四舍五入保留小数点后m位
-  `trunc(n,m)`: 截取,对n这个数值截取小数点后m位前的内容
- `mod(n,m)`:n对m取余
- `ceil(n)`:对n向上取整;`floor(n)`:对n向下取整

### 转换函数

![image-20221016172705248](https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202210161727853.png)

**显示转换**：借助to_char(数据，格式)、to_number、to_date函数来完成转换。

**[注意]** 如果隐式、显示都可以使用，应该首选显示，这样可以省去oracle的解析过程。

![image-20221016172746213](https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202210161727812.png)

#### to_char函数

**功能**:将date或number类型转换成字符串类型

![image-20221019113415897](https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202210191135012.png)

案例:

查询员工的薪水: 使用2位小数, 本地货币代码, 千位符 	

```sql
select to_char(sal, 'L9,999.99') from emp;
```

特别注意:'L9,999.99'之间没有空格

<img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202210191138144.png" alt="image-20221019113747079" style="zoom: 50%;" />

------

[参考date的格式](#date的格式)

在屏幕上显示如下字符串：      
2015-05-11 16:17:06 今天是 星期一       

```sql
select to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss "今天是" day') from dual;
```

**说明**: 在**固定的格式里加入自定义的格式是可以**的，必须要加`””`。

![image-20221019114539105](https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202210191146163.png)

#### to_number函数

**功能**:将字符串转换成number类型

案例:

将￥2,975.00转化成数字2975：

```sql
select to_number('￥2,975.00', 'L9,999.99') 转成数字 from dual;  
```

#### to_date函数

**功能**:将字符串转换成date类型

已知字符串'2015-05-11 15:17:06 今天是 星期一'转化成日期.

```sql
select to_date('2015-05-11 15:17:06 今天是 星期一', 'yyyy-mm-dd hh24:mi:ss "今天是" day') 	from dual;
```

![image-20221019114858405](https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202210191149773.png)

------

求1980年12月17日入职的员工信息

```sql
select * from emp where hiredate = to_date('17-12月-80','DD-MON-RR');
```

#### date的格式

(格式不区分大小写)

| 格式      | 说明                                                     | 举例          |
| --------- | -------------------------------------------------------- | ------------- |
| YYYY      | Full year in numbers                                     | 2011          |
| RR        | 年份的后两个数字                                         | 11            |
| YEAR      | Year spelled out(年的英文全称)                           | twenty eleven |
| MM        | Two-digit value of month 月份（两位数字）                | 04            |
| MONTH/mon | Full name of the month（月的全称）                       | 4月           |
| DY        | Three-letter abbreviation of the day of the week(星期几) | 星期一        |
| DAY       | Full name of the day of the week                         | 星期一        |
| DD        | Numeric day of the month                                 | 02            |
| HH24      | 2位数字的24小时制的小时数                                | 11            |
| MI        | 2位数字的分钟数                                          | 52            |
| ss        | 2位数字的秒数                                            | 44            |

#### 时间和日期函数

`sysdate` 当前的系统时间    如:  `select sysdate from dual;`

oracle日期型+1 = 加一天

日期和日期可以**相减表示相隔多少天**, 但是**不允许相加**, 两个日期相加没有意义(报错: `ORA-00975`: 不允许日期 + 日期), **日期只能和数字相加**

上面方式如果计算月差,年差,周差,等可以分别除以30,365,7.但这样计算显然是不精确的

如下日期函数才来精确计算

- `months_between(date1,date2)`   计算date1-date2的月差
- `add_months(date,n)`   date日期增加n个月
- `last_day(date)`  date日期的这个月的最后一天
- `next_day(date,'星期一')`   date日期的下一个星期一
- `round(date,'month')`  date日期按月份四舍五入(过了一半就加1,没过一半就不加)
- `trunc(date,'year')` date日期按年份截断(月份和日数归最小),按月截断的话表示日数归最小

### 通用函数

这些函数适用于任何数据类型，同时也适用于空值：

- **`NVL (expr1, expr2)`**     滤空函数： 如果expr1为NULL，返回expr2

- **`NVL2 (expr1, expr2, expr3)`**    滤空函数： 如果expr1为NULL，返回expr3,否则返回expr2

- **`NULLIF (expr1, expr2)`**   当 expr1 = expr2 时返回null, 不相等的时候返回expr1值。

- **`COALESCE (expr1, expr2, ..., exprn)`**   找非空值函数  从左向右找参数中第一个不为空的值。

  <img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202210191431201.png" alt="image-20221019143055678" style="zoom:67%;" />

## 分组函数

分组函数:也称之为组函数或者聚合函数,oracle提供的常用的有5个函数: avg、count、max、min、sum操作的是一组数据，返回一个结果。     可以配合[分组数据](#分组)使用(select后同时存在分组函数和非分组函数的情况下,必须配合[分组数据](#分组)使用)

- **`count(列名或1)`**  计算行数(滤空)  1表示只要有值,都算+1;列名表示按照该列名算行数

  `select count(distinct job) from emp`显示工作总数(去重才能计算到工作总数) 

- **`avg(列名)`**  求平均列值(滤空)      注意: `avg(comm)`   等同于   `sum(comm)/count(comm)` (滤空) 而非`sum(comm)/count(empno)` (不滤空),前者是有奖金的人的奖金平均值,后者是全部人平均奖金的值

  ![image-20221019161354607](https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202210191613017.png)

- **`max(列名)`**  求列值最大值(滤空)

- **`min(列名)`**  求列值最小值(滤空)

- **`sum(总和)`**   求列值总和(滤空)

**总结 : 分组函数自带滤空功能**

可以通过 [nvl函数](#通用函数) 去掉分组函数的滤空功能,如下

```sql
select avg(nvl(comm,0)) from emp;
```

#### count注意点

`count(*)`和`count(e.empno)`的区别:

- `count(*)` 只要一行中有一个字段不为空就被统计上
- `count(e.empno)` 只有`e.empno`不为空才会被统计上
- **[注意]** 不能使用`count(e.*)`, 会报错.应该写成某个表的具体的列.

## 条件表达式与条件函数

在SQL中无法实现if else 逻辑。当有这种需求的时候，可以使用case 或者 decode

### case条件表达式

case:是一个**表达式**，其语法为：

```sql
CASE expr  WHEN comparison_expr1 THEN return_expr1
[WHEN comparison_expr2 THEN return_expr2
 WHEN comparison_exprn THEN return_exprn
 ELSE else_expr]
END
```

上面代码解释,根据expr列名或表达式来判断,when后面的为判断值,如果expr = 该值,则返回return_expr1表达式.else后接when没提到的情况的返回值else_expr.

**案例**

老板打算给员工涨工资, 要求：
总裁(PRESIDENT)涨1000, 经理(MANAGER)涨800, 其他人涨400. 请将涨前, 涨后的薪水列出。

```sql
select ename, job, sal 涨前薪水, 	
case job 
when 'PRESIDENT' then sal+1000 
when 'MANAGER'   then sal+800 
else  sal + 400
end 涨后薪水 
from emp;  
```

<img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202210191532530.png" alt="image-20221019153254072" style="zoom:67%;" />

### decode函数

decode：是一个**函数**，其语法为：

```sql
DECODE(col|expression, search1, result1 
			[, search2, result2,...,]
			[, default])
```

除第一个和最后一个参数之外，中间的参数都是成对呈现的 `(参1, 条件, 值, 条件, 值, …, 条件, 值, 尾参)`

**案例**

题目与效果图等同于case条件变量案例

```sql
select ename, job, sal 涨前薪水, decode(job, 'PRESIDENT', sal + 1000,  
'MANAGER', sal + 800,  
sal + 400) as 涨后薪水 
from emp;
```

## 多表查询

只要select后出现多表重复存在的列名,则需要标识列名属于谁,如:

```sql
select e.deptno from emp e,dept d;
```

否则报错:  `ORA-00918: 未明确定义列`

### 笛卡尔积

两个表的笛卡尔积 = 两个表的项之间组合的所有可能的集合

笛卡尔积的行数 = table1的行数 x table2的行数
笛卡尔积的列数 = table1的列数 + table2的列数

![image-20221020165843162](https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202210201658550.png)

笛卡尔积中包含不正确的无用数据.上图中很显然左表(黄)和右表(绿)的deptno匹配会出现不相等的情况,即无效数据.(添加图中连接条件可以去除无效行)

多表查询就是按照给定条件(连接条件)，从笛卡尔全集中选出正确的结果。

### 连接条件

- `Equijoin`：等值连接
- `Non-equijoin`：不等值连接
- `Outerjoin`：外连接
- `Selfjoin`：自连接

#### 等值连接

只返回满足连接条件的数据（两边都有的才显示）。

where子句后面的条件，是“=”为等值连接。

```sql
select e.*,d.* from emp e, dept d where e.deptno = d.deptno;
```

#### 不等值连接

where子句后面的条件，不是“=”为不等值连接。

```sql
select e.empno,e.ename,e.sal,s.grade from emp e,salgrade s where e.sal<=s.hisal and e.sal>= s.losal;
```

#### 外连接

按部门统计员工人数，显示： 部门号 部门名称 人数

```sql
select d.deptno,dname,count(e.empno) from dept d,emp e where d.deptno = e.deptno group by dname,d.deptno;
```

![image-20221020180059609](https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202210201801063.png)

虽然显示了如上结果,但因为`where d.deptno = e.deptno`,缺失了40号部门

##### 右外连接

右边deptno显示全

写法：与叫法相反：`where e.deptno(+)=d.deptno`

```sql
select d.deptno,dname,count(e.empno) from dept d,emp e where e.deptno(+)=d.deptno group by dname,d.deptno;
```

##### 左外连接

左边deptno显示全

写法：与叫法相反：`where d.deptno=e.deptno(+)` 

左外连接和右外连接效果完全一样,只是顺序不同.

**[重点]**  **`(+)`符号加在哪就看两边的行数想要显示全,就在另一边加上该符号**

#### 自连接

核心，通过表的别名，将同一张表视为多张表。

查询员工信息：xxx的老板是 yyy 

```sql
select e.ename || '  的老板是 ' || b.ename from emp e, emp b where e.mgr=b.empno;
```

<img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202210211432867.png" alt="image-20221021143252478" style="zoom:50%;" />

由于KING没有老板,所以可以使用外连接的方式把king也显示出来:

```sql
select e.ename || '  的老板是 ' || nvl(b.ename,'没有') from emp e, emp b where e.mgr=b.empno(+);
```

<img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202210211602703.png" alt="image-20221021160247799" style="zoom:67%;" />

## 子查询

子查询语法很简单，就是select 语句的嵌套使用,即**sql嵌套sql**。

语法格式: 主查询的where、select、having、from后都可以放置子查询,如下:

```sql
SELECT	select_list
FROM	table
WHERE	expr operator
			(SELECT	select_list
		   FROM		table);
```

查询工资比SCOTT高的员工信息.

1. 查出SCOTT的工资

   `select ename, sal from emp where ename='SCOTT'; 结果为3000`

2. 查询比3000高的员工

   `select * from emp where sal>3000;  `

通过两步可以将问题结果得到。子查询，可以将两步合成一步。

```sql
select * 
from emp  
where sal  >  (select sal  
					     from emp  
					      where ename='SCOTT');
```

- 写一个较复杂的子查询的时候,要合理的添加换行,缩进
- 主查询的where、[select](#select后子查询案例)、[having](#having后子查询案例)、[from](#from后子查询案例)后都可以放置子查询
- 强调：在from后面放置的子查询(...), from后面放置是一个集合(表、查询结果)
- 一般不在子查询中使用order by, 但在[Top-N分析问题](#top-N问题)中，必须使用`order by`  
- **子查询可以放在select后，但，要求该子查询必须是单行子查询：(该子查询本身只返回一条记录，2+叫多行子查询)**
- **单行子查询只能使用单行操作符；多行子查询只能使用多行操作符**

### where后子查询案例

参考第一个例子.

### select后子查询案例

查询10号部分员工号,员工姓名,部门编号,部门名称

```sql
select e.empno,e.ename,e.deptno,(select dname from dept where deptno=10) from emp e where deptno = 10;
```

此处的子查询(select后)必须是**单行子查询**.

### having后子查询案例

查询部门平均工资高于20号部门平均工资的部门和平均工资

```sql
select deptno,avg(sal) 
from emp 
group by deptno 
having avg(sal)>(select avg(sal) 
                 from emp 
                 where deptno=20);
```

### from后子查询案例

查询员工的姓名、薪水和年薪：要求格式为:`select * from ___________________`

```sql
select * from (select ename 姓名,sal 薪水,sal*12+nvl(comm,0) 年薪 from emp);
```

### 多行子查询

子查询返回2条记录以上就叫多行。

多行操作符有：	

- `IN`		等于列表中的任意一个
- `ANY`	  和子查询返回的任意一个值比较
- `ALL`		和子查询返回的所有值比较

**案例**

查询薪水比30号部门任意一个员工高的员工信息

```sql
单行子查询方式min实现:
select * from emp where sal > (select min(sal) from emp where deptno=30);  
多行子查询方式ANY实现
select * from emp where sal > any(select sal from emp where deptno=30);
```

------

查询薪水比30号部门所有员工高的员工信息。

```sql
单行子查询方式max实现:
select * from emp where sal > (select max(sal) from emp where deptno=30);
多行子查询方式ALL实现
select * from emp where sal > all (select sal from emp where deptno=30); 
```

### 单行子查询

单行子查询就是该条子查询执行结束时, 只返回一条记录(一行数据)。

使用单行操作符:
=、>、>=、<、<=、<>或者!=	

### 子查询中null

判断一个值等于、不等于空，不能使用=和!=号，而应该使用is 和 not。

**[ [特别注意] ]**  如果**集合中有NULL值，不能使用not in**。如： not in (10， 20， NULL)，但是可以使用in。

```c
//用等于号与不等于号和null做比较都返回假
值 =  null   //返回假
值 != null   //返回假
```

因为, not in操作符等价于 !=All，最后一个表达式为假，整体假;
而a in (10, 20, NULL)等价于(a = 10) or (a = 20) or (a = null)只要有一个为真即为真。
		in 操作符等价于 = Any 

### 子查询优化

> 一般情况下，子查询使用order by或是不使用order by对主查询来说没有什么意义。子查询的结果给主查询当成集合来使用，所以没有必要将子查询order by。
> 但，在Top-N分析问题中，必须使用order by

**SQL优化**: 理论上，既可以使用子查询，也可以使用多表查询，尽量使用“多表查询”。子查询有2次from, 与数据库服务的交互多.

### top-N问题

Top-N指排名前N相关的问题

解决top-N问题使用了一个关键词   **`rownum`   (行号)**

**`rownum`的生成是在集合第一次产生的时候就生成了.**  可以将查询的结果看成一个表来用

通过子查询排序的方式得到一个临时表,在外部查询中按照rownum来区分排名.   参考如下案例:

查询emp表中工资在5-8的员工信息

```sql
select rn 排名,d.* from (select rownum rn,e.* from (select * from emp order by sal) e) d where rn<=8 and rn>=5;
```

**[讲解]** 二级子查询中,子集合中的rownum不是列名的话,不能在上级查询中被作为筛选条件,解决方式是给rownum提供一个别名,再多加一层子查询,使最外部查询中`rownum的别名`成为一个列名,以此参与筛选.

结果:![image-20221028161825421](https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202210281618481.png)

## 集合运算

集合运算的操作符。`A ∩ B`、`A ∪ B`、`A - B`  			

![image-20221023134056913](https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202210231341844.png)

**`union`和`union all`的区别**: `union`会去掉重复的, 而`union all`会全部显示

**集合运算注意点**

- 参与运算的各个集合必须**列数相同**，且对应**每个列的类型一致**。(不然会报错类型不一致:`ORA-01790` 或 列数不同:`ORA-01789`)
- 采用第一个集合的表头作为最终使用的表头.
- 可以使用括号()先执行后面的语句。

**案例**

按照部门统计各部门不同工种的工资情况，要求按如下格式输出：

![image-20221023151906466](https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202210231519944.png)

照集合的要求,必须列数相同,类型一致,所以写法如下,使用null强行占位!

```sql
select deptno,job,sum(sal) from emp group by deptno,job
union
select deptno,to_char(null),sum(sal) from emp group by deptno
union
select to_number(null),to_char(null),sum(sal) from emp;	
```

**sql优化**  :  集合运算的性能一般较差









## 一些tips

尽量使用列名，用列名代替* (oracle 9i之前不同， 之后一样)

`sysdate`可以作为列名在select后使用,表示当前日期,如果from后面不来源于任何表,可以使用伪表`dual`

## 综合案例

**查询部门工资大于本部门平均工资的员工信息**

先查询10号部门:
      使用子查询:

```sql
select e.deptno,
		       e.empno,
		       e.ename,
		       e.sal,
		       (select avg(sal) from emp where deptno = 10) 
		  from emp e
		 where e.deptno = 10
		   and e.sal > (select avg(sal) from emp where deptno = 10);
```

推广到所有部门   (其实就是`10`换成`e.deptno`)

```sql
select e.deptno,
		       e.empno,
		       e.ename,
		       e.sal,
		       (select avg(sal) from emp where deptno = e.deptno)
		  from emp e
		 where e.sal > (select avg(sal) from emp where deptno = e.deptno)
		 order by e.deptno;
```

上述是一种解决方案,也可以:使用多表查询:

```sql
select e.deptno, e.empno, e.ename, e.sal, d.avgsal
		  from emp e,
		       (select deptno, avg(sal) avgsal from emp group by deptno) d
		 where e.deptno = d.deptno
		   and e.sal > d.avgsal;
```

------

**从emp表中查询, 结果显示如下的格式:**

```
Total  1980   1981  1982  1987
-----  -----  ----- ----- -----
 14     1     10     1      2
```

sql如下:

```sql
select count(empno) "Total",
          sum(decode(to_char(hiredate, 'YYYY'), '1980', 1, 0)) "1980",
          sum(decode(to_char(hiredate, 'YYYY'), '1981', 1, 0)) "1981",
          sum(decode(to_char(hiredate, 'YYYY'), '1982', 1, 0)) "1982",
          sum(decode(to_char(hiredate, 'YYYY'), '1987', 1, 0)) "1987"
from emp;
```

[decode函数跳转](#decode函数)

# 事务

**数据库事务**，是由有限的数据库操作序列组成的逻辑执行单元，这一系列操作要么全部执行，要么全部放弃执行。

数据库事务由以下的部分组成:

- 一个或多个DML 语句
- 一个 DDL(Data Definition Language – 数据定义语言) 语句
- 一个 DCL(Data Control Language – 数据控制语言) 语句

事务的**特点**：**要么都成功，要么都失败**。

## **事务的特性**

ACID: 原子性,一致性,隔离性,持久性

- **原子性(Atomicity)**：事务中的全部操作在数据库中是不可分割的，要么全部完成，要么均不执行。
- **一致性 (Consistency)**：几个并行执行的事务, 其执行结果必须与按某一顺序串行执行的结果相一致。
- **隔离性(Isolation)**：事务的执行不受其他事务的干扰，当数据库被多个客户端并发访问时，隔离它们的操作，防止出现：脏读、幻读、不可重复读。
- **持久性 (Durability)**：对于任意已提交事务，系统必须保证该事务对数据库的改变不被丢失，即使数据库出现故障。 

## 事务的流程

事务的**起始标志**：oracle中自动开启事务，以DML语句为开启标志。

> 执行增删改查语句, 只要没有提交commit和回滚rollback, 操作都在一个事务中.

事务的结束标志: 提交、回滚都是事务的结束标志。

### 提交与回滚

- 提交

  1.显示提交: `commit` 
  2.隐式提交

  1. **任何DDL语句**，如：`create table`除了创建表之外还会隐式提交Create之前所有没有提交的DML语句。
  2.  **正常退出**(exit / quit)

- 回滚

  1.**显示回滚**: `rollback` 
  2.**隐式回滚**: 掉电、宕机、非正常退出。

## 控制事务

**保存点（savepoint）**可以防止错误操作影响整个事务，方便进行事务控制。

![image-20221024143654530](https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202210241436648.png)

- **设置保存点**aaa   `savepoint aaa;`
- **回滚到保存点**aaa   `rollback to savepoint aaa;`

`savepoint`主要用于在事务上下文中声明一个中间标记, 将一个长事务分隔为多个较小的部分,和我们编写文档时, 习惯性保存一下一样, 都是为了防止出错和丢失。如果**保存点设置名称重复，则会删除之前的那个保存点**。一旦**commit之后，所有的savepoint将失效**。

回滚的操作,会将**回滚过程中的"设置保存点行为"也回滚掉.**

## 隔离级别

对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:

- **脏读**: 对于两个事物T1, T2; T1读取了已经被T2更新但还没有被提交的字段. 之后, 若 T2 回滚, T1读取的内容就是临时且无效的
- **不可重复读**: 对于两个事物 T1, T2; T1 读取了一个字段, 然后 T2 更新了该字段. 之后, T1再次读取同一个字段, 值就不同了.
- **幻读**: 对于两个事物 T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插入了一些新的行. 之后, 如果 T1 再次读取同一个表, 就会多出几行.

**数据库事务的隔离性**: 数据库系统必须具有**隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题.** 

一个事务与其他事务隔离的程度称为**隔离级别**. 数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, **隔离级别越高, 数据一致性就越好, 但并发性越弱**.

### SQL99定义4中隔离级别

1. `Read Uncommitted`	读未提交数据。
2. `Read Commited`	读已提交数据。	（Oracle默认）
3. `Repeatable Read`	可重复读。		（MySQL默认）
4. `Serializable`		序列化、串行化。（查询也要等前一个事务结束）

Oracle支持的隔离级别： `Read Commited`（默认）和 `Serializable`，以及Oracle自定义的`Read Only`三种。

`Read Only`：由于大多数情况下，在事务操作的过程中，不希望别人也来操作，但是如果将别人的隔离级别设置为Serializable（串行），但是单线程会导致数据库的性能太差。是应该允许别人来进行read操作的。

# oracle开发

oracle开发需要使用**occi库**

- Windows下开发需要先下载开发包,具体操作参考[此链接](https://www.freesion.com/article/4985586791/)
- Linux下下载oracle安装包有自带,通过`locate libocci.so`查找

## OCCI

> Oracle C++调用接口 -- `OCCI` 即 `Oracle C++ Call Interface`
> OCCI 是Oracle 的C++ API, 允许你使用面向对象的特性、本地类、C++语言的方法来访问Oracle数据库

### OCCI介绍

- 优势

  - 基于标准C++和面向对象的设计

  - 效率较高

  - 适合开发C/S模式的程序,软件中间层

- 特性
  - 完整支持SQL/PLSQL
  - 为不断增长的用户和请求提供弹性选项
  - 为使用用户自定义类型,如C中的类,提供了无缝接口
  - 支持所有的Oracle数据类型以及LOB types(大对象)
  - 可以访问数据库元数据

### OCCI项目配置

#### 头文件

```c++
#include <occi.h> -- 程序中只需要包含这一个头文件
#include <occiCommon.h>
#include <occiControl.h>
#include <occiData.h>
#include <occiObjects.h>
```

#### 库文件

- Windows

  - `oraocci11.lib` 或 `oraocci11d.lib`

  - `oraocci11.dll` 或 `oraocci11d.dll`

    (前者为release模式时使用，名字末尾带d的后者为debug模式时使用。)
    
  - 库文件路径:`oci/lib/msvc/vc14`

  - 头文件路径:`oci/include`

- Linux

  - `libnnz11.so`
  - `libocci.so`
  - `libclntsh.so`

#### linux下的环境配置

-----root用户下进行配置------

1. 将oracle_client_11gR2.tar.gz文件上传到linux操作系统的`/opt`目录下

2. 执行`tar -zxvf oracle_client_11gR2.tar.gz`解压至当前目录下

3. 进入到刚刚解压的目录, 打开`<<Hi-看我,看我.sh>>`

4. 将文件中的export导出的环境变量拷贝到root用户的`.bashrc`文件中

   注意: 若解压的目录不是`/opt`, 环境变量中的路径需要修改

5. 执行`..bashrc`或者`source .bashrc` 或者退出再次登录使配置的环境变量生效

   可以执行`echo $OCCI_HOME`进行查看, 若看到内容则设置成功

6. 可以设置远程oracle服务器

   切换到`/opt/instantclient_11_2/network/admin`目录下

   打开`tnsnames.ora`文件, 修改其中的HOST部分, 将IP修改成实际的oracle服务的IP地址

7. occi.cpp测试代码上传到root用户下

   然后执行: `g++ -o a.out occi.cpp -locci -lclntsh`, 编译通过表明设置的没有问题.

   若执行报错, 查看一下代码中的oracle的用户名和密码是否正确.

#### 常见的几个环境变量

```shell
PATH:命令或者可执行程序搜索的路径
C_INCLUDE_PATH:gcc编译器查找头文件的路径
CPLUS_INCLUDE_PATH: g++编译器查找头文件的路径
LD_LIBRARY_PATH:查找动态链接库的路径
LIBRARY_PATH: 查找静态库的路径
```

```shell
oracle用户安装了oracle服务系统, 本身就有oracle编程需要的库文件和头文件:
> export OCCI_HOME=/u01/app/oracle/product/11.2.0/db_1
> export OCCI_INCLUDE_DIR=$OCCI_HOME/rdbms/public
> export OCCI_LIBRARY_PATH=$OCCI_HOME/lib
> export LD_LIBRARY_PATH=$$LD_LIBRARY_PATH:$OCCI_LIBRARY_PATH
>
> 程序编译时搜索的库目录
>
> export LIBRARY_PATH=$$LIBRARY_PATH:$OCCI_LIBRARY_PATH
>
> 程序编译时搜索的头文件目录
>
> export CPLUS_INCLUDE_PATH=$$CPLUS_INCLUDE_PATH:$OCCI_INCLUDE_DIR
>
> 上面的环境变量中OCCI_HOME和OCCI_INCLUDE_DIR与在root中的配置不同, 其余相同
```

### occi使用

#### 开发流程

**初始化** - Environment类

- OCCI通过创建一个Environment的对象完成初始化工作。
- 可以通过Environment创建数据库连接，从而进行其它的操作
- 要创建Environment，应该调用Environment类的静态方法`createEnvironment()`

```cpp
// 初始化环境   (返回NULL表示失败)
Environment *env = Environment::createEnvironment();

//关闭环境
Environment::terminateEnvironment(env);
```

**连接数据库** - Connection 类

```cpp
Connection *Environment::createConnection(const string &userName,const string &password,const string &connectString);
//第一个参数:用户名
//第二个参数:密码
//第三个参数:数据库连接串,"IP地址:端口号/数据库服务名"
```

- 连接数据库通过Connection类的对象实例实现
- 调用Environment类的`createConnection()`方法可以创建一个Connection对象；
- 使用Environment::terminateConnection()断开连接

```cpp
// 函数调用
const string userName = "scott"; // 用户名
const string passwd = "tiger"; // 密码
const string connstr = "localhost:1521/orcl"; // 数据库连接串
Connection* conn = env->createConnection(userName, passwd, connstr);
// 断开连接
env->terminateConnection(conn);
```

**执行SQL**

**`Statement类`**用于执行SQL语句,并获取返回结果。
**`ResultSet类`**用于处理SELECT 查询的结果。
对于所有类型的数据的绑定或者获取，OCCI都提供了统一的方法

- setXXX 方法用于Statement
- getXXX 方法用于Statement & ResultSet

OCCI会自动处理类型之间的转换。
使用方法：
使用`Connection::createStatement()`创建Statement对象, 指定 SQL 命令(DDL/DML/query)作为参数

#### 常用API

```cpp
// 操作函数
Connection::createStatement(string &sql);
Statement::setSQL(string &sql);//如果上面函数未传参,则可调用该函数,也可不调用该参数,直接调用下面的各种execute函数传参
Statement::execute(string &sql); // can be used for any SQL, returns status它会返回一个布尔值，指示是否可以检索ResultSet对象。如果返回值为true，则可以使用getResultSet()方法获取查询结果。
Statement::executeUpdate(string &sql); // returns Insert/Update/Delete count,注意该函数不能执行select查询,返回值表示受影响的行数
Statement::executeQuery(string &sql); // returns ResultSet（结果集）该函数才能执行select查询(针对上一个函数).通哟ResultSet的next()函数遍历每个查询到的行,getString,getInt等函数通过传参1,2,3...获取每行的每一项
```

> 使用 setXXX 方法传递要绑定用于输入的值
> 使用合适的execute方法执行SQL
> 对于SELECT 查询, 使用ResultSet 对象处理返回结果

执行插入的案例:

```cpp
// 插入操作
Statement *stmt = conn->createStatement(“ insert into Dept(Deptno,Dname, Loc) values (1,
‘ACCOUNTS’, ‘ZONE1’ ”);
stmt->executeUpdate();
conn->terminateStatement(stmt); // 关闭查询, 释放资源
```

使用绑定参数的DML（数据操作语句）示例：

```cpp
Statement *stmt = conn->createStatement(“ insert into Emp(EmpNo,Ename) values(:1, :2) ”);
//1 and 2 are bind placeholders
int empno = 2;
string empname = “JOHN W”;
//first parameter is bind position, second is value
stmt->setInt(1, empno);
stmt->setString(2, empname);
stmt->executeUpdate();
```

#### oracle简易案例

```c++
#include <iostream>
#include "occi.h"
#include <string>
using namespace std;
using namespace oracle::occi;

int main()
{
  // 初始化连接环境
  Environment *env = Environment::createEnvironment();
  // 创建连接
  string userName = "scott";
  cout << "userName:" << userName << endl;
  string passwd = "tiger";
  string connstr = "localhost:1521/orcl"; // 1521是oracle的默认端口
  // conn是建立连接之后得到的对象
  Connection* conn = NULL;
  try
  {
      conn = env->createConnection(userName, passwd, connstr);
  }
  catch (const std::exception& e)
  {
      cout << "捕获到异常"<<endl;
      cout << e.what() << endl;
      cout<<conn<<endl;
  }
  if (conn == NULL)
  {
    cout << "连接失败..." << endl;
    return -1;
  }
  cout << "数据库连接成功..." << endl;
  // 创建一个用户操作sql对象
  // 可以给这个函数指定sql语句,也可以不指定
  Statement *stat = conn->createStatement();
  // 如果没有指定执行的sql可以通过set方法指定
  string sql = "select * from dept";
  stat->setSQL(sql);
  // 执行sql语句
  ResultSet *resSet = stat->executeQuery(sql);
  // 取出所有的记录
  while (resSet->next())
  {
    // 每循环一次读一条记录
    // 读出这条记录的三个字段
    int no = resSet->getInt(1);
    string str1 = resSet->getString(2);
    string str2 = resSet->getString(3);
    cout << no << "" << str1 << "" << str2 << endl;
  }
  conn->terminateStatement(stat);
  env->terminateConnection(conn);
  // 释放资源
  Environment::terminateEnvironment(env);
  std::cout << "end" << std::endl;
  return 0;
}
```

编译命令为:

```shell
g++ -o a.out occi.cpp -I$ORACLE_HOME/rdbms/public -L$ORACLE_HOME/lib -locci -lclntsh
```

执行返回结果为:

```shell
userName:scott
数据库连接成功...
10ACCOUNTINGNEW YORK
20RESEARCHDALLAS
30SALESCHICAGO
40OPERATIONSBOSTON
end
```

## ORA-24550

在使用occi多线程访问oracle服务器的时候,会出现ORA-24550错误,错误信息如下:

```
ORA-24550 : signal received : [si_signo=11] [si_errno=0] [si_code=50] [si_adr =
2020202020202020] killed
```

该错误会导致进程终止, 修改方案如下:

1. 使用fifind命令所有oracle服务器端的 `sqlnet.ora` 文件, 在文件中添加下配置项:

   ```shell
   DIAG_ADR_ENABLED=OFF
   DIAG_SIGHANDLER_ENABLED=FALSE
   DIAG_DDE_ENABLED=FALSE
   ```

2. 如果该问题还未解决, 在调用 OCCI 接口的客户端对应oracle目录中, 例如, 我的客户端对用的oralce目录为
   `/opt/instantclient_11_2` , 在该目录下的 `network/admin` 中添加文件 `sqlnet.ora` , 内容如下:

   ```shell
   SQLNET.AUTHENTICATION_SERVICES= (NTS)
   NAMES.DIRECTORY_PATH= (TNSNAMES,HOSTNAME)
   DIAG_ADR_ENABLED=OFF
   DIAG_SIGHANDLER_ENABLED=FALSE
   DIAG_DDE_ENABLED=FALSE
   ```

# Mysql

瑞典MySQL AB公司开发，由SUN收购，而后SUN被甲骨文并购，目前属于Oracle公司。

MySQL是一种关联数据库管理系统 由于其**体积小、速度快、总体拥有成本低**、MySQL软件采用了双授权政策，分为社区版和企业版。

oracle部分linux系统用不了,但mysql没有这个问题

## MySQL版本及下载

MySQL数据库版本相对比较繁杂。常见的有：`Community`社区版、`Enterprise`企业版。

- `Community`版是开源免费的，这也是我们通常用的MySQL的版本。可以满足绝大多数用户需求。
- `Enterprise`版，官方指出提供30天免费试用期。可进一步划分为MySQL标准版、MySQL企业版、MySQL集群版。官方提供付费服务。

其中`Community Server` 可以直接从mysql 的官网下载。但`Enterprice Edition`只能从`Oracle edelivery`上下载，而`Edelivery`有时会屏蔽中国IP。

下载mysql时注意区分版本细节及所应用的系统平台：linux(32/64) 、win(32/64)

GA 是指软件的通用版本，一般指正式发布的版本 `(Generally Available (GA) Release)`

- `mysql-essential-5.1.60-win32.msi`精简版，如果只需要mysql服务，就选择此版本。
- `mysql-5.1.60-win32.msi` 完整版，包含安装程序和配置向导，有MySQL文档。  
- `mysql-noinstall-5.1.60-win32.zip` 是非安装的zip压缩包，没有自动安装程序和配置向导，无安装向导
- `mysql-5.1.60.zip` 是用于windows的Mysql源码压缩包

默认情况下,linux都会有mysql

### red hat

#### 卸载

**red hat linux演示如何卸载mysql**

在终端提示符输入：`rpm -aq | grep -i mysql`	命令。查询mysql是否安装

**卸载旧的版本操作**

1. `rpm -e 软件包名 --nodeps --allmatches` (不理会依赖关系，删除所有上一步查出来的相同的mysql)

   `rpm -e mysql-connector-odbc-3.51.26r1127-1.el5 --nodeps --allmatches`

   `rpm -e libdbi-dbd-mysql-0.8.1a-1.2.2 --nodeps --allmatches`

   `rpm -e mysql-server-5.0.77-3.el5 --nodeps --allmatches`

2. 将老版本的几个残留文件手动删除

   ```shell
   rm -f /etc/my.cnf
   rm -rf /var/lib/mysql
   rm -rf /var/share/mysql
   rm -rf /usr/bin/mysql*
   ```

#### 安装

**red hat linux演示如何安装mysql**

解压.zip安装包
`unzip V46610-01-MySQL Database 5.6.20 RPM for Oracle Linux RHEL 6 x86 (64bit).zip`

得到如下软件包

```c
//下面三个必装
MySQL-client-advanced-5.6.20-1.el6.x86_64.rpm
MySQL-devel-advanced-5.6.20-1.el6.x86_64.rpm
MySQL-server-advanced-5.6.20-1.el6.x86_64.rpm
//下面可选
MySQL-embedded-advanced-5.6.20-1.el6.x86_64.rpm
MySQL-shared-advanced-5.6.20-1.el6.x86_64.rpm
MySQL-shared-compat-advanced-5.6.20-1.el6.x86_64.rpm
MySQL-test-advanced-5.6.20-1.el6.x86_64.rpm
//可以参考README.txt
README.txt
```

安装服务器  `rpm -ivh MySQL-server-advanced-5.6.****-1.el6.x86_64.rpm`

第一次安装,会自动生成一个文件`/root/.mysql_secret`,文件内含mysql的root用户的密码.因此必须在第一次连接的时候修改此处的密码

`mysql_secure_installation` 配置安全选项

默认配置设置文件在 ` /usr/my.cnf ` ,可以编辑这个 文件改变mysql服务器设置

##### 安装客户端

`rpm -ivh MySQL-client-advanced-5.6.****-1.el6.x86_64.rpm`

说明:不安装`mysql-client`是不能使用mysql工具登陆到mysql数据库

修改密码  `mysql> set password=password('123456'); 	将密码设置为：123456`

### ubuntu

#### 安装

ubuntu下安装:  `apt-get install mysql-server`     (root无初始密码)

设置MySQL的root初始密码:  `ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'your_password';`

`mysql_secure_installation`这个命令设置mysql安全配置向导

1. 是否建立密码验证插件（用以验证密码强度）：n

2. 首次运行则会要求输入并确认root密码，设置过第2步的root初始密码则会提示是否修改密码。

   如果遇到以下报错，请先执行上面第2步的设置root初始密码：

   ```shell
   Failed! Error: SET PASSWORD has no significance for user ‘root’@’localhost’ as the authentication method used doesn’t store authentication data in the MySQL server. Please consider using ALTER USER instead if you want to change authentication parameters.
   ```

3. 是否删除匿名用户：y

4. 是否禁止root远程登陆：n

5. 是否删除test数据库：y

6. 刷新权限：y

给root账号开放所有权限:  `GRANT ALL PRIVILEGES ON *.* TO root@'localhost';`

检查mysql服务状态  `sudo systemctl status mysql`

mysql服务的启动/停止/重启

```shell
# 启动MySQL服务
service mysql start
# 停止MySQL服务
service mysql stop
# 重启MySQL服务
service mysql restart
```

如果要安装客户端和开发组件要分别执行下面语句

```shell
sudo apt install libmysqlclient-dev	
sudo apt-get install mysql-client
```

#### 卸载

`apt autoremove mysql-server`

## mysql的基本操作

`mysql -u用户名 -p密码`进入本地mysql命令行    e.g.`mysql -uroot -p12345`

若想进入远程数据库,需要使用参数`-h192.168.0.3`指定远程主机ip地址

退出登录 `quit/exit`

在MySQL中，您可以使用`CREATE USER`语句创建新用户。创建新用户的基本语法如下：`CREATE USER 'username'@'host' IDENTIFIED BY 'password';`，其中`username`是您要创建的用户的名称，`host`是用户可以连接的主机（可以是特定的IP地址或通配符，例如`%`表示任何主机），而`password`是新用户的密码 。

创建用户后，您需要为他们授予适当的权限，以便他们能够访问和操作MySQL服务器上的数据库和表。这可以使用`GRANT`语句完成 。例如，要将所有权限授予`test`数据库中的`johndoe`用户，您可以使用以下命令：`GRANT ALL PRIVILEGES ON test.* TO 'johndoe'@'%';`。需要注意的是，创建用户后，您必须刷新权限以反映所做的更改，方法是运行 `FLUSH PRIVILEGES;` 。

### 数据库CURD

对数据库进行增(create)、删(delete)、改(update)、查(Retrieve)操作

**[注意] mysql中数据库名和表名都区分大小写**

**组织结构**

- oracle是先有库,库下是用户,用户下再有表
- mysql是先有用户,用户下是库,库下是表

![image-20221030113604065](https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202210301136512.png)

操作盘点

- **显示已有的所有数据库** `show databases`

- **显示建数据库的语句** `show create database 数据库名`

- **新建数据库**  `create database 数据库名`

  创建字符集为utf-8的数据库:`create database 数据库名 character set utf8;` 

  创建字符集为utf-8并会对存入的数据进行检查是否utf8格式的数据库 `create database 数据库名 character set utf8 collate utf8_general_ci;`

  如果不存在才新建数据库  `create database if not exists 数据库名`

- **删除数据库**  `drop database 数据库名`

- 修改数据库字符集(不能修改数据库名) `alter database 数据库名 character set utf8;`

- 进入数据库  `use 数据库名`

- 查看当前使用的是哪个库 `status;` 或 `select database() from dual;`

- `source sql脚本文件路径` 用该命令执行上面的sql脚本文件.[点击参考](#mysql的多表查询)

- 显示索引是`show index from 表名`

p.s.  默认情况下,反引号 `` ` 括起来的字符串,区分大小写.

### 表CURD

mysql的表curd操作和oracle是几乎一样的,只有[数据类型](#mysql的数据类型)不一致.

[跳转方便对比oracle的表curd](#表)

#### mysql的数据类型

![image-20221030135621392](https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202210301356829.png)

p.s.  (附加说明)

- `bit`     1位　	可以指定位数，如：bit(3)
- `int`     2字节 	可以指定最大位数，如：int<4>　最大为4位的整数
- `float`   2个字节　可以指定最大的位数和最大的小数位数，如：float<5,2> 最大为一个5位的数，小数位最多2位 
- `double`　4个字节　可以指定最大的位数和最大的小数位数，如：float<6,4> 最大为一个6位的数，小数位最多4位
- `char`　  必须指定字符数,如char(5) 为不可变字符　即使存储的内容为'ab',也是用5个字符的空间存储这个数据
- `varchar`　必须指定字符数,如varchar(5) 为可变字符　如果存储的内容为'ab',占用2个字符的空间；如果为'abc',则占用3个字符的空间
- `text`: 大文本(大字符串)
- `blob`：二进制大数据　如图片，音频文件，视频文件
- `date`: 日期　如：'1921-01-02'
- `datetime`: 日期+时间　如：'1921-01-02 12:23:43'
- `timeStamp`: 时间戳，自动赋值为当前日期时间

在Mysql中显示多行数据应该在查询语句结尾处添加 `\G`或`\g`来替换结束标记`;`

<img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202210301443749.png" alt="image-20221030144335864" style="zoom: 50%;" />

- **创建表**   `create table t1 (id int, name varchar(20))`
- **查看当前选择的数据库中的表**   `show tables;`
- **查看表结构**  `desc tablename;`
- **查看创建表的语法**    `show create table t1;`
- **更改表名**    `rename table employee to worker;`
- **增加一个字段**   `alter table employee add column height double;`   （column关键字在Oracle中，添加则语法错误）
- **修改一个字段**   `alter table employee modify column height float;`
- **删除一个字段**   `alter table employee drop column height;`
- **修改表的字符集**   `alter table employee character set gbk;`
- **删除employee表**  `drop table employee;`

注意:mysql删除表不能使用purge

### 数据的CURD操作

**和oracle是一样的.**

- 查询  `select id, name as "名字", salary "月薪", salary*12 年薪  from employee where id >=2;`

- 修改  `update employee set salary=10000, resume='也是一个中牛' where name='王五';`

- 删除  `delete from employee where name='王五';`

  `truncate employee;`

- 插入 `insert into employee values(1,'张三',1,'1983-04-27',15000,'2012-06-24','一个大牛');`

### mysql的分组查询注意点

在oracle数据库中,**having后面不可以使用别名,mysql可以使用别名**(别名若是中文不要加`""`)

```sql
#正确的
select sum(english+chinese+math) "总分",class_id from student group by class_id having 总分>1300;
#正确的
select sum(english+chinese+math) 总分,class_id from student group by class_id having 总分>1300;
#错误的
select sum(english+chinese+math) "总分",class_id from student group by class_id having "总分">1300;
#显示Empty set, 1 warning (0.00 sec)
```

**尽量使用英文别名**

### mysql的top-N问题

[oracle中的top-N问题](#top-N问题)比较复杂,而mysql中很简单

关键词  **`limit`**

在查询中，经常要返回前几条或者中间某几行数据时，用到`limit`
$$
limit\ \ offset,rows
$$
参数说明：
**`offset`**：指定第一个返回记录行的偏移量（即从哪一行开始返回），注意：初始行的偏移量为0。
**`rows`**：返回具体行数。

**如果limit后面是一个参数，就是检索前多少行。如果limit后面是2个参数，就是从offset+1行开始，检索rows行记录。**

**案例**

将math成绩从小到大排序,求math成绩在5-8名的学生的信息

`select * from student order by math limit 4,4;`

### mysql中的函数

#### 日期时间函数

MySQL里面时间分为三类：时间、日期、时间戳(含有时分秒的`sysdate`)。    (在mysql中使用sysdate必须加小括号)

![image-20221030172638699](https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202210301726678.png)

- `DATA_ADD` 等同于 `ADDDATE` ,`DATA_SUB`同理
- `CURDATE` 等同于 `CURRENT_DATE`,`current_time`同理

![image-20221030173143508](https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202210301732417.png)

`now()`   等同于   `sysdate()`   等同于   `current_timestamp()`

addtime函数用法参考

![image-20221030174159636](https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202210301742376.png)

DATE_ADD函数用法参考  (`interval`是关键词,不能缺少)

![image-20221030175035800](https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202210301750340.png)

 上述语句中的函数名, INTERVAL不区分大小写, day, month, year也可以用大写.

DATEDIFF函数用法参考

![image-20221030180213902](https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202210301802641.png)

##### 日期格式函数

日期转字符串
$$
DATE\_FORMAT(date,format)
$$

根据format 字符串安排date 值的格式。 

以下说明符可用在 format 字符串中：

![image-20221030180826827](https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202210301808026.png)

案例:   `select date_format(now(),'%Y-%m-%d %H:%i:%s');`

<img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202210301811721.png" alt="image-20221030181106873" style="zoom:67%;" />

#### 数学相关函数

![image-20221031112333528](https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202210311123690.png)

- `conv(12,10,2)` 将12从10进制转换成2进制为1100
- `format(12.015,2)` 将12.015保留小数点后两位为12.02
- `mod(3700,300)`  求余为100
- `rand`函数一般用`rand(now())`

还有三角函数,指数等等的一大堆数学函数

#### 字符串相关函数

**`||` 连接字符串 在 MySQL不可以使用。**但mysql的`concat`函数可以连接多个字符串

![image-20221031142000017](https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202210311420970.png)

- `replace`  会替换所有符合的字串
- `strcmp`  相等返回0,小于返回-1,大于返回1
- `substring` 的`position`可以为负数表示倒数第几个位置开始

#### 转换函数

- 日期转字符串 :    `date_format(date,format)`函数
- 字符串转日期:     `str_to_date(string,format)`函数

#### 滤空函数

mysql不支持[nvl函数](#通用函数),取而代之是**`ifnull`**函数,用法与nvl函数一致.

> 注意：
> Oracle中有一个通用函数，与MYSQL中的`ifnull`函数名字相近：`nullif`：如`nullif(a, b)` 当 a = b 时返回null, 不相等的时候返回a值。`nullif('L9,999.99', 'L9,999.99')`

mysql中`nullif()`函数也存在。

### mysql的多表查询

准备数据

新建scott.sql文件

```sql
create database if not exists scott character set utf8;

use scott;

create table bonus
(
        ename VARCHAR(10),
        job   VARCHAR(9),
        sal   int,
        comm  int
);

create table dept
(
        deptno  int  not null,
        dname  varchar(14),
        loc    varchar(13)
);

alter table dept add constraint PK_DEPT primary key(deptno);

create table emp
(
        empno  int not null,
        ename  varchar(10),
        job    varchar(9),
        mgr    int,
        hiredate  date,
        sal   int,
        comm    int,
        deptno   int
);

alter table emp add constraint PK_EMP primary key (empno);

alter table emp add constraint FK_DEPTNO foreign key (DEPTNO) references dept(deptno);

create table salgrade
(
        grade int,
        losal int,
        hisal int
);

INSERT INTO dept VALUES ('10', 'ACCOUNTING', 'NEW YORK');
INSERT INTO dept VALUES ('20', 'RESEARCH', 'DALLAS');
INSERT INTO dept VALUES ('30', 'SALES', 'CHICAGO');
INSERT INTO dept VALUES ('40', 'OPERATIONS', 'BOSTON');

INSERT INTO emp VALUES (7369, 'SMITH', 'CLERK', 7902,'1980-12-17', 800, NULL, 20);
INSERT INTO emp VALUES (7499, 'ALLEN', 'SALESMAN', 7698,'1981-2-20', 1600, 300, 30);
INSERT INTO emp VALUES (7521, 'WARD', 'SALESMAN', 7698,'1981-2-22', 1250, 500, 30);
INSERT INTO emp VALUES (7566, 'JONES', 'MANAGER', 7839,'1981-4-2', 2975, NULL, 20);
INSERT INTO emp VALUES (7654, 'MARTIN', 'SALESMAN', 7698,'1981-9-28', 1250, 1400, 30);
INSERT INTO emp VALUES (7698, 'BLAKE', 'MANAGER', 7839,'1981-5-1', 2850, NULL, 30);
INSERT INTO emp VALUES (7782, 'CLARK', 'MANAGER', 7839,'1981-1-9', 2450, NULL, 10);
INSERT INTO emp VALUES (7788, 'SCOTT', 'ANALYST', 7566,'1982-12-9', 3000, NULL, 20);
INSERT INTO emp VALUES (7839, 'KING', 'PRESIDENT', NULL,'1981-11-17', 5000, NULL, 10);
INSERT INTO emp VALUES (7844, 'TURNER', 'SALESMAN', 7698,'1981-9-8', 1500, 0, 30);
INSERT INTO emp VALUES (7876, 'ADAMS', 'CLERK', 7788,'1983-1-12', 1100, NULL, 20);
INSERT INTO emp VALUES (7900, 'JAMES', 'CLERK', 7698,'1981-12-3', 950, NULL, 30);
INSERT INTO emp VALUES (7902, 'FORD', 'ANALYST', 7566,'1981-12-3', 3000, NULL, 20);
INSERT INTO emp VALUES (7934, 'MILLER', 'CLERK', 7782,'1982-12-3', 1300, NULL, 10);


insert into salgrade values(1,700,1200);
insert into salgrade values(2,1201,1400);
insert into salgrade values(3,1401,2000);
insert into salgrade values(4,2001,3000);
insert into salgrade values(5,3001,9999);
```

`source /root/scott.sql` 用该命令执行上面的sql脚本文件.

得到原始数据

#### 交叉连接

相当于oracle的[笛卡尔积](#笛卡尔积)

关键词  **`cross join`**

`select e.*, d.* from emp e cross join dept d;`

#### 内连接

对应oracle中的[等值连接](#等值连接)

只返回满足连接条件的数据（两边都有的才显示）。

##### SQL99写法

关键词  **`[inner] join ... on ...`**     (inner可以省略)

`select e.ename,e.job,d.deptno,d.dname from emp e inner join dept d on e.deptno = d.deptno;`

##### oracle写法

`select e.ename,e.job,d.deptno,d.dname from emp e, dept d where e.deptno = d.deptno;`

区别盘点:    [,]  --->  [inner join]      [where]  --->  [on]

#### mysql外连接

##### mysql左外连接

左边有值才显示。     与[oracle的左外连接](#左外连接)仅仅是写法不同,含义一致

关键词   **`left [outer] join ...   on  ...`**     (outer可省略)

```sql
select e.*, d.*
		from emp e left outer join dept d
		on e.deptno=d.deptno
```

##### mysql右外连接

右边有值才显示。   与[oracle的右外连接](#右外连接)仅仅是写法不同,含义一致

关键词   **`right [outer] join ...   on  ... `**    (outer可省略)

```sql
select e.*, d.*
		from emp e right outer join dept d
		on e.deptno=d.deptno
```

即可知: SQL99中，外链接取值与关系表达式=号左右位置无关。取值跟from后表的书写顺序有关。 

**[案例]**   统计各个部门员工总人数-要求显示部门名称

```sql
select count(e.empno),d.dname from emp e right join dept d on e.deptno = d.deptno group by dname;
```

**[自连接案例]**   查询员工、老板信息，显示: xxx的老板是xxx

```sql
select concat(e.ename,'的老板是',ifnull(b.ename,'自己')) from emp e left join emp b on e.mgr = b.empno;
```

<img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202210311558213.png" alt="image-20221031155836798" style="zoom:67%;" />

##### mysql满外连接

任一边有值就会显示。     在oracle中没有对应

关键词    **`full [outer] join ... on ...`**      (outer可省略)

```sql
select e.*, d.*
		from emp e full outer join dept d		
		on e.deptno=d.deptno
```

### mysql表的约束

- **定义主键约束**　`primary key`	不允许为空，不允许重复
- **定义主键自动增长**　`auto_increment`  (从1开始,即使插入不填或者手动填null,也会从1开始自动增长给数)
- **定义唯一约束**　`unique`
- **定义非空约束**　`not null`
- **定义外键约束**　`constraint ordersid_FK foreign key(ordersid) references orders(id)`

**[注意]**  **check约束**在MySQL中语法保留，但**没有效果**

**案例**

```sql
create table myclass (
  id INT(11) primary key auto_increment,
  name varchar(20) unique
);

create table student (
  id INT(11) primary key auto_increment,
  name varchar(20) unique,
  passwd varchar(15) not null,
  classid INT(11),
  constraint stu_classid_FK foreign key(classid) references myclass(id));
```

## mysql中文乱码问题

查看所有应用的字符集     `show variables like 'character%';`

> 关于`utf8mb3`和`utf8mb4`，其主要区别在于：`most bytes 3`和`most bytes 4`，即最多使用3 / 4个字节来表示1个字符！所以，当使用`utf8mb4`时，可以表示更多字符，例如生僻汉字、冷门符号、emoji表情符号等。

指定字符集登录数据库(默认是utf8mb4)   `mysql -uroot -p123456 --default_character_set=gbk`

上面语句如果不是和插入时登录数据库使用的同一个字符集,就会中文乱码

![image-20221031173810379](https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202210311738498.png)

如果使用`secureCRT`,`secureCRT`菜单中的Options-Session Options-Category-Terminal-Appearance中可以设置Character encoding设置工具的字符集(如果未设置为utf-8也会显示乱码)

操作系统的语言集

Ubuntu下查看字符集 `cat /etc/default/locale`

red hat下查看字符集 `cat /etc/sysconfig/i18n`

返回显示`LANG="en_US.UTF-8"`   表示环境变量LANG = 操作系统的菜单按照zh_CN显示,文件存储按照utf8

操作系统本身不是utf-8也会乱码

总结:

- 使用哪种字符集插入的数据,就要用哪种字符集去select查看
- 操作系统本身必须支持中文的显示
- linux客户端工具若不支持中文显示也会显示乱码

## MYSQL API

访问MySQL服务器，这需要使用mysqlclient库，MySQL的大多数客户端API（除Java和.NET）都是通过这个库来和MySQL服务器通讯的，而这个库正是使用C语言编写的。

可使用`mysql -V` 命令查看当前系统内所使用的mysql数据库版本信息。MySQL客户端使用 libmysqlclient 库内部的函数访问MySQL服务器。因此我们在编程过程中，如若使用到库内的函数，必须链接函数库，对应的要找到头文件所在目录位置、函数库路径。以便我们在使用gcc编译工具时可以填充参数`-I、-L、-l`。

从手册中可获知，函数库名为mysqlclient。
	因此我们使用命令`find / -name libmysqlclient*` 或`locate *libmysql*`(ubuntu下需要下载支持)查找该库的路径。得到`/usr/lib/x86_64-linux-gnu/libmysqlclient.a`。
`nm /usr/lib/x86_64-linux-gnu/libmysqlclient.a`命令可查看库内包含的函数。

**链接使用该库。**			
	用到头文件`<mysql.h>`可使用`locate mysql.h`查看其目录位置`/usr/include/mysql/mysql.h`。

编译引用库的应用程序

```shell
gcc hello.c -o hello -I/usr/include/mysql/ -L/usr/lib/x86_64-linux-gnu/ -lmysqlclient 
```

如果链接出错,原因是**某些64位Linux环境**下，动态库配置不完整。需手动指定编译所用的动态库。根据错误提示分析需要加入如下函数库：

- `__gxx_personality_v0`   		-->	-lstdc++		使用g++相关的环境
- `dlclose/dlopen/dlsym`				-->	-ldl			完成用一个程序加载其他动态库的作用。
- `pthread_*`						-->-lpthread		线程库
- ``my_getsystime'/clock_gettime'`	-->-lrt			librt.so是glibc中对real-time的支持库

使用`ldd`命令可以查看该可执行文件运行所依赖的库文件。

### 常用函数

> c/c++程序员需要访问mysql数据库时，可以有2个选择，一个是纯的mysql的c API, 另外一个是`mysqlplus`这个库。前者是mysql的开发小组所维护的，其实现代码是mysql源代码的一部分。后者现在已经转为社区维护了。

**总体印象**

使用MySQL库API函数的一般步骤：

1. **初始化**. 	`MYSQL *mysql_init(MYSQL *mysql)`

2. **错误处理**	`unsigned int mysql_errno(MYSQL *mysql)` 

   `char *mysql_error(MYSQL *mysql);`

3. **建立连接**.	`MYSQL *mysql_real_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd,const char *db, unsigned int port, const char *unix_socket, unsigned long client_flag);`

4. **执行SQL语句**	`int mysql_query(MYSQL *mysql, const char *stmt_str)`

5. **获取结果**	`MYSQL_RES *mysql_store_result(MYSQL *mysql)`

   `MYSQL_ROW mysql_fetch_row(MYSQL_RES *result)`

6. **释放内存**	`void mysql_free_result(MYSQL_RES *result)`

7. **关闭连接**	`void mysql_close(MYSQL *mysql)` 

8. [编码相关](#编码相关)

7. [结果集相关](#结果集相关)

#### mysql_init函数

分配或初始化与`mysql_real_connect()`相适应的MYSQL对象。如果mysql是NULL指针，该函数将分配、初始化、并返回新对象。否则，将初始化对象，并返回对象的地址。如果`mysql_init()`分配了新的对象，当调用`mysql_close()`来关闭连接时。将释放该对象。

```c
MYSQL *mysql_init(MYSQL *mysql) 
```

返回值:   初始化的MYSQL*句柄。如果无足够内存以分配新的对象，返回NULL。

#### mysql_real_connect函数

mysql_real_connect()尝试与运行在主机上的MySQL数据库引擎建立连接。在你能够执行需要有效MySQL连接句柄结构的任何其他API函数之前，mysql_real_connect()必须成功完成。

```c
MYSQL *mysql_real_connect(
  MYSQL *mysql, //mysql结构体指针
  const char *host, //ip地址,NULL或localhost视为本机
  const char *user, //用户名,NULL或空字符串视为当前用户
  const char *passwd, //密码
  const char *db, //数据库名,NULL会将默认数据库设为该值
  unsigned int port,//端口号 
  const char *unix_socket, //跨网络的话应该填NULL.如果非空,描述了应使用的套接字或命名管道.
  unsigned long client_flag) //标志,通常为0,可以设置下面组合,以允许特定功能
  
//返回值,如果失败返回NULL,成功返回mysql(MYSQL结构体指针)
```

| 标志名称                | 标志描述                                                     |
| ----------------------- | ------------------------------------------------------------ |
| CLIENT_COMPRESS         | 使用压缩协议。                                               |
| CLIENT_FOUND_ROWS       | 返回发现的行数（匹配的），而不是受影响的行数。               |
| CLIENT_IGNORE_SPACE     | 允许在函数名后使用空格。使所有的函数名成为保留字。           |
| CLIENT_INTERACTIVE      | 关闭连接之前，允许interactive_timeout（取代了wait_timeout）秒的不活动时间。客户端的会话wait_timeout变量被设为会话interactive_timeout变量的值。 |
| CLIENT_LOCAL_FILES      | 允许LOAD DATA LOCAL处理功能。                                |
| CLIENT_MULTI_STATEMENTS | 通知服务器，客户端可能在单个字符串内发送多条语句（由‘;’隔开）。如果未设置该标志，将禁止多语句执行。 |
| CLIENT_MULTI_RESULTS    | 通知服务器，客户端能够处理来自多语句执行或存储程序的多个结果集。如果设置了CLIENT_MULTI_STATEMENTS，将自动设置它。 |
| CLIENT_NO_SCHEMA        | 禁止`db_name.tbl_name.col_name`语法。它用于ODBC。如果使用了该语法，它会使分析程序生成错误，在捕获某些ODBC程序中的缺陷时，它很有用。 |
| CLIENT_ODBC             | 客户端是ODBC客户端。它将mysqld变得更为ODBC友好。             |
| CLIENT_SSL              | 使用SSL（加密协议）。该选项不应由应用程序设置，它是在客户端库内部设置的。 |

调用mysql_real_connect之前不要尝试加密密码,密码加密将由客户端API自动处理

使用

```c
MYSQL *conn = mysql_real_connect(mysql,"localhost","root","password","myTest",0,NULL,0);
if(conn == NULL)
{
    printf("[error]%s",mysql_error(mysql));
    return -1;
}
```

#### mysql_query函数

**[功能]**执行由“Null终结的字符串”查询指向的SQL查询。正常情况下，字符串必须包含1条SQL语句，而且不应为语句添加终结分号`;`或`\g`。如果允许多语句执行，字符串可包含多条由分号隔开的语句。

mysql_query函数不单单能完成查询sql的功能，还能完成非select语句在c程序中的执行。是一个十分万能的c程序中执行SQL语句的函数。并且该函数本身直接支持静态SQL。如果语句中包含二进制数据，则需要调用`mysql_real_query`来执行查询语句。

```c
int mysql_query(MYSQL *mysql, const char *query);
//如果查询成功，返回0。如果出现错误，返回非0值
//mysql参数为mysql_real_connect返回值
//query为sql执行语句的字符串
```

- 若执行的是**`UPDATE, DELETE或INSERT语句`**，则可通过`mysql_affected_rows()`获知受影响的记录数。
- 若执行的是**`SELECT语句`**，查询结束后，查询结果被保存在mysql句柄中。需要使用获取结果集的API函数将结果集获取出来。有两种方式可以获取结果集。

**注意**: `mysql_query`执行的SQL语句不应为语句添加终结分号（‘;’）或“\g”。

#### mysql_close函数

关闭前面打开的连接。如果句柄是由mysql_init()或mysql_connect()自动分配的，mysql_close()还将解除分配由mysql指向的连接句柄。

```c
void mysql_close(MYSQL *mysql);
```

#### 编码相关

##### mysql_character_set_name函数

为当前连接返回默认的字符集。

```c
const char *mysql_character_set_name(MYSQL *mysql) 
```

##### mysql_set_character_set函数

该函数用于为当前连接设置默认的字符集

```c
int mysql_set_character_set(MYSQL *mysql, char *csname) 
```

返回值:    0表示成功，非0值表示出现错误。 

```c
//设置utf8编码集例子
mysql_set_charset_name(&mysql, "utf8")
//下面也可以
mysql_query(mysql, "set names utf8");
```

#### 结果集相关

一种方式是通过`mysql_store_result()`将整个结果集全部取回来。另一种方式则是调用`mysql_use_result()`初始化获取操作，但暂时不取回任何记录。视结果集的条目数选择获取结果集的函数。两种方法均通过`mysql_fetch_row()`来访问每一条记录。

- [`mysql_store_result函数`](#mysql_store_result函数)    获取结果集
- [`mysql_fetch_row函数` ](#mysql_fetch_row函数)   解析结果集
- [`mysql_free_result函数` ](#mysql_free_result函数)   释放结果集
- [获取列数函数](#获取列数函数)
- [获取表头函数](#获取表头函数)
- [`mysql_affected_rows函数`](#mysql_affected_rows函数)      返回影响行数

##### mysql_store_result函数

**获取结果集**

```c
MYSQL_RES *mysql_store_result(MYSQL *mysql) 
//成功返回MYSQL_RES结果集指针，失败返回NULL。(可以通过判断返回NULL来判断mysql_query是否执行成功)
```

`MYSQL_RES`是一个结构体类型，可以从`mysql.h`头文件中找到该结构体的定义

```c
typedef struct MYSQL_RES {
  uint64_t row_count;//行数,有多少行
  MYSQL_FIELD *fields;
  struct MYSQL_DATA *data;
  MYSQL_ROWS *data_cursor;
  unsigned long *lengths; /* column lengths of current row */
  MYSQL *handle;          /* for unbuffered reads */
  const struct MYSQL_METHODS *methods;
  MYSQL_ROW row;         /* If unbuffered read */
  MYSQL_ROW current_row; /* buffer to current row */
  struct MEM_ROOT *field_alloc;
  unsigned int field_count, current_field;
  bool eof; /* Used by mysql_fetch_row */
  /* mysql_stmt_close() had to cancel this result */
  bool unbuffered_fetch_cancelled;
  enum enum_resultset_metadata metadata;
  void *extension;
} MYSQL_RES;
```

**使用案例**

```c
MYSQL_RES *result = mysql_store_result(mysql);
	if (result == NULL) {
	ret = mysql_errno(mysql);
	printf("mysql_store_result error: %s\n", mysql_error(mysql));
	return ret;	
	}
```

该函数调用成功，则SQL查询的结果被保存在result中

##### mysql_fetch_row函数

**解析结果集**

```c
MYSQL_ROW mysql_fetch_row(MYSQL_RES *result)
//成功返回下一行的MYSQL_ROW结构。如果没有更多要检索的行或出现了错误，返回NULL
//result为mysql_store_result返回的值
```

**使用案例**

```c
	MYSQL_ROW row = NULL;				//typedef char **MYSQL_ROW;	
      while ((row = mysql_fetch_row(result))) {
      printf("%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n", row[0],row[1],row[2],row[3],row[4],row[5],row[6],row[7]);
    }
```

MYSQL_ROW的本质是`tupedef char** MYSQL_ROW;`,数据信息存储的形式如下图

![image-20221114152116545](https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202211141522005.png)

##### mysql_free_result函数

**释放结果集**

```c
void mysql_free_result(MYSQL_RES *result); 
//成功释放参数传递的结果集。没有失败情况。
```

##### 查询数据整体案例

```c
char sSql[255] = "select * from testTable";
    int ret = mysql_query(conn,sSql);
    if(ret!=0)
    {
        printf("执行失败\n");
    }
    else
    {
        printf("执行成功\n");
    }
    MYSQL_RES* res = mysql_store_result(mysql);
    if(res == NULL)
    {
        printf("%s\n",mysql_error(mysql));
    }
    else
    {
        MYSQL_ROW row = NULL;
        while((row = mysql_fetch_row(res))!=NULL)
        {
            printf("id:%s  name:%s\n",row[0],row[1]);
        }
        mysql_free_result(res);
    }
```

##### 获取列数函数

- `unsigned int mysql_field_count(MYSQL *mysql)` 			从**mysql句柄**中获取连接的表有多少列。(表为连接数据库的时候指定了的某张表)
- `unsigned int mysql_num_fields(MYSQL_RES *result)` 	从**返回的结果集**中获取有多少列。

##### 获取表头函数

- `MYSQL_FIELD *mysql_fetch_fields(MYSQL_RES *result)` 全部获取
- `MYSQL_FIELD *mysql_fetch_field(MYSQL_RES *result)` 获取单个

返回值为**`MYSQL_FIELD`**结构体指针

```c
typedef struct MYSQL_FIELD {
  char *name;               /* 列名Name of column */
  char *org_name;           /* 原名(有别名的情况下)Original column name, if an alias */
  char *table;              /* 表名Table of column if column was a field */
  char *org_table;          /* 原表名Org table name, if table was an alias */
  char *db;                 /*表的库名 Database for table */
  char *catalog;            /* Catalog for table */
  char *def;                /* Default value (set by mysql_list_fields) */
  unsigned long length;     /* Width of column (create length) */
  unsigned long max_length; /* Max width for selected set */
  unsigned int name_length;
  unsigned int org_name_length;
  unsigned int table_length;
  unsigned int org_table_length;
  unsigned int db_length;
  unsigned int catalog_length;
  unsigned int def_length;
  unsigned int flags;         /* Div flags */
  unsigned int decimals;      /* Number of decimals in field */
  unsigned int charsetnr;     /* Character set */
  enum enum_field_types type; /* Type of field. See mysql_com.h for types */
  void *extension;
} MYSQL_FIELD;
```

##### mysql_affected_rows函数

返回上次UPDATE更改的行数，上次DELETE删除的行数，或上次INSERT语句插入的行数。对于UPDATE、DELETE或INSERT语句，可在mysql_query()后立刻调用。对于SELECT语句，mysql_affected_rows()的工作方式与mysql_num_rows()类似。

```c
my_ulonglong mysql_affected_rows(MYSQL *mysql);
```

**[返回值]** 大于0的整数表明受影响或检索的行数。“0”表示UPDATE语句未更新记录，在查询中没有与WHERE匹配的行，或未执行查询。“-1”表示查询返回错误，或者，对于SELECT查询，在调用mysql_store_result()之前调用了mysql_affected_rows()。由于mysql_affected_rows()返回无符号值，通过比较返回值和“(my_ulonglong)-1”或等效的“(my_ulonglong)~0”，检查是否为“-1”。

如果在连接至mysqld时指定了标志CLIENT_FOUND_ROWS，对于UPDATE语句，mysql_affected_rows()将返回WHERE语句匹配的行数。

### mysql客户端编写案例

1. mysql初始化 -- [mysql_init()](#mysql_init函数)
2. 连接mysql数据库 -- [mysql_real_connect()](#mysql_real_connect函数)
3. 循环
   1. 打印提示符
   2. 读取用户输入的sql语句,判断是否为退出
   3. 不是退出的话执行sql语句取出结果集或影响行数打印出来 -- [mysql_store_result()](#mysql_store_result函数),[mysql_fetch_row()](#mysql_fetch_row函数),[mysql_affected_rows()](#mysql_affected_rows函数)
   4. 如果要释放结果集 -- [mysql_free_result()](#mysql_free_result函数)
4. 关闭连接 -- mysql_close()

**代码**

```c
#include <stdio.h>
#include <stdlib.h>
#include "mysql.h"
#include <unistd.h>
#include <string.h>

int main()
{
    MYSQL *mysql = mysql_init(NULL);
    if (mysql == NULL)
    {
        printf("错误\n");
        return -1;
    }
    printf("mysql Init 成功\n");
    MYSQL *conn = mysql_real_connect(mysql, "localhost", "root", "password123", "myTest", 0, NULL, 0);
    if (conn == NULL)
    {
        printf("[error]%s", mysql_error(mysql));
        return -1;
    }
    printf("链接成功\n");
    while (1)
    {
        char buf[999] = {0};
        printf("MYSQL>");
        fflush(stdout);
        read(STDIN_FILENO, buf, sizeof(buf));
        //去首尾空格
        int spaceIndex = 0;
        for (spaceIndex = 0; spaceIndex < strlen(buf); spaceIndex++)
        {
            if (buf[spaceIndex] != ' ')
                break;
        }
        int commandRealLength = strlen(buf) - spaceIndex;
        memmove(buf, buf + spaceIndex, strlen(buf) - spaceIndex);
        // printf("old:%s\n",buf);
        memset(buf + commandRealLength, 0, sizeof(buf) - commandRealLength);
        // printf("new:%s\n",buf);
        //判断是否只有回车字符
        if (buf[0] == '\n')
            continue;
        //去末尾分号
        char *p = strrchr(buf, ';');
        if (p != NULL)
            *p = NULL;
        // printf("最终传递的sql指令为：%s\n", buf);
        if (strncasecmp(buf, "quit", 4) == 0 || strncasecmp(buf, "exit", 4) == 0)
        {
            mysql_close(mysql);
            return 0;
        }
        printf("执行命令\n");
        if (strncasecmp(buf, "select", 6) == 0)
        {
            int ret = mysql_query(conn, buf);
            if (ret != 0)
            {
                printf("执行失败\n");
                continue;
            }
            MYSQL_RES *res = mysql_store_result(mysql);
            if (res == NULL)
            {
                printf("%s\n", mysql_error(mysql));
                continue;
            }
            else
            {
                MYSQL_ROW row = NULL;
                int colSum = mysql_num_fields(res);
                MYSQL_FIELD *field = mysql_fetch_fields(res);
                if (field != NULL)
                {
                    while ((row = mysql_fetch_row(res)) != NULL)
                    {
                        for (int i = 0; i < colSum; i++)
                        {
                            /* code */
                            printf("%s:%s\t", field[i].name, row[i]);
                        }
                        printf("\n");
                    }
                }
                mysql_free_result(res);
            }
        }
        else
        {
            int ret = mysql_query(conn, buf);
            if (ret != 0)
            {
                printf("执行失败\n");
                continue;
            }
            printf("query ok,%d row affected\n", mysql_affected_rows(mysql));
        }
    }
    mysql_close(mysql);
    return 0;
}
```

### MYSQL的事务

事务相关知识点参考[事务章节](#事务)

- MySQL的事务的默认自动提交的，每执行一个sql语句都自动commit
- Oracle的事务是自动打开的(以你执行的一条DML语句为标志)，但每次执行需要手动commit

在程序中设置**`autocommit`**修改MySQL事务的属性。(**每次连接会重新恢复默认,要重新设置**)

- `set autocommit = 0` 禁止自动提交
- `set autocommit = 1` 开启自动提交MySQL中InnoDB引擎才支持事务默认自动提交机制。MYISAM引擎不支持。

#### 相关sql语句

- 开启事务   `start transaction`
- 设置手动提交   `set autocommit = 0` 
- 设置自动提交   `set autocommit = 1` 
- 提交   `commit`
- 回滚   `rollback`

#### 代码案例

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "mysql.h"

#define SET_TRAN	"SET AUTOCOMMIT=0"  		//手动commit	
#define UNSET_TRAN	"SET AUTOCOMMIT=1"		//自动commit

//设置事务为手动提交
int mysql_OperationTran(MYSQL *mysql)  			
{
	//--开启事务
	int ret = mysql_query(mysql, "start transaction");  
	if (ret != 0) {
		printf("mysql_OperationTran query start err: %s\n", mysql_error(mysql));
		return ret;
	}
	
	//--设置事务为手动提交
	ret = mysql_query(mysql, SET_TRAN);
	if (ret != 0) {
		printf("mysql_OperationTran query set err: %s\n", mysql_error(mysql));
		return ret;
	}
	return ret;
}
	
//设置事务为自动提交
int mysql_AutoTran(MYSQL *mysql)
{
	//--开启事务
	int ret = mysql_query(mysql, "start transaction");  
	if (ret != 0) {
		printf("mysql_AutoTran query start err: %s\n", mysql_error(mysql));
		return ret;
	}
	//--设置事务为自动提交
	ret = mysql_query(mysql, UNSET_TRAN);
	if (ret != 0) {
		printf("mysql_AutoTran query set err: %s\n", mysql_error(mysql));
		return ret;
	}
	return ret;		
}
//执行commit，手动提交事务
int mysql_Commit(MYSQL *mysql)
{
	int ret = mysql_query(mysql, "COMMIT"); 
	if (ret != 0) {
		printf("commit err: %s\n", mysql_error(mysql));
		return ret;
	}
	return ret;
}

//执行rollback，回滚事务		
int mysql_Rollback(MYSQL *mysql)
{
	int ret = mysql_query(mysql, "ROLLBACK");
	if (ret != 0) {
		printf("rollback err: %s\n", mysql_error(mysql));
		return ret;
	}
	return ret;
}

#define DROP_SAMPLE_TABLE "DROP TABLE IF EXISTS test_table"
#define CREATE_SAMPLE_TABLE "CREATE TABLE test_table(col1 INT,\
                                                 col2 VARCHAR(10),\
                                                 col3 VARCHAR(10))"
                                         
#define sql01 "INSERT INTO test_table(col1,col2,col3) VALUES(10, 'AAA', 'A1')"
#define sql02 "INSERT INTO test_table(col1,col2,col3) VALUES(20, 'BBB', 'B2')"
#define sql03 "INSERT INTO test_table(col1,col2,col3) VALUES(30, 'CCC', 'C3')"
#define sql04 "INSERT INTO test_table(col1,col2,col3) VALUES(40, 'DDD', 'D4')"

int main(void)
{
	int ret = 0;
	MYSQL *mysql = mysql_init(NULL);
	
	mysql = mysql_real_connect(mysql, "localhost", "root", "123456", "mydb2", 0, NULL, 0);
	if (mysql == NULL) {
		ret = mysql_errno(mysql);
		printf("func mysql_real_connect() err：%d\n", ret);
		return ret;
	} 	
	printf(" --- connect ok......\n");	
	
	if (mysql_query(mysql, DROP_SAMPLE_TABLE)) {
	  fprintf(stderr, " DROP TABLE failed\n");
	  fprintf(stderr, " %s\n", mysql_error(mysql));
	  exit(0);
	}
	if (mysql_query(mysql, CREATE_SAMPLE_TABLE)) {
	  fprintf(stderr, " CREATE TABLE failed\n");
	  fprintf(stderr, " %s\n", mysql_error(mysql));
	  exit(0);
	}	
	
	ret = mysql_OperationTran(mysql); 	//开启事务，并修改事务属性为手动commit 
	if (ret != 0) {
		printf("mysql_OperationTran() err:%d\n", ret);
		return ret;
	}
	
	ret = mysql_query(mysql, sql01);	//向表中插入第一行数据 ‘AAA’
	if (ret != 0) {
		printf("mysql_query() err:%d\n", ret);
		return ret;
	}
	ret = mysql_query(mysql, sql02);	//向表中插入第二行数据 ‘BBB’
	if (ret != 0) {
		printf("mysql_query() err:%d\n", ret);
		return ret;
	}
	ret = mysql_Commit(mysql); 		//手动提交事务
	if (ret != 0) {
		printf("mysql_Commit() err:%d\n", ret);
		return ret;
	}
	
	ret = mysql_AutoTran(mysql); 		// =再次= 修改事务属性为【自动】commit
	if (ret != 0) {
		printf("mysql_OperationTran() err:%d\n", ret);
		return ret;
	}
	ret = mysql_OperationTran(mysql); 	// =再次= 修改事务属性为【手动】commit
	if (ret != 0) {
		printf("mysql_OperationTran() err:%d\n", ret);
		return ret;
	}
	ret = mysql_query(mysql, sql03);	//向表中插入第三行数据 ‘CCC’
	if (ret != 0) {
		printf("mysql_query() err:%d\n", ret);
		return ret;
	}
	ret = mysql_query(mysql, sql04);	//向表中插入第四行数据 ‘DDD’
	if (ret != 0) {
		printf("mysql_query() err:%d\n", ret);
		return ret;
	}
	ret = mysql_Rollback(mysql);		//直接rollback操作
	if (ret != 0) {
		printf("mysql_Rollback() err:%d\n", ret);
		return ret;
	}
	//rollback操作是否能回退掉CCC、DDD的值，取决于事务属性。
	mysql_close(mysql);
	return 0;	
}
```

### 预处理类API

MySQL客户端／服务器协议提供了预处理语句。该功能采用了由`mysql_stmt_init()`初始化函数返回的`MYSQL_STMT`语句处理程序数据结构。对于多次执行的语句，预处理执行是一种有效的方式。首先对语句进行解析，为执行作好准备。接下来，在以后使用初始化函数返回的语句句柄执行一次或多次。

对于多次执行的语句，**预处理执行比直接执行快**，主要原因在于，仅对查询执行一次解析操作。在直接执行的情况下，每次执行语句时，均将进行查询。此外，由于每次执行预处理语句时仅需发送参数的数据，从而**减少了网络通信量**。

预处理语句的另一个优点是，它**采用了二进制协议，从而使得客户端和服务器之间的数据传输更有效率。**

> 性能、调优是数据库编程永恒不变的主题！如果能把SQL语句框架预先处理好，当真正要执行SQL语句时只需要发送对应的参数到对应的SQL框架中，就能提高客户端访问服务器的速度，且数据量小，可以减少网络通信量，提高数据传输效率高。				

预处理语句的优势在于归纳为：一次编译、多次运行，省去了解析优化等过程；此外预处理语句能**防止 SQL 注入**。

#### 预处理相关函数

- [`mysql_stmt_init()`](#mysql_stmt_init函数)				初始化预处理环境句柄。	返回一个结构体指针 `MYSQL_STMT *stmt`
- [`mysql_stmt_prepare()`](#mysql_stmt_prepare函数)				向上面句柄中添加SQL语句，带有 `(?,?,?)` 占位符
- [`mysql_stmt_param_count()` ](#mysql_stmt_param_count函数)		求绑定变量的个数(辅助函数)， 有多少个'?'就返回多少
- [`mysql_stmt_bind_param()`](#mysql_stmt_bind_param函数)			将?对应的实参，设置到预处理环境句柄中
- [`mysql_stmt_execute()`](#mysql_stmt_execute函数)				执行预处理的SQL语句
- [`mysql_stmt_error()` ](#mysql_stmt_error函数)	    获取错误消息。
- [`mysql_stmt_close()` ](#mysql_stmt_close函数)	    关闭预处理语句

![image-20221122164501715](https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202211221646758.png)

##### mysql_stmt_init函数

创建MYSQL_STMT句柄。对于该句柄，应使用[`mysql_stmt_close(MYSQL_STMT *)`](#mysql_stmt_close函数)释放。

```c
MYSQL_STMT *mysql_stmt_init(MYSQL *mysql);
//成功时，返回指向MYSQL_STMT结构的指针。如果内存溢出，返回NULL。
```

##### mysql_stmt_prepare函数

准备sql语句框架,字符串必须包含1条SQL语句(通过将问号字符“?”嵌入到SQL字符串的恰当位置)。不应为语句添加终结用分号(‘;’)或\g。 

```c
int mysql_stmt_prepare(MYSQL_STMT *stmt, const char *query, unsigned long length);
//query为sql语句字符串,length为sql字符串长度
//如果成功处理了语句，返回0。如果出现错误，返回非0值。 
```

可通过调用[`mysql_stmt_error() `](#mysql_stmt_error函数)获取错误消息。

#####  mysql_stmt_param_count函数

返回预处理语句中参数标记符的数目。

```c
unsigned long mysql_stmt_param_count(MYSQL_STMT *stmt);
//表示语句中参数数目的无符号长整数。 
```

##### mysql_stmt_bind_param函数

`mysql_stmt_bind_param()`用于为SQL语句中的参数标记符绑定数据，以传递给`mysql_stmt_prepare()`。它使用`MYSQL_BIND`结构来提供数据

```c
my_bool mysql_stmt_bind_param(MYSQL_STMT *stmt, MYSQL_BIND *bind);
//bind应该为MYSQL_BIND数组首地址
//如果绑定成功，返回0。如果出现错误，返回非0值。
```

###### MYSQL_BIND结构体

详解参考[官方文档](https://dev.mysql.com/doc/c-api/8.0/en/c-api-prepared-statement-data-structures.html)

```c
typedef struct MYSQL_BIND {
  unsigned long *length; /* 参考下方讲解*/
  bool *is_null;         /* 问号缓冲区中的值是否可以为空Pointer to null indicator */
  void *buffer;          /* 指向问号缓冲区的地址buffer to get/put data */
  /* set this if you want to track data truncations happened during fetch */
  bool *error;
  unsigned char *row_ptr; /* for the current data position */
  void (*store_param_func)(NET *net, struct MYSQL_BIND *param);
  void (*fetch_result)(struct MYSQL_BIND *, MYSQL_FIELD *, unsigned char **row);
  void (*skip_result)(struct MYSQL_BIND *, MYSQL_FIELD *, unsigned char **row);
  /* output buffer length, must be set when fetching str/binary */
  unsigned long buffer_length;//缓冲区长度,字符串要提供.作为输入参数时表示buffer的	字节数,作为输出结果时,表示可以存储在buffer中的最大字节数
  unsigned long offset;              /* offset position for char/binary fetch */
  unsigned long length_value;        /* Used if length is 0 */
  unsigned int param_number;         /* For null count and error messages */
  unsigned int pack_length;          /* Internal length for packed data */
  enum enum_field_types buffer_type; /* 问号缓冲区的类别buffer type */
  bool error_value;                  /* used if error is 0 */
  bool is_unsigned;                  /* set if integer type is unsigned */
  bool long_data_used;               /* If used with mysql_send_long_data */
  bool is_null_value;                /* Used if is_null is 0 */
  void *extension;
} MYSQL_BIND;
```

> 值得注意的是上面结构体中的length成员和buffer_length成员你的区别:
>
> - 对于入参数据绑定，设置 length 表示 buffer 中存储的参数值的实际长度。这是由 mysql_stmt_execute() 使用的。
>
>   当length为NULL时，buffer_length可以作为长度来用
>
>   - 但改变buffer_length之后必须重新调用`mysql_stmt_bind()`才会对查询起作用。
>   - 而length只要改变其所指向的unsigned long，就会在下一次查询起作用，不用重新调用`mysql_stmt_bind()`。
>
> - 对于输出值绑定，MySQL 在您调用 mysql_stmt_fetch() 时设置 length 。 mysql_stmt_fetch() 返回值决定了如何解释长度：
>
>   - 如果返回值为0，则 *length 表示参数值的实际长度。
>   - 如果返回值为 `MYSQL_DATA_TRUNCATED` ，则 *length 表示参数值的非截断长度。在这种情况下， *length 和 buffer_length 中的最小值表示值的实际长度。

buffer_type成员指定的允许值:

![image-20221122172303182](https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202211221724158.png)

##### mysql_stmt_execute函数

`mysql_stmt_execute()`执行与语句句柄相关的预处理查询。在该调用期间，将当前绑定的参数标记符的值发送到服务器，服务器用新提供的数据替换标记符。

```c
int mysql_stmt_execute(MYSQL_STMT *stmt);
//如果执行成功，返回0。如果出现错误，返回非0值。
```

##### mysql_stmt_bind_result函数

```cpp
bool mysql_stmt_bind_result(MYSQL_STMT *stmt, MYSQL_BIND *bind)
//返回值:如果绑定成功，返回0。如果出现错误，返回非0值。
```

一种函数，用于将结果集中的列与数据缓冲和长度缓冲关联（绑定）起来。当调用`mysql_stmt_fetch()`以获取数据时，MySQL客户端/服务器协议会将绑定列的数据置于指定的缓冲区内。

##### mysql_stmt_fetch函数

mysql_stmt_fetch是函数名，mysql_stmt_fetch()返回结果集中的下一行。

```cpp
int mysql_stmt_fetch(MYSQL_STMT *stmt)
```

| 返回值                  | 描述                                 |
|----------------------|------------------------------------|
| 0                    | 成功，数据被提取到应用程序数据缓冲区。                |
| 1                    | 出现错误。调用mysql_stmt_error()，可获取错误消息。 |
| MYSQL_NO_DATA        | 不存在行/数据。                           |
| MYSQL_DATA_TRUNCATED | 出现数据截短。                            |

##### mysql_stmt_error函数

对于由stmt指定的语句，`mysql_stmt_error()`返回由Null终结的字符串，该字符串包含最近调用的语句API函数的错误消息，该函数或成功或失败。如果未出现错误，返回空字符串(`""`)

```c
const char *mysql_stmt_error(MYSQL_STMT *stmt) 
```

##### mysql_stmt_close函数

关闭预处理句柄

```c
my_bool mysql_stmt_close(MYSQL_STMT *);
//如果成功释放了语句，返回0。如果出现错误，返回非0值。 
```

#### 预处理案例

```cpp
char id[5]={0};
    char name[129]={0};
    char nodedesc[513]={0};
    MYSQL_TIME createtime;
    int authcode = 0;
    int state = 0;
    string query = "select * from SECNODE where id = ?";
    MYSQL_STMT *stmt = mysql_stmt_init(mysql);
    if ( mysql_stmt_prepare(stmt,query.c_str(),query.size())) {
        cout<<"Could not prepare statement: "<<mysql_stmt_error(stmt)<<endl;
        return false;
    }
    //初始化问号参数集
    MYSQL_BIND bind[1];//初始化问号数作为参数个bind
    unsigned long paramlength=4;
    memset(bind,0,sizeof(MYSQL_BIND));
    bind[0].buffer_type = MYSQL_TYPE_STRING;
    bind[0].buffer = (char*)clientID.c_str();
    bind[0].length = &paramlength;
    if (mysql_stmt_bind_param(stmt, bind)) {
       cout<<"Could not bind parameters:"<<mysql_stmt_error(stmt)<<endl;
       return false;
    }
    if (mysql_stmt_execute(stmt)) {
        cout<<"Could not execute statement: "<< mysql_stmt_error(stmt)<<endl;
        return false;
    }   
    //初始化结果集
    MYSQL_BIND res[6];
    memset(res, 0, sizeof(bind));
    res[0].buffer_type = MYSQL_TYPE_STRING;
    res[0].buffer = id;
    res[0].buffer_length = sizeof(id)-1;
    res[1].buffer = name;
    res[1].buffer_type = MYSQL_TYPE_VAR_STRING;
    res[1].buffer_length = sizeof(name)-1;
    res[2].buffer = nodedesc;
    res[2].buffer_type = MYSQL_TYPE_VAR_STRING;
    res[2].buffer_length = sizeof(nodedesc)-1;
    res[3].buffer_type = MYSQL_TYPE_TIME;
    res[3].buffer = &createtime;
    res[4].buffer = &authcode;
    res[4].buffer_type = MYSQL_TYPE_LONG;
    res[5].buffer = &state;
    res[5].buffer_type = MYSQL_TYPE_LONG;
    cout<<mysql_stmt_bind_result(stmt, res)<<endl;
    mysql_stmt_store_result(stmt);
    // 获取结果
    int fetch;
    while ((fetch = mysql_stmt_fetch(stmt)) != MYSQL_NO_DATA) {
        cout <<"fetch:"<<fetch<<endl;
       cout<<"id:"<< id<<", name: "<< name<<endl;
    }
    mysql_stmt_close(stmt);
```

# oracle和mysql的区别

oracle要求select和from一定要组合使用,mysql可以没有from

# 非关系数据库

数据库有两种

- 关系型数据库

  mysql,oracle,sqlite,sql server

  - 操作数据必须要使用sql语句
  - 数据存储在磁盘
  - 存储的数据量大

- 非关系型数据库

  nosql,redis

  - 操作不使用sql语句,命令方式
  - 数据默认存储在内存,速度快,效率高,存储数据量小
  - 不需要数据库表,以键值对的方式存储的

<img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202305261512329.png" alt="image-20230526151239035" style="zoom:50%;" />

1. 所有的数据默认存储在关系型数据库中
2. 客户端访问服务器, 有一些数据, 服务器需要频繁的查询数据
   - 服务器首先将数据从关系型数据库中读出 -> 第一次
   - 将数据写入到redis中
   - 客户端第二次包含以后访问服务器
   - 服务器从redis中直接读数据

## Redis

### 安装与使用

[官网跳转](http://redis.cn/)

安装命令: `sudo apt install redis-server redis-tools`

redis两个角色

- 服务器

  ```shell
  #服务器启动(不填路径默认找根目录下的redis.conf)
  redis-server [配置文件路径]
  ```

- 客户端

  ```shell
  #客户端
  redis-cli [-p 端口号] [-h ip地址]
  #默认连接本地6379端口的服务器
  #通过客户端关闭服务器
  shutdown
  #客户端的测试命令
  ping ["测试消息"]
  ```

[官方命令在线文档](http://redis.cn/commands.html)


1. 安装完成后，Redis服务将自动启动。您可以使用以下命令检查Redis服务的状态：
```shell
  sudo systemctl status redis-server

```
如果服务正在运行，您将看到`active (running)`的状态。 
2. 如果Redis服务未运行，您可以使用以下命令手动启动它：

```shell
  sudo systemctl start redis-server
   
```

3. 您还可以使用以下命令停止Redis服务：

```shell
  sudo systemctl stop redis-server
   
```

4. 如果您希望Redis服务在系统启动时自动启动，可以使用以下命令启用它：

```bash
  sudo systemctl enable redis-server
   
```
#### redis配置文件

给redis服务器使用的

根目录下的`redis.conf`

配置文件常用配置项

```shell
#允许谁访问redis服务器(如果注释掉它表示任何主机都可以访问到redis服务器)
bind 127.0.0.1 192.168.1.100
#保护模式(保护模式必须要关闭才能允许远程主机访问reids服务器)
protected-mode yes
#redis服务器启动的时候绑定的端口(默认为6379)
port 6379
#客户端空闲的超时时长,超时后服务器主动断开连接(0表示禁用该超时断开功能)
timeout 0
#服务器启动后是否以守护进程存在
daemonize no
#如果上一项设置了服务器是守护进程,就会生成一个pid文件,路径设置为如下,一般改为./redis_6379.pid表示redis-server的启动目录下生成pid文件
pidfile /var/run/redis_6379.pid
#服务器是守护进程,才会写日志文件,日志文件路径如下(空""表示把日志丢到了空设备中,意思不想保留下来,一般修改成./redis.log)
logfile ""
#设置数据库的个数(通过select dbID来切换数据库,dbID== 0到database的值-1之间的一个值)
databases 16
```

另有[数据持久化相关的配置项(点击跳转)](#数据持久化的配置项)

### 数据类型

redis中数据的组织形式:

- key: 必须是字符串 - "hello world"(双引号括住的部分会将空格也视为字符串的一部分)

- value: 可选的

  - String类型

    字符串

  - List类型

    存储多个String字符串的

  - Set类型

    集合(元素不重复,数据是无序的)

  - SortedSet类型

    排序集合(元素不重复,默认升序)

  - Hash类型

    与[[stl]]数据组织方式一样   key:value

    - map是红黑树实现的
    - hash是数组实现的

### 常用命令

#### String类型命令

```shell
key -> string
value -> string
# 设置一个键值对->string:string
SET key value
# 通过key得到value
GET key
# 同时设置一个或多个 key-value 对
MSET key value [key value ...]
# 同时查看过个key
MGET key [key ...]
# 如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾
# key: hello, value: world, append: 12345
APPEND key value
# 返回 key 所储存的字符串值的长度
STRLEN key
# INCR key为key值加1  INCRBY key n:key的值加n
# DECR key为key值减1  DECRBY key n:key的值减n
# 前提, value必须是数字字符串 -"12345"
DECR key
```

#### List类型命令

```shell
key -> string
value -> list
# 将一个或多个值 value 插入到列表 key 的表头
LPUSH key value [value ...]
# 将一个或多个值 value 插入到列表 key 的表尾 (最右边)。
RPUSH key value [value ...]
# list中删除元素
LPOP key # 删除最左侧元素
RPOP key # 删除最右侧元素
# 遍历
LRANGE key start stop
start: 起始位置, 0
stop: 结束位置, -1
#倒数第二个为-2,倒数第三为-3,依此类推
# 通过下标得到对应位置的字符串
LINDEX key index
# list中字符串的个数
LLEN key
```

#### Set类型命令

```shell
key -> string
value -> set类型 ("string", "string1")
# 添加元素
# 将一个或多个 member 元素加入到集合 key 当中，已经存在于集合的 member 元素将被忽略
SADD key member [member ...]
# 遍历
SMEMBERS key
# 差集
SDIFF key [key ...]
# 交集
SINTER key [key ...]
# 并集
SUNION key [key ...]
```

#### SortedSet 类型

```shell
key -> string
value -> sorted ([socre, member], [socre, member], ...)
# 添加元素(如果添加的member已存在,可以更新score的值)
ZADD key score member [[score member] [score member] ...]
# 遍历 (WITHSCORES参数能让成员和它的 score 值一并返回)
ZRANGE key start stop [WITHSCORES] # -> 升序集合
ZREVRANGE key start stop [WITHSCORES] # -> 降序集合
#指定分数区间内元素的个数
ZCOUNT key min max
#显示member的薪水排名
ZRANK key member#由尾至前的排名
ZREVRANK key member#由前至尾的排名
#移除有序集中的一个或多个成员
ZREM key member [member...]
#系那是成员的score值
ZSCORE key member
```

#### Hash类型命令

```shell
key ->string
value -> hash ([field:value], [field:value], [field:value], ...)
# 添加数据(field是字段)  添加一个field:value的键值对
HSET key field value
# 取某字段数据
HGET key field
# 批量插入键值对
HMSET key field value [field value ...]
# 批量取数据
HMGET key field [field ...]
# 删除键值对
HDEL key field [field ...]
#判断字段是否存在(1存在,0不存在)
HEXISTS key file
#遍历哈希表key中所有的字段和值
HGETALL key
#返回哈希表key中的所有字段
HKEYS key
#返回哈希表key中的字段数来你肝
HLEN key
#返回哈希表key中的所有字段的值
HVALS key
```

#### Key 相关的命令

```shell
# 删除键值对
DEL key [key ...]
# 查看key值
KEYS pattern
查找所有符合给定模式 pattern 的 key 。
KEYS * 匹配数据库中所有 key 。
KEYS h?llo 匹配 hello ， hallo 和 hxllo 等。
KEYS h*llo 匹配 hllo 和 heeeeello 等。
KEYS h[ae]llo 匹配 hello 和 hallo ，但不匹配 hillo
# 给key设置生存时长(seconds可以输入算式如24*60*60)
EXPIRE key seconds
#查看key当前还剩下的生存时长,无限生存时间返回的是-1
ttl key
# 取消生存时长
PERSIST key
# 返回key对应的valued的数据类型
TYPE key
#判断key值是否存在(存在返回1,否则返回0)
EXISTS key
```

### redis插件

[布隆过滤器插件](https://github.com/RedisBloom/RedisBloom/tree/v2.2.14)

 [[数据结构#布隆过滤器|了解布隆过滤器]]

### Redis数据持久化

> 持久化:数据从内存到磁盘的过程

**持久化的两种方式**

- **`rdb方式`**
  - 这是一种默认的持久化方式,默认打开
  - 磁盘的持久化文件`xxx.rdb`
  - 将内存数据以**二进制**的方式直接写入磁盘文件
  - 文件比较**小,恢复时间短,效率高**
  - 以**用户设定的频率**同步数据
- **`aof方式`**
  - 默认是关闭的
  - 磁盘的持久化文件`xxx.aof`
  - 直接将**生成数据的命令**写入磁盘文件
  - 文件比较**大,恢复时间长,效率低**
  - **每隔1s同步一次**,不可设置(由于频率很快,数据完整性高)

**二者关联**

- aof和rdb同步方式可以同时打开
- aof和rdb同步方式可以同时关闭
- 两种模式同时开启的情况下,数据恢复时
  - 效率上考虑用`rdb模式`
  - 数据完整性上考虑用`aof模式`

#### 数据持久化的配置项

```shell
#设置rdb的同步频率(设置为save ""表示关闭rdb同步方式)
	#900s内至少一个key发生变化就同步数据到磁盘上
	#300s内至少十个key发生变化就同步数据
	#60s内至少一万个key发生变化就同步数据
save 900 1
save 300 10
save 60 10000
#rdb同步到磁盘上的文件名字
dbfilename dump.rdb
#rdb和aof文件同步到磁盘上的文件的路径
dir ./
#aof文件同步功能是否要打开
appendonly no
#aof文件名字
appendfilename "appendonly.aof"
#aof的同步方式(可以设置为always,everysec或no)
	#everysec为每秒同步一次(折中方案,推荐)
	#always为每写一次就同步一次(效率最低)
	#no为操作系统想的时候才会同步(效率最高,一般不用)
appendfsync everysec
```

### Redis开发

redis开发库有很多,有官方的有第三方的,支持各种语言,在[官网有罗列(点击跳转)](http://redis.cn/clients.html)

此处以C语言的库[HIREDIS](https://github.com/redis/hiredis)作为选择

#### HIREDIS库

[HIREDIS库github链接](https://github.com/redis/hiredis)

**hiredis API接口的使用**

**连接数据库**

```c
// 连接数据库
redisContext *redisConnect(const char *ip, int port);
redisContext *redisConnectWithTimeout(const char *ip,int port, const struct timeval tv);
```

**redisContext结构体**

```c++
typedef struct redisContext {
    const redisContextFuncs *funcs;   /* Function table */

    int err; /* Error flags, 0 when there is no error 不等于0表示有错误*/
    char errstr[128]; /* String representation of error when applicable */
    redisFD fd;
    int flags;
    char *obuf; /* Write buffer */
    redisReader *reader; /* Protocol reader */

    enum redisConnectionType connection_type;
    struct timeval *connect_timeout;
    struct timeval *command_timeout;

    struct {
        char *host;
        char *source_addr;
        int port;
    } tcp;

    struct {
        char *path;
    } unix_sock;

    /* For non-blocking connect */
    struct sockaddr *saddr;
    size_t addrlen;

    /* Optional data and corresponding destructor users can use to provide
     * context to a given redisContext.  Not used by hiredis. */
    void *privdata;
    void (*free_privdata)(void *);

    /* Internal context pointer presently used by hiredis to manage
     * SSL connections. */
    void *privctx;

    /* An optional RESP3 PUSH handler */
    redisPushFn *push_cb;
} redisContext;
```

**执行redis命令函数**

```c
// 执行redis命令
void *redisCommand(redisContext *c, const char *format, ...);
//第一个参数,即c为redisConnect的返回值
//如reply = redisCommand(c,"SET %s %s", "foo", "hello world");
```

**返回值指向的结构**

```c
// redisCommand 函数实际的返回值类型
typedef struct redisReply {
/* 命令执行结果的返回类型 */
int type;
/* 存储执行结果返回为整数 */
long long integer;
/* str变量的字符串值长度 */
size_t len;
/* 存储命令执行结果返回是字符串, 或者错误信息 */
char *str;
/* 返回结果是数组, 代表数据的大小 */
size_t elements;
/* 存储执行结果返回是数组*/
struct redisReply **element;
} redisReply;
```

**type的类型盘点**

| 状态                    | 表示含义                                                     |
| ----------------------- | ------------------------------------------------------------ |
| REDIS_REPLY_STRING==1   | 返回值是**字符串**,字符串储存在redis->str当中,字符串长度为redis->len |
| REDIS_REPLY_ARRAY== 2   | 返回值是**数组**，数组大小存在redis->elements里面，数组值存储在redis->element[i]里面。数组里面存储的是指向redisReply的指针，数组里面的返回值可以通过redis->element[i]->str来访问，数组的结果里全是type==REDIS_REPLY_STRING的redisReply对象指针。 |
| REDIS_REPLY_INTEGER== 3 | 返回整数long long，从integer字段获取值                       |
| REDIS_REPLY_NIL==4      | 返回值为空表示执行结果为空                                   |
| REDIS_REPLY_STATUS==5   | 返回命令执行的状态，比如`set foo bar`返回的状态为OK，存储在str当中 `reply->str == "OK" 。` |
| REDIS_REPLY_ERROR ==6   | 命令执行错误,错误信息存放在 reply->str当中。                 |

**释放资源**

```c
//释放放回结果
void freeReplyObject(void *reply);
//释放连接
void redisFree(redisContext *c);
```

#### 测试案例

```cpp
#include "hiredis.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include<stdio.h>
#include <iostream>
using namespace std;

int main(int argc, const char** argv) {
    redisContext* c = redisConnect("127.0.0.1",6379);
    if(c->err!=0)
        return -1;
    std::cout<<"连接成功"<<std::endl;
    redisReply* ret = (redisReply*)redisCommand(c,"keys *");
    std::cout<<ret->type<<std::endl;//显示为2,为数组
    for (int i = 0; i < ret->elements; i++)
    {
        std::cout<<ret->element[i]->str<<std::endl;
    }
    freeReplyObject(ret);
    redisFree(c);
    cout<<ret->str<<endl;
    return 0;
}
```

