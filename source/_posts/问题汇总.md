---
title: 待解决问题汇总
tags: 待解决
categories: 杂项
---
以下为本人待解决问题，有能解决的大佬看到，恳请帮忙解决一下，感激不尽。

<!-- more -->

```javascript
本人qq邮箱：503969402@qq.com
```

# 问题汇总

## 问题1（已解决）

开发环境:

`Microsoft Visual Studio Community 2015`
`版本 14.0.24720.00 Update 1`
`Microsoft .NET Framework`
`版本 4.8.03761`

**问题描述**:

以下代码为什么出错？

代码如下：

```cpp
#include"iostream"
#include <string>
using namespace std;
class Building
{
	friend void GoodGay::visit();
public:
	Building()
	{
		m_SittingRoom = "客厅";
		m_BedRoom = "卧室";
	}
	string m_SittingRoom;
private:
	string m_BedRoom;
};
class GoodGay
{
public:
	GoodGay()
	{
		m_building = new Building;
	}
	void visit()//此函数要可以访问到Building
	{
		cout << "正在访问"<<this->m_building->m_SittingRoom << endl;
		cout << "正在访问" << this->m_building->m_BedRoom << endl;
	}
	Building* m_building;
};
int main() {
	GoodGay gg;
	gg.visit();
	system("pause");
	return EXIT_SUCCESS;
}
```

报错如下：

![image-20210104125726016](https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210104125726016.png)

一定要写成如下代码才能执行：

```cpp
#include"iostream"
#include <string>
using namespace std;
class Building;
class GoodGay
{
public:
	GoodGay();
	void visit();//此函数要可以访问到Building
	Building* m_building;
};
class Building
{
	friend void GoodGay::visit();
public:
	Building();
	
	string m_SittingRoom;
private:
	string m_BedRoom;
};
Building::Building()
{
	m_SittingRoom = "客厅";
	m_BedRoom = "卧室";
}
void GoodGay::visit()//此函数要可以访问到Building
{
	cout << "正在访问" << m_building->m_SittingRoom << endl;
	cout << "正在访问" << m_building->m_BedRoom << endl;
}
GoodGay::GoodGay()
{
	m_building = new Building;
}
int main() {
	GoodGay gg;
	gg.visit();
	system("pause");
	return EXIT_SUCCESS;
}
```

已解决：先后声明问题。而且必须是声明和实现隔离。

## 问题2

<img src="https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210120230828691.png" alt="image-20210120230828691" style="zoom:80%;" />

```cpp
class MyClassA:virtual public MyClass
class MyClassB:virtual public MyClass
class MyClassC:public MyClassA,public MyClassB
```

由于虚继承的本身语义，MyClassC内必须重写fun函数？

## 问题3

开发环境:

`Microsoft Visual Studio Community 2015`
`版本 14.0.24720.00 Update 1`
`Microsoft .NET Framework`
`版本 4.8.03761`

dynamicArray.h

```cpp
#pragma once
#ifdef _DEBUG
#define New   new(_NORMAL_BLOCK, __FILE__, __LINE__)
#endif
#include <iostream>
using namespace std;


template<class T>
class DynamicArray
{
	T* pArray=NULL;
	int mCapacity;
	int msize=0;
public:
	DynamicArray();

	DynamicArray(int capacity);

	DynamicArray(const DynamicArray<T>& dynamicArray);

	DynamicArray(T* t, int num);

	~DynamicArray();

	DynamicArray<T>& operator=(const DynamicArray<T>& dynamicArray);

	DynamicArray<T> operator+(const DynamicArray<T>& dynamicArray);//不改变原来的拼接

	friend ostream& operator<<<>(ostream& cout, const DynamicArray<T>& dynamicArray);
	//template<class T>//------------------------------------------------------------------------1
	//friend ostream& operator<<(ostream& cout, const DynamicArray<T>& dynamicArray);//-----------2（写1,2行表示用函数模板的方式，这样也可以，就不用写<>了）

	T& operator[](int index);

	DynamicArray<T>& append_DynamicArray(const DynamicArray<T> dynamicArray);//改变原来的拼接

	DynamicArray<T>& insert_DynamicArray(int pos,T data);//插入

	DynamicArray<T>& delete_DynamicArray(int pos);//删除

	DynamicArray<T>& clear_DynamicArray();//清空

	DynamicArray<T>& Push_back_DynamicArray(T data);//推入数据

	T Pop_back_DynamicArray();//弹出数据

	int getLength();//获取长度

	int GetCapacity();//获取容量
};
```



dynamicArray.hpp

```cpp
#include "dynamicArray.h"
#include <string.h>
template<class T>
DynamicArray<T>::DynamicArray()
{
	mCapacity = 5;
	pArray = New T[mCapacity];
	//cout<<"New一个"<<pArray<<endl;
}

template<class T>
DynamicArray<T>::DynamicArray(int capacity)
{
	mCapacity = capacity;
	pArray = New T[mCapacity];// 如果T是对象，那么这个对象必须提供默认的构造函数
	//cout << "New一个" << pArray << endl;
}

template<class T>
DynamicArray<T>::DynamicArray(const DynamicArray<T>& dynamicArray)
{
	mCapacity = dynamicArray.mCapacity;
	msize = dynamicArray.msize;
	pArray = New T[mCapacity];
	//cout << "New一个" << pArray << endl;
	memcpy(pArray, dynamicArray.pArray, sizeof(T)*mCapacity);
}

template<class T>
DynamicArray<T>::DynamicArray(T* t, int num)
{
	mCapacity = num;
	msize = num;
	pArray = New T[mCapacity];
	//cout << "New一个" << pArray << endl;
	memcpy(pArray, t, sizeof(T)*mCapacity);
}

template<class T>
DynamicArray<T>::~DynamicArray()
{
	if (pArray)
	{
		//cout << "delete一个" << pArray << endl;
		delete[] pArray;
		pArray = NULL;
	}
}

template<class T>
DynamicArray<T>& DynamicArray<T>::operator=(const DynamicArray<T>& dynamicArray)
{
	//如果有原内存空间删除原内存空间
	if (pArray)
	{
		delete[] pArray;
	}
	mCapacity = dynamicArray.mCapacity;
	pArray = New T[mCapacity];
	//cout << sizeof(T)*mCapacity << endl;
	memcpy(pArray, dynamicArray.pArray, sizeof(T)*mCapacity);
	msize = dynamicArray.msize;
	return (DynamicArray<T>&)dynamicArray;
}

template<class T>
inline DynamicArray<T> DynamicArray<T>::operator+(const DynamicArray<T>& dynamicArray)
{
	DynamicArray<T> tmpArray(msize +dynamicArray.msize);
	tmpArray.msize = msize + dynamicArray.msize;
	memcpy(tmpArray.pArray, pArray, sizeof(T)*msize);
	memcpy(tmpArray.pArray+msize, dynamicArray.pArray, sizeof(T)*dynamicArray.msize);
	return tmpArray;
}

template<class T>
inline T & DynamicArray<T>::operator[](int index)
{
	// TODO: 在此处插入 return 语句
	return pArray[index];
}

template<class T>
inline DynamicArray<T>& DynamicArray<T>::append_DynamicArray(const DynamicArray<T> dynamicArray)
{
	//查看容量是够足够拼接,不够的话就扩容
	if (mCapacity<msize+dynamicArray.msize)
	{
		mCapacity = msize + dynamicArray.msize;
		T* oldpArray = pArray;
		pArray = New T[mCapacity];
		memcpy(pArray, oldpArray, sizeof(T)*msize);
		delete[] oldpArray;
	}
	memcpy(pArray+msize, dynamicArray.pArray, sizeof(T)*dynamicArray.msize);
	msize += dynamicArray.msize;
	return *this;
}

template<class T>
inline DynamicArray<T>& DynamicArray<T>::insert_DynamicArray(int pos, T data)
{
	if (pos>msize)
	{
		pos = msize;
	}
	if (pos<0)
	{
		pos = 0;
	}
	if (msize==mCapacity)//需要扩容
	{
		mCapacity++;
		T* oldPArray = pArray;
		pArray = New T[mCapacity];
		memcpy(pArray,oldPArray,sizeof(T)*pos);
		pArray[pos] = data;
		memcpy(pArray + pos + 1, oldPArray + pos, sizeof(T)*(msize - pos));
		msize++;
		delete[] oldPArray;
	}
	else
	{
		memmove(pArray+pos+1, pArray+pos, sizeof(T)*(msize - pos));
		pArray[pos] = data;
		msize++;
	}
	return *this;
}

template<class T>
inline DynamicArray<T>& DynamicArray<T>::delete_DynamicArray(int pos)
{
	if (pos >= msize)
	{
		pos = msize-1;
	}
	if (pos < 0)
	{
		pos = 0;
	}
	memmove(pArray + pos, pArray + pos + 1,sizeof(T)*(msize - pos - 1));//memcpy不能处理重叠位置的挪移，要用memmove
	msize--;
	return *this;
}

template<class T>
inline DynamicArray<T>& DynamicArray<T>::clear_DynamicArray()
{
	msize = 0;
	return *this;
}

template<class T>
inline DynamicArray<T>& DynamicArray<T>::Push_back_DynamicArray(T data)
{
	if (msize == mCapacity)//需要扩容
	{
		mCapacity++;
		T* oldPArray = pArray;
		pArray = New T[mCapacity];
		memcpy(pArray, oldPArray, sizeof(T)*msize);
		pArray[msize] = data;
		msize++;
		delete[] oldPArray;
	}
	else
	{
		pArray[msize] = data;
		msize++;
	}
	return *this;
}

template<class T>
inline T DynamicArray<T>::Pop_back_DynamicArray()
{
	if (this->m_Size == 0)
	{
		return NULL;
	}
	msize--;
	return pArray[msize];
}

template<class T>
inline int DynamicArray<T>::getLength()
{
	return msize;
}

template<class T>
inline int DynamicArray<T>::GetCapacity()
{
	return mCapacity;
}



template<class T>
ostream& operator<<(ostream& cout, const DynamicArray<T>& dynamicArray)
{
	for (int i = 0; i < dynamicArray.msize; i++)
	{
		cout << dynamicArray.pArray[i] << " ";
	}
	return cout;
}
```





main.cpp

```cpp
#include <iostream>
using namespace std;
#include "dynamicArray.hpp"
//下面用于定位内存泄露位置

#ifdef _DEBUG
#define New   new(_NORMAL_BLOCK, __FILE__, __LINE__)
#endif

#define CRTDBG_MAP_ALLOC  
#include <stdlib.h>  
#include <crtdbg.h> 
#include <string>


//用Person类来测试动态数组模板类
class Person
{
	string mName;
	int mAge;
public:
	Person(){ cout << "临时构造" << this << endl; }//必须提供默认构造函数，才能供dynamicArray构造Person
	~Person(){cout<<"析构"<<mName<<this<<endl;}
	Person(Person& p)
	{
		mAge=p.mAge ;
		mName=p.mName;
		cout<<"拷贝构造"<<mName<<this<<endl;
	}
	Person(string name,int age)
	{
		mName = name;
		mAge = age;
		cout << "有参构造" << mName << this << endl;
	}
	friend ostream& operator<<(ostream& cout, Person& p)//必须提供默认构造函数，才能供dynamicArray输出显示
	{
		cout << "年龄：" << p.mAge << "  名称：" << p.mName<<endl;
		return cout;
	}
};



void intDynamicArrayTest()
{
	int a[5] = { 5,4,3,2,1 };
	int b[5] = { 1,2,3,4,5 };
	DynamicArray<int> dynamicArray(b, 5);
	DynamicArray<int> dynamicArray1(a, 5);
	dynamicArray.insert_DynamicArray(10, 9).insert_DynamicArray(10, 10);
	dynamicArray.delete_DynamicArray(10).delete_DynamicArray(10);
	cout<< dynamicArray <<endl;
	cout << dynamicArray1 << endl;

}

void personDynamicArrayTest()
{
	Person p1("小明", 16);
	Person p2("小红", 22);
	Person p3("小张", 18);
	Person p4("小白", 20);
	DynamicArray<Person> dynamicArray;
	dynamicArray.insert_DynamicArray(0,p1);
	cout<<dynamicArray<<endl;
	dynamicArray.insert_DynamicArray(0, p4);
	cout << dynamicArray << endl;

}


int main()
{
	//intDynamicArrayTest();
	personDynamicArrayTest();
	_CrtDumpMemoryLeaks();//用于检测内存泄露，必须放在此处,开辟test函数的目的是为了当test函数执行完后，该释放的内存早该释放了，此时才可以在这里测试是否有内存泄露
	return 0;
}
```

运行如下：

![image-20210220172330584](https://raw.githubusercontent.com/che77a38/blogImage/main/image-20210220172330584.png)

无法理解！