---
title: 数据结构
date: 2020-12-23 22:51:13
tags: 数据结构
categories: 技术

---

数据结构学习

<!-- more -->



# 数据结构

**数据结构**是计算机存储、组织数据的方式。是相互之间存在一种或多种特定关系的数据元素集合

**算法**是特定问题求解步骤的描述，在计算机中表现为***指令的有限序列***，算法是独立存在的一种解决问题的方法和思想。

> 对于算法而言，语言并不重要，重要的是思想。

***算法和数据结构区别***

1. ***算法是为了解决实际问题而设计的。***
2. **数据结构是算法需要处理的问题载体。**
3. 数据结构与算法相辅相成。

***算法具有五个基本的特性：输入、输出、有穷性、确定性和可行性***

-  **输入输出**：算法具有零个或多个输入、至少有一个或多个输出。
-  **有穷性**：指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。
-  **确定性**：算法的每一步骤都有确定的含义，不会出现二义性。
-  **可行性**：算法的每一步都必须是可行的，也就是说，每一步都能通过执行有限次数完成。

## ***数据结构分类***

###  ***逻辑结构***

#### 集合结构

集合结构中的数据元素除了同属于一个集合外，他们之间没有其他关系。各个数据元素是平等的。他们共同属于同一个集合，数据结构中的集合关系类似于数学中的集合。如图：

![img](https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8723.png)

#### 线性结构

线性结构中的数据元素之间是**一对一**的关系。

> 一对一：第一个元素没有前驱，最后一个元素没有后续，其他元素都有一个前驱一个后继

如图：

![img](https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8724.png)

#### 树形结构

树形结构中是数据元素之间存在一种**一对多**的层次关系，如图：

![img](https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8725.png)



#### 图形结构

图形结构的数据元素**多对多**的关系，如图：

![img](https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8726.png)

### 物理结构

物理结构：是指数据的逻辑结构在计算机中的存储形式，共分为两种：顺序存储和链式存储。

#### 顺序存储

是把数据元素存放在地址连续的存储单元里，其数据的逻辑关系和物理关系是一致的，如图：

![img](https://raw.githubusercontent.com/che77a38/blogImage2/main/%E5%9B%BE%E7%89%8727.png)



#### 链式存储结构

是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关数据的位置。如图：

![img](https://raw.githubusercontent.com/che77a38/blogImage2/main/%E5%9B%BE%E7%89%8728.png)

## 线性表

线性结构是一种最简单且常用的数据结构。线性结构的基本特点是节点之间满足线性关系。

**动态数组、链表、栈、队列**都属于线性结构。

线性表是零个或者多个数据元素的有限序列，***数据元素之间是有顺序的***，***数据元素个数是有限的***，***数据元素的类型必须相同***

### 动态数组

下图中的链表指的就是**动态数组**

![img](https://raw.githubusercontent.com/che77a38/blogImage2/main/%E5%9B%BE%E7%89%8729.png)

优点：

- 无需为线性表中的逻辑关系增加额外的空间。
- 可以快速的获取表中合法位置的元素。

缺点：

- 插入和删除操作需要移动大量元素。

#### 动态数组案例：

##### dynamicArray.h头文件

```c
/***************************************************** ************************* 
* @版权所有（c）2020，Peng，保留所有权利。 
* @文件路径:    C:\USERS\ADMINISTRATOR\DESKTOP\C语言学习案例（内含数据结构）\动态数组案例\DYNAMICARRAY\dynamicArray.h 
* @版本：1.0版 
* @作者：Peng 
* @创建时间：2020 / 11 / 05 17：06 
* @文件描述： 动态数组头文件
****************************************************** ************************/  


#pragma once
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//未使用void*重命名隐藏DynamicArray指针的索引，并且未将如下结构体置于源文件中，防止生成库时用户直接在头文件中看到
typedef struct _DynamicArray
{
	void **ArrayAddr;//动态数组首地址
	int m_capacity;//动态数组当前容量
	int m_size;//动态数组当前占用大小
}DynamicArray;


//动态数组初始化
DynamicArray* init_DynamicArray(int capacity);

//动态数组遍历
void foreach_DynamicArray(DynamicArray* dynamicArray,void(*myPrintf)(void*));


//动态数组末尾添加
void append_DynamicArray(DynamicArray* dynamicArray,void* data);


//动态数组插入
void insert_DynamicArray(DynamicArray* dynamicArray, int pos, void* data);


//动态数组修改
void change_DynamicArray(DynamicArray* dynamicArray, int pos, void* data);


//动态数组项删除
void removeByPos_DynamicArray(DynamicArray* dynamicArray,int pos);


//动态数组清空
void clear_DynamicArray(DynamicArray* dynamicArray);


//动态数组销毁
void destroy_DynamicArray(DynamicArray** dynamicArray);

```

##### dynamicArray.c源文件

```c
/***************************************************** ************************* 
* @版权所有（c）2020，Peng，保留所有权利。 
* @文件路径:    C:\USERS\ADMINISTRATOR\DESKTOP\C语言学习案例（内含数据结构）\动态数组案例\DYNAMICARRAY\dynamicArray.c 
* @版本：1.0版 
* @作者：Peng 
* @创建时间：2020 / 11 / 05 17：06 
* @文件描述： 动态数组源文件
****************************************************** ************************/  
#include "dynamicArray.h"

DynamicArray* init_DynamicArray(int capacity)
{
	if (capacity<=0)
	{
		return NULL;
	}
	DynamicArray* dynamicArray = malloc(sizeof(DynamicArray));
	if (!dynamicArray)
	{
		return NULL;
	}
	dynamicArray->ArrayAddr = malloc(sizeof(void*)*capacity);
	if (!dynamicArray->ArrayAddr)
	{
		free(dynamicArray);
		return NULL;
	}
	dynamicArray->m_capacity = capacity;
	dynamicArray->m_size = 0;
	return dynamicArray;
}

void foreach_DynamicArray(DynamicArray* dynamicArray, void(*myPrintf)(void*))
{
	if (!dynamicArray||!myPrintf)
	{
		return;
	}
	printf("容量：%d  占用大小：%d\r\n",dynamicArray->m_capacity,dynamicArray->m_size);
	for (size_t i = 0; i < dynamicArray->m_size; i++)
	{
		myPrintf(dynamicArray->ArrayAddr[i]);
	}
}


void insert_DynamicArray(DynamicArray* dynamicArray, int pos, void* data)
{
	if (!dynamicArray||!data)
	{
		return;
	}
	//无效位置，则尾插
	if (pos<0||pos>dynamicArray->m_size)
	{
		pos = dynamicArray->m_size;
	}
	//空间不够则拓展空间
	if (dynamicArray->m_size==dynamicArray->m_capacity)
	{
		dynamicArray->ArrayAddr = realloc(dynamicArray->ArrayAddr, dynamicArray->m_capacity *sizeof(void*)*2);
		dynamicArray->m_capacity*=2;
	}
	//后面元素往后移动
	for (int i = dynamicArray->m_size-1; i >=pos; i--)
	{
		dynamicArray->ArrayAddr[i + 1] = dynamicArray->ArrayAddr[i];
	}
	//插入新元素
	dynamicArray->ArrayAddr[pos] = data;
	dynamicArray->m_size++;
	
	
}


void change_DynamicArray(DynamicArray* dynamicArray, int pos, void* data)
{
	if (!dynamicArray || !data)
	{
		return;
	}
	//无效位置
	if (pos<0 || pos>=dynamicArray->m_size)
	{
		return;
	}
	dynamicArray->ArrayAddr[pos] = data;
}

void clear_DynamicArray(DynamicArray* dynamicArray)
{
	if (!dynamicArray )
	{
		return;
	}
	memset(dynamicArray->ArrayAddr, 0,sizeof(void*)*dynamicArray->m_size);
	dynamicArray->m_size = 0;
}



void destroy_DynamicArray(DynamicArray** dynamicArray)
{
	if (!(*dynamicArray))
	{
		return;
	}
	if ((*dynamicArray)->ArrayAddr!=NULL)
	{
		free((*dynamicArray)->ArrayAddr);
		(*dynamicArray)->ArrayAddr = NULL;
	}
	free(*dynamicArray);
	*dynamicArray = NULL;
	
}


void removeByPos_DynamicArray(DynamicArray* dynamicArray, int pos)
{
	if (!dynamicArray)
	{
		return;
	}
	if (pos < 0 || pos >= dynamicArray->m_size)
	{
		return;
	}
	for (int i = 0; i < dynamicArray->m_size-1; i++)
	{
		if (i>=pos)
		{
			dynamicArray->ArrayAddr[i] = dynamicArray->ArrayAddr[i + 1];
		}
	}
	dynamicArray->ArrayAddr[dynamicArray->m_size - 1] = NULL;
	dynamicArray->m_size--;
}


```



### 链表

数组缺陷：

1. 静态空间，一旦分配内存就不可以动态扩展，如果分配过多，造成资源浪费，空间操作不精确
2. 插入删除效率低

> **链表的构成**
>
> 链表由节点构成
>
> 节点由数据域（维护数据）和指针域（维护上一个或下一个节点）组成

**带头节点指针pHeader，和尾节点指针pTail**

但大多数链表都只带头节点，如下图

![img](https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8716.png)

不带链表头节点如下图：

![img](https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8720.png)

> 头结点不固定，根据实际需要变换头结点(如在原来头结点前插入新节点，然后，新节点重新作为链表的头结点)。

优势：带头结点永远固定了头节点和尾节点的位置，方便头部和尾部的操作

链表的分类一：

1. 静态链表 （在栈上分配内存）

```c
//链表节点的结构体
typedef struct _LinkNode
{
	int num;//数据域
	struct LinkNode* next;//指针域
}LinkNode;

void main()
{
    //创建节点
    LinkNode node1={10,NULL};
    LinkNode node2={20,NULL};
    LinkNode node3={30,NULL};
    //建立关系
    node1.next=&node2;
    node2.next=&node3;
    //遍历链表
    LinkNode* pCurrent=&node1;
    while(pCurrent!=NULL)
    {
        //此处可遍历数据
        printf("%d\r\n",pCurrent.num);
        pCurrent=pCurrent->next;
	}  
}
```

2. 动态链表（在堆上分配内存）

```c
//链表节点的结构体
typedef struct _LinkNode
{
	int num;//数据域
	struct LinkNode* next;//指针域
}LinkNode;

void main()
{
    //创建节点
    LinkNode* node1=malloc(sizeof(LinkNode));
    LinkNode* node2=malloc(sizeof(LinkNode));
    LinkNode* node3=malloc(sizeof(LinkNode));
    node1->num=100;
    node2->num=200;
    node3->num=300;
    //建立关系
    node1->next=node2;
    node2->next=node3;
    node3->next=NULL;
    //遍历链表
    LinkNode* pCurrent=node1;
    while(pCurrent!=NULL)
    {
        //此处可遍历数据
        printf("%d\r\n",pCurrent->num);
        pCurrent=pCurrent->next;
	}  
    //释放空间
    free(node1);
    free(node2);
    free(node3);
    node1=null;
    node2=null;
    node3=null;
}
```

链表的分类二

1. 单向链表

![img](https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8717.png)

2. 双向链表

![img](https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8718.png)

3. 单向循环链表

![img](https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8719.png)

4. 双向循环链表



#### **链表案例：**

##### linkList.h头文件

```c
/***************************************************** ************************* 
* @版权所有（c）2020，Peng，保留所有权利。 
* @文件路径:    C:\USERS\ADMINISTRATOR\DESKTOP\C语言学习案例（内含数据结构）\链表案例\LINKNODETEST\linkList.h 
* @版本：1.0版 
* @作者：Peng 
* @创建时间：2020 / 11 / 06 15：38 
* @文件描述： 链表头文件，链表一切空间申请释放均已处理
****************************************************** ************************/  

#pragma once
#include <stdio.h>
#include <string.h>
#include <stdlib.h>


//此处由于C语言中没有C++类似的保护内部数据防止直接访问的机制，因此用void*的方式可以防止使用我们代码的用户访问到内部成员（就是点不出来），而我们自己使用的时候再自己进行强转使用。
typedef void* LinkList;


//初始化链表
LinkList* init_LinkList();


//遍历链表
void foreach_LinkList(LinkList* linklist, void(*myPrintf)(void*));


//添加节点
void append_LinkList(LinkList* linklist, void* data);


//插入链表
void insert_LinkList(LinkList* linklist, int pos, void* data);


//删除节点
void delete_LinkList(LinkList* linklist, int pos);


//反转链表
void reverse_LinkList(LinkList* linklist);


//清空链表 
void clear_LinkList(LinkList* linklist);


//销毁链表
void destroy_LinkList(LinkList** linklist);


//返回长度
int getLength_LinkList(LinkList* linklist);
```

##### linkList.cpp源文件

```c
/***************************************************** ************************* 
* @版权所有（c）2020，Peng，保留所有权利。 
* @文件路径:    C:\USERS\ADMINISTRATOR\DESKTOP\C语言学习案例（内含数据结构）\链表案例\LINKNODETEST\linkList.cpp 
* @版本：1.0版 
* @作者：Peng 
* @创建时间：2020 / 11 / 06 15：38 
* @文件描述： 链表源文件，链表一切空间申请释放均已处理
****************************************************** ************************/  
#include "linkList.h"

//重点：该结构体放在源文件中的目的是当把这个文件生成库文件时，可以避免用户直接在头文件中直接看到该结构的真实情况
//节点结构体，用于组织成链表
typedef struct _LinkNode
{
	void* data;
	struct _LinkNode* next;
}LinkNode;


//链表结构体，用于维护链表整体的必要数据
typedef struct __LinkList
{
	LinkNode* pHeader;//链表头节点
	int m_size;//链表长度
}_LinkList;

LinkList* init_LinkList()
{
	LinkList* linklist = (LinkList*)malloc(sizeof(LinkList));
	LinkNode* pHeader = (LinkNode*)malloc(sizeof(LinkNode));
	if (!pHeader)
	{
		return NULL;
	}
	pHeader->data = NULL;//无用数据
	pHeader->next = NULL;
	((_LinkList*)linklist)->m_size = 0;
	((_LinkList*)linklist)->pHeader = pHeader;
	return linklist;
}


void foreach_LinkList(LinkList* _linklist, void(*myPrintf)(void*))
{
	_LinkList* linklist = _linklist;
	//参数校验
	if (!linklist || !linklist->pHeader||!myPrintf)
	{
		return;
	}
	printf("-------------------------------------------------\r\n");
	//遍历操作
	LinkNode* pCurrent = linklist->pHeader->next;
	while (pCurrent)
	{
		myPrintf(pCurrent->data);
		pCurrent = pCurrent->next;
	}
	printf("链表数量为%d\r\n", linklist->m_size);
	printf("-------------------------------------------------\r\n");
	printf("\r\n");
	
}

void append_LinkList(LinkList* _linklist, void* data)
{
	_LinkList* linklist = _linklist;
	//参数校验
	if (!linklist || !linklist->pHeader ||  !data)
	{
		return;
	}
	//申请空间并拷贝添加节点内存
	LinkNode* pAppend = (LinkNode*)malloc(sizeof(LinkNode));
	if (!pAppend)
	{
		return;
	}
	pAppend->data = data;
	//添加操作
	LinkNode* pCurrent = linklist->pHeader;
	while (pCurrent->next)
	{
		pCurrent = pCurrent->next;
	}
	pCurrent->next = pAppend;
	pAppend->next = NULL;
	linklist->m_size++;

}




void insert_LinkList(LinkList* _linklist, int pos, void* data)
{
	_LinkList* linklist = _linklist;
	//参数校验
	if ( !linklist||!linklist->pHeader || !data ||!linklist)
	{
		return;
	}
	if (pos < 0||pos> linklist->m_size)//无效位置,强制做尾插
	{
		pos = linklist->m_size;
	}
	//找到插入位置
	LinkNode* pCurrent = linklist->pHeader;
	int curPos = 0;
	while (pCurrent->next)
	{
		if (pos == curPos)
		{
			break;
		}
		pCurrent = pCurrent->next;
		curPos++;
	}


	//申请空间并拷贝插入节点内存
	LinkNode* pInsert = (LinkNode*)malloc(sizeof(LinkNode));
	if (!pInsert)
	{
		return;
	}
	pInsert->data = data;

	//插入操作
	pInsert->next = pCurrent->next;
	pCurrent->next = pInsert;
	linklist->m_size++;


}

void delete_LinkList(LinkList* _linklist, int pos)
{
	_LinkList* linklist = _linklist;
	if (!linklist || !linklist->pHeader)
	{
		return;
	}
	if (pos < 0 || pos>= linklist->m_size)
	{
		return;
	}
	//找到位置
	LinkNode* pCurrent = linklist->pHeader;
	int curPos = 0;
	while (pCurrent->next)
	{
		if (pos == curPos)
		{
			break;
		}
		pCurrent = pCurrent->next;
		curPos++;
	}
	//删除操作票
	if (!pCurrent->next)
	{
		return;
	}
	LinkNode* pNext = pCurrent->next->next;//临时储存后面链表
	free(pCurrent->next);
	pCurrent->next = pNext;
	linklist->m_size--;



}

void reverse_LinkList(LinkList* _linklist)
{
	_LinkList* linklist = _linklist;
	if (!linklist || !linklist->pHeader&&!linklist->pHeader->next)//排除链表没有或者只有一个的情况
	{
		return;
	}
	LinkNode* pCurrent = linklist->pHeader->next;
	LinkNode* pCurrentNext = pCurrent->next;
	LinkNode* pCurrentNextNext = NULL;
	while (pCurrentNext)//链表还有两个节点以上的时候
	{
		if (pCurrentNext->next)//链表还有第三个节点的时候，记录第三个节点,否则记录为NULL
		{
			pCurrentNextNext = pCurrentNext->next;
		}
		else
		{
			pCurrentNextNext = NULL;
		}
		//对前两个节点进行翻转操作
		pCurrentNext->next = pCurrent;
		//两指针后移一段
		pCurrent = pCurrentNext;
		pCurrentNext = pCurrentNextNext;
	}
	//跳出循环后pCurrent为尾节点指针,现将头节点指向的节点的next置空，然后头节点指针指向尾节点
	linklist->pHeader->next->next = NULL;
	linklist->pHeader->next = pCurrent;
}




void clear_LinkList(LinkList* _linklist)
{
	_LinkList* linklist = _linklist;
	if (!linklist || !linklist->pHeader)
	{
		return;
	}
	LinkNode* tmpCurrent = NULL;
	while (linklist->pHeader->next)
	{
		tmpCurrent = linklist->pHeader->next->next;
		free(linklist->pHeader->next);
		linklist->pHeader->next = tmpCurrent;
		tmpCurrent = NULL;
	}
	linklist->m_size=0;
}


void destroy_LinkList(LinkList** _linklist)
{
	_LinkList** linklist = _linklist;
	if (!*linklist || !(*linklist)->pHeader)
	{
		return;
	}
	LinkNode* tmpCurrent = NULL;
	LinkNode* pCurrent = (*linklist)->pHeader;
	while (pCurrent)
	{
		tmpCurrent = pCurrent->next;
		free(pCurrent);
		pCurrent = tmpCurrent;
	}
	(*linklist)->pHeader = NULL;
	if (!*linklist)
	{
		free(*linklist);
		*linklist = NULL;
	}
}


int getLength_LinkList(LinkList* _linklist)
{
	_LinkList* linklist = _linklist;
	if (!linklist|| !linklist->pHeader)
	{
		return 0;
	}
	return linklist->m_size;
}



```

## 受限线性表

### 栈(Stack)

Ø 概念：

> 首先它是一个线性表，也就是说，栈元素具有线性关系，即前驱后继关系。只不过***\*它是一种特殊的线性表\****而已。定义中说是在线性表的表尾进行插入和删除操作，这里表尾是指栈顶，而不是栈底。

***它的特殊之处在于限制了这个线性表的插入和删除的位置，它始终只在栈顶进行。这也就使得：栈底是固定的，最先进栈的只能在栈底。***（**先入后出**）

![img](https://raw.githubusercontent.com/che77a38/blogImage2/main/%E5%9B%BE%E7%89%8730.png)

栈顶：top 

#### 栈的作用**

##### **就近匹配**

当需要检测成对出现但又互不相邻的事物时可以使用栈“后进先出”的特性

括号匹配检测案例如下：

```c
//从第一个字符开始扫描
//--当遇见普通字符时忽略，
//--当遇见左括号时压入栈中
//--当遇见右括号时从栈中弹出栈顶符号，并进行匹配
//----匹配成功：继续读入下一个字符
//----匹配失败：立即停止，并报错
//结束：
//成功: 所有字符扫描完毕，且栈为空
//失败：匹配失败或所有字符扫描完毕但栈非空

void 利用栈判断字符串括号是否匹配_printfError(char* originStr,char* myErrorStr,char* p)
{
	printf("%s\r\n", myErrorStr);
	printf("--------------------[ErrorPos]-------------------\r\n");
	printf("%s\r\n",originStr);
	for (int i = 0; i < p-originStr; i++)
	{
		printf(" ");
	}
	printf("|\r\n");
	printf("-------------------------------------------------\r\n");
}


int 利用栈判断字符串括号是否匹配(char* str,char left,char right)
{
	if (left==right)
	{
		return 0;
	}
	if (!str)
	{
		return 0;
	}
	char* p = str;
	SeqStack stack = init_SeqStack();

	while (*p !=0)
	{
		if (*p== left)
		{
			push_SeqStack(stack, p);
		}
		if (*p== right)
		{
			if (size_SeqStack(stack)>0)
			{
				pop_SeqStack(stack);
			}
			else
			{
				利用栈判断字符串括号是否匹配_printfError(str,"多余右括号无匹配!",p);
				return 0;
			}
		}

		p++;
	}
	if (size_SeqStack(stack)==0)
	{
		return 1;//匹配
	}
	while (size_SeqStack(stack)>0)
	{
		利用栈判断字符串括号是否匹配_printfError(str, "多余左括号无匹配!", top_SeqStack(stack));
		pop_SeqStack(stack);
	}
	return 0;//不匹配
}
```

##### 中缀表达式转后缀表达式计算

功能：为了解决运算符优先度问题

**后缀表达式**（由波兰科学家在20世纪50年代提出）

将运算符放在数字后面，符合计算机运算

我们习惯的数学表达式叫做中缀表达式，符合人类思考习惯

```javascript
//中缀表达式=>后缀表达式
//符合人类思考习惯=>符合计算机运算
//如下：
5 + 4 => 5 4 +  
1 + 2 * 3 => 1 2 3 * +  
8 +( 3 – 1 ) * 5 => 8 3 1 – 5 * +
```

中缀转后缀算法案例:

```c
//遍历中缀表达式中的数字和符号：
//--对于数字：直接输出
//--对于符号：
//----左括号：进栈  
//----运算符号：与栈顶符号进行优先级比较
//------若栈顶符号优先级低：此符号进栈  
//--------（默认栈顶若是左括号，左括号优先级最低）
//------若栈顶符号优先级不低：将栈顶符号弹出并输出，之后进栈
//----右括号：将栈顶符号弹出并输出，直到匹配左括号,将左括号和右括号同时舍弃
//遍历结束：将栈中的所有符号弹出并输出

```

后缀计算出结果算法案例:

```c
//遍历后缀表达式中的数字和符号
//--对于数字：进栈
//--对于符号：
//----从栈中弹出右操作数
//----从栈中弹出左操作数
//----根据符号进行运算
//----将运算结果压入栈中
//遍历结束：栈中的唯一数字为计算结果

```

自己想出来的用双栈进行公式优先级计算的方法

```c
double 双浮点四则运算(double firstNum, double secondNum, char operator)
{
	switch (operator)
	{
	case '+':
		return firstNum + secondNum;
		break;
	case '-':
		return firstNum - secondNum;
		break;
	case '*':
		return firstNum * secondNum;
		break;
	case '/':
		return firstNum / secondNum;
		break;
	}
}

//只允许一个小数点，否则结果无意义,结果为精确到小数后6位
double 字符数组转小数(char* numStr)
{
	if (!numStr)
	{
		return 0;
	}
	int spotPos = -1;
	int i;
	for (i = 0; numStr[i] != '\0'; i++)
	{
		if (numStr[i] == '.')
		{
			spotPos = i;
		}
	}
	double answer = 0;
	if (spotPos != -1)//有小数点
	{
		int numWeight = spotPos - 1;
		for (int j = 0; numStr[j] != '\0'; j++)
		{
			if (numStr[j] == '.')
			{
				continue;
			}
			int tmp = numStr[j] - '0';
			answer += pow(10, numWeight)*tmp;


			numWeight--;
		}
	}
	else
	{
		int numWeight = i - 1;
		for (int j = 0; numStr[j] != '\0'; j++)
		{
			int tmp = numStr[j] - '0';
			answer += pow(10, numWeight)*tmp;
			numWeight--;
		}
	}
		return answer;
}

//对两个栈中单符号进行运算后将返回运算结果
double 双栈单符号运算(SeqStack numStack,SeqStack operatorStack)
{
	char topCh = *(char*)top_SeqStack(operatorStack);
	pop_SeqStack(operatorStack);
	double secondNum = *(double*)top_SeqStack(numStack);
	pop_SeqStack(numStack);
	double firstNum=0;
	if (top_SeqStack(numStack) != NULL)
	{
		firstNum = *(double*)top_SeqStack(numStack);
		pop_SeqStack(numStack);
	}
	return 双浮点四则运算(firstNum, secondNum, topCh);
}


//运算过程中允许使用的最大double类型空间使用个数
#define MAXALLOW 999

//若为符号  右括号，就近匹配左括号，将中间运算做完，将结果入数字栈
//第一个要解决的是多位数字问题
double 双栈公式计算法(char* formulas)
{
	if (!formulas)
	{
		return;
	}
	if (!利用栈判断字符串括号是否匹配(formulas, '(', ')'))//符号匹配校验
	{
		return;
	}
	
	int dIndex = 0;
	double dArray[MAXALLOW] = { 0 };
	SeqStack numStack = init_SeqStack();
	SeqStack operatorStack = init_SeqStack();
	dynamicChArray chArray = init_dynamicChArray(5);
	for (int i = 0; formulas[i] != '\0'; i++)
	{
		//////////////////////////////////////////////////////////////////////////此处思考解决多位数字
		if ((formulas[i] <= '9'&&formulas[i] >= '0')||(formulas[i] =='.'))//若为单个数字或者小数点，入数字字符动态数组(此处未规避非单小数点风险)
		{
			append_dynamicChArray(chArray, formulas[i]);
		}
		else//若为符号入栈
		{
			if (size_dynamicChArray(chArray)>0)//当遇到任意符号时将累积下来的数字字符转成小数入数字栈
			{
				if (dIndex < MAXALLOW)
				{
					dArray[dIndex] = 字符数组转小数(pChar_dynamicChArray(chArray));
					push_SeqStack(numStack, &dArray[dIndex]);
					clear_dynamicChArray(chArray);
					dIndex++;
				}
				else//溢出错误
					return;
			}
			//处理括号
			char tmpCh;
			char* top = top_SeqStack(operatorStack);
			//处理四则运算优先级
			//按照优先级，当栈顶是*，/而准备入栈的是+—的时候，直接运算*，/后再入栈
			if (top && (*top == '*' || *top == '/') && (formulas[i] == '+' || formulas[i] == '-'))
			{
				//结果的浮点数入数字栈
				dArray[dIndex] = 双栈单符号运算(numStack, operatorStack);
				push_SeqStack(numStack, &dArray[dIndex]);
				dIndex++;
				push_SeqStack(operatorStack, &formulas[i]);
			}
			else if (formulas[i] == ')')//遇到右括号，循环进行配对括号中所有计算
			{
				
				while ((tmpCh = *(char*)top_SeqStack(operatorStack)) != '(')//将符号栈中除了左括号之外的所有符号运算完
				{
					if (size_SeqStack(numStack) < 2)//并未具体针对（1）这样的给出解决方案
					{
						return;
					}
					dArray[dIndex] = 双栈单符号运算(numStack,operatorStack);
					push_SeqStack(numStack, &dArray[dIndex]);
					dIndex++;
				}
				pop_SeqStack(operatorStack);//弹出多余左括号
			}
			else 
				push_SeqStack(operatorStack, &formulas[i]);




		}

	}
	if (size_dynamicChArray(chArray) > 0)//当遇到任意符号时将累积下来的数字字符转成小数入数字栈(此处重复是为了避免数字封尾，最后的数字无法入数字栈)
	{
		if (dIndex < MAXALLOW)
		{
			dArray[dIndex] = 字符数组转小数(pChar_dynamicChArray(chArray));
			push_SeqStack(numStack, &dArray[dIndex]);
			clear_dynamicChArray(chArray);
			dIndex++;
		}
		else//溢出错误
			return;
	}



	//括号，*，/已经已全部剔除完毕情况的运算
	while (size_SeqStack(operatorStack) > 0)//符号栈非空
	{
		dArray[dIndex] = 双栈单符号运算(numStack,operatorStack);
		push_SeqStack(numStack, &dArray[dIndex]);
		dIndex++;
	}
	double answer = *(double*)top_SeqStack(numStack);
	//空间释放
	destroy_SeqStack(&numStack);
	destroy_SeqStack(&operatorStack);
	destroy_dynamicChArray(&chArray);
	return answer;
}
```





**栈主要是两种**

1. 栈的顺序存储（数组）

#### 栈的顺序存储案例

##### SeqStack.h顺序栈头文件

```c
/***************************************************** ************************* 
* @版权所有（c）2020，Peng，保留所有权利。 
* @文件路径:    C:\USERS\ADMINISTRATOR\DESKTOP\C语言学习案例（内含数据结构）\SEQSTACK\SeqStack.h 
* @版本：1.0版 
* @作者：Peng 
* @创建时间：2020 / 11 / 18 15：47 
* @文件描述： 顺序栈头文件
****************************************************** ************************/  
#pragma once


#define MAX_STACK_LENGHT 100



typedef void* SeqStack;


//初始化栈
SeqStack init_SeqStack();

//入栈
void push_SeqStack(SeqStack _stack,void* data);

//出栈
void pop_SeqStack(SeqStack _stack);

//返回栈顶
void* top_SeqStack(SeqStack _stack);

//返回栈大小
int size_SeqStack(SeqStack _stack);

//判断栈是否为空
int isEmpty_SeqStack(SeqStack _stack);

//销毁栈
void destroy_SeqStack(SeqStack* _stack);
```

##### SeqStack.c顺序栈源文件

```c
/***************************************************** ************************* 
* @版权所有（c）2020，Peng，保留所有权利。 
* @文件路径:    C:\USERS\ADMINISTRATOR\DESKTOP\C语言学习案例（内含数据结构）\SEQSTACK\SeqStack.c 
* @版本：1.0版 
* @作者：Peng 
* @创建时间：2020 / 11 / 18 15：46 
* @文件描述： 顺序栈源文件
****************************************************** ************************/  
#include "SeqStack.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//该结构体放在源文件中的目的是当把这个文件生成库文件时，可以避免用户直接在头文件中直接看到该结构的真实情况
typedef struct __SeqStack
{
	void* data[MAX_STACK_LENGHT];
	int m_Size;
}_SeqStack;


SeqStack init_SeqStack()
{
	_SeqStack* stack = (_SeqStack*)malloc(sizeof(_SeqStack));
	if (!stack)
	{
		return;
	}
	stack->m_Size = 0;
	memset(stack->data, NULL, MAX_STACK_LENGHT*sizeof(void*));
	return stack;

}


void push_SeqStack(SeqStack _stack, void* data)
{
	_SeqStack* stack = _stack;
	if (!stack||!data)
	{
		return;
	}
	if (stack->m_Size==MAX_STACK_LENGHT)//超出容量
	{
		return;
	}
	stack->data[stack->m_Size++] = data;
}


void pop_SeqStack(SeqStack _stack)
{
	_SeqStack* stack = _stack;
	if (!stack )
	{
		return;
	}
	stack->data[stack->m_Size--] = NULL;
}


void* top_SeqStack(SeqStack _stack)
{
	_SeqStack* stack = _stack;
	if (!stack )//无栈
	{
		return NULL;
	}
	if (stack->m_Size==0)//空栈
	{
		return NULL;
	}
	return stack->data[stack->m_Size - 1];
}


int size_SeqStack(SeqStack _stack)
{
	_SeqStack* stack = _stack;
	if (!stack)
	{
		return -1;
	}
	return stack->m_Size;
}



int isEmpty_SeqStack(SeqStack _stack)
{
	_SeqStack* stack = _stack;
	if (!stack)
	{
		return -1;
	}
	if (stack->m_Size==0)
	{
		return 1;
	}
	return 0;
}



void destroy_SeqStack(SeqStack* _stack)
{
	if (*_stack)
	{
		_SeqStack** stack = _stack;
		free(*stack);
		*stack = NULL;
	}
}
```

2. 栈的链式存储（链表）

#### 栈的链式存储案例

头节点做栈顶，利于压栈出栈的操作

##### LinkListStack.h链栈头文件

```c
/***************************************************** ************************* 
* @版权所有（c）2020，Peng，保留所有权利。 
* @文件路径:    C:\USERS\ADMINISTRATOR\DESKTOP\C语言学习案例（内含数据结构）\SEQSTACK\LinklistStack.h 
* @版本：1.0版 
* @作者：Peng 
* @创建时间：2020 / 11 / 20 14：24 
* @文件描述： 栈链头文件
****************************************************** ************************/  
#pragma once

typedef void* LStack;

//初始化栈
LStack init_LStack();

//入栈
void push_LStack(LStack _stack, void* data);

//出栈
void pop_LStack(LStack _stack);

//返回栈顶
void* top_LStack(LStack _stack);

//返回栈大小
int size_LStack(LStack _stack);

//判断栈是否为空
int isEmpty_LStack(LStack _stack);

//销毁栈
void destroy_LStack(LStack* _stack);
```

##### LinkListStack.c链栈源文件

```c
/***************************************************** ************************* 
* @版权所有（c）2020，Peng，保留所有权利。 
* @文件路径:    C:\USERS\ADMINISTRATOR\DESKTOP\C语言学习案例（内含数据结构）\SEQSTACK\LinklistStack.c 
* @版本：1.0版 
* @作者：Peng 
* @创建时间：2020 / 11 / 20 14：24 
* @文件描述： 栈链源文件
****************************************************** ************************/  
#include "LinklistStack.h"
#include <stdio.h>

typedef struct _LStackNode
{
	struct _LStackNode* next;
}LStackNode;


typedef struct __LStack
{
	LStackNode* pHeader;
	int m_size;
}_LStack;


LStack init_LStack()
{
	_LStack* stack = malloc(sizeof(_LStack));
	if (!stack)
	{
		return;
	}
	stack->pHeader = NULL;
	stack->m_size = 0;
	return stack;
}


void push_LStack(LStack _stack, void* data)
{
	_LStack* stack =_stack;
	LStackNode* pPush = data;
	if (!stack||!pPush)
	{
		return;
	}
	//入栈操作--链表头插
	pPush->next = stack->pHeader;
	stack->pHeader = pPush;
	stack->m_size++;
}

void pop_LStack(LStack _stack)
{
	_LStack* stack = _stack;
	if (!stack)
	{
		return;
	}
	//出栈操作--链表头删
	stack->pHeader = stack->pHeader->next;
	stack->m_size--;
}

void* top_LStack(LStack _stack)
{
	_LStack* stack = _stack;
	if (!stack)
	{
		return;
	}
	return stack->pHeader;
}


int size_LStack(LStack _stack)
{
	_LStack* stack = _stack;
	if (!stack)
	{
		return;
	}
	return stack->m_size;
}

int isEmpty_LStack(LStack _stack)
{
	_LStack* stack = _stack;
	if (!stack)
	{
		return -1;
	}
	if (stack->m_size)
	{
		return 0;
	}
	return 1;


}


void destroy_LStack(LStack* _stack)
{
	_LStack** stack = _stack;
	if (*stack)
	{
		free(*stack);
		*stack = NULL;
	}

}
```

### 队列(Queue)(发音和Q一样)

***队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。***

![img](https://raw.githubusercontent.com/che77a38/blogImage2/main/%E5%9B%BE%E7%89%8731.png)

队头元素：front             队尾元素：back             队列和栈一样不提供遍历功能

#### 队列的顺序存储案例(基于动态数组)

##### **顺序队列的头文件seqQueue.h**

```c
/***************************************************** ************************* 
* @版权所有（c）2020，Peng，保留所有权利。 
* @文件路径:    C:\USERS\ADMINISTRATOR\DESKTOP\C语言学习案例（内含数据结构）\队列案例\QUEUE\seqQueue.h 
* @版本：1.0版 
* @作者：Peng 
* @创建时间：2020 / 11 / 27 12：56 
* @文件描述： 顺序队列的头文件（引用了动态数组文件）
****************************************************** ************************/  
#pragma once

#define  INIT_CAPACITY 1024

typedef void* seqQueue;

//初始化顺序队列
seqQueue init_seqQueue();

//入队
void push_seqQueue(seqQueue queue,void* data);

//出队
void pop_seqQueue(seqQueue queue);

//队头
void* front_seqQueue(seqQueue queue);

//队尾
void* back_seqQueue(seqQueue queue);

//队内项数
int size_seqQueue(seqQueue queue);

//清空队列
void clear_seqQueue(seqQueue queue);

//是否空
int isEmpty_seqQueue(seqQueue queue);

//销毁队列
void destroy_seqQueue(seqQueue* queue);

//调试显示
void debugShow_seqQueue(seqQueue queue, void(*myPrintf)(void*));
```

##### 顺序队列的源文件seqQueue.c

```c
/***************************************************** ************************* 
* @版权所有（c）2020，Peng，保留所有权利。 
* @文件路径:    C:\USERS\ADMINISTRATOR\DESKTOP\C语言学习案例（内含数据结构）\队列案例\QUEUE\seqQueue.c 
* @版本：1.0版 
* @作者：Peng 
* @创建时间：2020 / 11 / 27 12：56 
* @文件描述： 顺序队列的源文件（引用了动态数组文件）
****************************************************** ************************/  
#include "dynamicArray.h"
#include "seqQueue.h"

seqQueue init_seqQueue()
{
	DynamicArray* array = init_DynamicArray(INIT_CAPACITY);
	return array;
}


void push_seqQueue(seqQueue queue, void* data)
{
	if (!queue||!data)
	{
		return;
	}
	DynamicArray* array = queue;
	insert_DynamicArray(queue, array->m_size, data);
}


void pop_seqQueue(seqQueue queue)
{
	if (!queue)
	{
		return;
	}
	DynamicArray* array = queue;
	if (array->m_size<=0)
	{
		return;
	}
	removeByPos_DynamicArray(queue, 0);
}

void* front_seqQueue(seqQueue queue)
{
	if (!queue)
	{
		return NULL;
	}
	DynamicArray* array = queue;
	return array->ArrayAddr[0];
}

void* back_seqQueue(seqQueue queue)
{
	if (!queue)
	{
		return NULL;
	}
	DynamicArray* array = queue;
	return array->ArrayAddr[array->m_size-1];
}


int size_seqQueue(seqQueue queue)
{
	if (!queue)
	{
		return -1;
	}
	DynamicArray* array = queue;
	return array->m_size;
}

void clear_seqQueue(seqQueue queue)
{
	if (!queue)
	{
		return;
	}
	clear_DynamicArray(queue);
}

int isEmpty_seqQueue(seqQueue queue)
{
	if (!queue)
	{
		return -1;
	}
	DynamicArray* array = queue;
	if (array->m_size==0)
	{
		return 1;
	}

	return 0;
}



void destroy_seqQueue(seqQueue* queue)
{
	if (!(*queue))
	{
		return;
	}
	destroy_DynamicArray(queue);
}

void debugShow_seqQueue(seqQueue queue, void(*myShow)(void*))
{
	if (!queue||!myShow)
	{
		return;
	}
	printf("-------------------------------------------------\r\n");
	printf("队头\r\n");
	foreach_DynamicArray(queue, myShow);
	printf("队尾\r\n");
	printf("-------------------------------------------------\r\n");
	
}
```

#### 队列的链式存储案例

##### 链队列的头文件LinkQueue.h

```c
/***************************************************** ************************* 
* @版权所有（c）2020，Peng，保留所有权利。 
* @文件路径:    C:\USERS\ADMINISTRATOR\DESKTOP\C语言学习案例（内含数据结构）\队列案例\QUEUE\LinkQueue.h 
* @版本：1.0版 
* @作者：Peng 
* @创建时间：2020 / 11 / 27 20：40 
* @文件描述：	链表队列头文件
****************************************************** ************************/  
#pragma once

typedef void* linkQueue;

//初始化
linkQueue init_linkQueue();

//入队列
void push_linkQueue(linkQueue _queue,void* data);

//出队列
void pop_linkQueue(linkQueue _queue);

//队头元素
void* front_linkQueue(linkQueue _queue);

//队尾元素
void* back_linkQueue(linkQueue _queue);

//队中项个数
int size_linkQueue(linkQueue _queue);

//是否空
int isEmpty_linkQueue(linkQueue _queue);

//清空队列
void clear_linkQueue(linkQueue _queue);

//销毁队列
void destroy_linkQueue(linkQueue* _queue);
```

##### 链队列的源文件LinkQueue.c

```c
/***************************************************** ************************* 
* @版权所有（c）2020，Peng，保留所有权利。 
* @文件路径:    C:\USERS\ADMINISTRATOR\DESKTOP\C语言学习案例（内含数据结构）\队列案例\QUEUE\LinkQueue.c 
* @版本：1.0版 
* @作者：Peng 
* @创建时间：2020 / 11 / 27 20：40 
* @文件描述： 链表队列源文件
****************************************************** ************************/  
#pragma once
#include "LinkQueue.h"
#include <stdlib.h>

typedef struct _QueueNode
{
	struct  QueueNode* next;
}QueueNode;

typedef struct __LinkQueue
{
	QueueNode* pHeader;//指向头元素
	QueueNode* pTail;//指向尾元素
	int m_size;
}_LinkQueue;


linkQueue init_linkQueue()
{
	_LinkQueue* queue = malloc(sizeof(_LinkQueue));
	if (!queue)
	{
		return NULL;
	}
	queue->m_size = 0;
	queue->pHeader = NULL;
	queue->pTail = NULL;
	return queue;
}

void push_linkQueue(linkQueue _queue, void* data)
{
	_LinkQueue* queue = _queue;
	QueueNode* node = data;
	if (!queue||!data)
	{
		return;
	}
	node->next = NULL;
	if (queue->m_size==0)//初始化
	{
		queue->pTail = node;
		queue->pHeader = node;
	}
	else
	{
		queue->pTail->next = node;
		queue->pTail = node;
	}
	queue->m_size++;
}


void pop_linkQueue(linkQueue _queue)
{
	_LinkQueue* queue = _queue;
	if (!queue)
	{
		return;
	}
	if (queue->m_size<=0)
	{
		return;
	}
	queue->pHeader = queue->pHeader->next;
	queue->m_size--;
	if (queue->m_size == 0)//唯一一个节点被删除的时候，尾节点重新变为空
	{
		queue->pTail = NULL;
	}
}

void* front_linkQueue(linkQueue _queue)
{
	_LinkQueue* queue = _queue;
	if (!queue)
	{
		return;
	}
	return queue->pHeader;
}


void* back_linkQueue(linkQueue _queue)
{
	_LinkQueue* queue = _queue;
	if (!queue)
	{
		return;
	}
	return queue->pTail;
}

int size_linkQueue(linkQueue _queue)
{
	_LinkQueue* queue = _queue;
	if (!queue)
	{
		return -1;
	}
	return queue->m_size;
}

int isEmpty_linkQueue(linkQueue _queue)
{
	_LinkQueue* queue = _queue;
	if (!queue)
	{
		return -1;
	}
	if (queue->m_size==0)
	{
		return 1;
	}
	return 0;
}

void clear_linkQueue(linkQueue _queue)
{
	_LinkQueue* queue = _queue;
	if (!queue)
	{
		return;
	}
	queue->pHeader = NULL;
	queue->pTail = NULL;
	queue->m_size = 0;
}

void destroy_linkQueue(linkQueue* _queue)
{
	_LinkQueue** queue = _queue;
	if (*queue)
	{
		free(*queue);
		*queue = NULL;
	}
}

debugShow_linkQueue(linkQueue _queue, void(*myShow)(void*))
{
	_LinkQueue* queue = _queue;
	if (!queue)
	{
		return;
	}
	printf("-------------------------------------------------\r\n");
	
	printf("队头\r\n");
	QueueNode* pCurrent = queue->pHeader;
	for (int i = 0; i < queue->m_size; i++)
	{
		myShow(pCurrent);
		pCurrent = pCurrent->next;
	}
	printf("队尾\r\n");
	printf("-------------------------------------------------\r\n");
}
```

## **树和二叉树**

**树的定义**：由一个或多个(n≥0)结点组成的有限集合T，有且仅有一个结点称为根（root），当n>1时，其余的结点分为***m(m≥0)个互不相交的有限集合***T1,T2，…，Tm。每个集合本身又是棵树，被称作这个根的子树 。

<img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/%E5%9B%BE%E7%89%8732.png" alt="img" style="zoom:67%;" />

**树的结构特点：**

- 非线性结构，有一个直接前驱，但可能有多个直接后继（1:n）

- 树的定义具有递归性，树中还有树。

- 树可以为空，即节点个数为0。

- 根 ------ 即根结点(没有前驱)

- 叶子 ------ 即终端结点(没有后继)

- 森林 ------ 指m棵不相交的树的集合(例如删除A后的子树个数)

- 有序树 ------ 结点各子树从左至右有序，不能互换（左为第一）

- 无序树 ------ 结点各子树可互换位置。

- 双亲 ------ 即上层的那个结点(直接前驱) parent

- 孩子 ------ 即下层结点的子树 (直接后继) child

- 兄弟 ------ 同一双亲下的同层结点（孩子之间互称兄弟）sibling

- 堂兄弟 ------ 即双亲位于同一层的结点（但并非同一双亲）cousin

- 祖先 ------ 即从根到该结点所经分支的所有结点

- 子孙 ------ 即该结点下层子树中的任一结点

- 结点 ------ 即树的数据元素

- 结点的度 ------ 结点挂接的子树数（有几个直接后继就是几度）

- 结点的层次 ------ 从根到该结点的层数（根结点算第一层）  

- 终端结点 ------ 即度为0的结点，即叶子       

- 分支结点 ------ 除树根以外的结点（也称为内部结点）

- 树的度 ------ 所有结点度中的最大值（Max{各结点的度}）     

- 树的深度(或高度) ------ 指所有结点中最大的层数（Max{各结点的层次}）

  上图中的结点数＝ 13，树的度＝ 3，树的深度＝ 4

### 树的表示法

#### 图形表示法

**事物之间的逻辑关系**可以通过图的形式很直观的表示出来，如下图：

<img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/%E5%9B%BE%E7%89%8733.png" alt="img" style="zoom:50%;" />

#### 广义表表示法

**根作为由子树森林组成的表的名字写在表的左边。**

<img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/%E5%9B%BE%E7%89%8734.png" alt="img" style="zoom: 67%;" />

用广义表表示法表示上图：

```javascript
中国（河北（保定，石家庄），广东（广州，东莞），山东（青岛，济南））
```

#### 左孩子右兄弟表示法

左孩子右兄弟表示法可以将一颗**多叉树**转化为一颗**二叉树**：

<img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/%E5%9B%BE%E7%89%8735.png" alt="img" style="zoom: 67%;" />

左孩子右兄弟表示法节点的结构

<img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/%E5%9B%BE%E7%89%8736.png"/>

节点有两个指针域，其中一个指针指向**子节点**，另一个指针指向其**兄弟节点**。

### **二叉树概念**

#### 二叉树基本概念

**定义：**n（n≥0）个结点的有限集合，由一个根结点以及两棵互不相交的、分别称为左子树和右子树的二叉树组成 。

**逻辑结构：**一对二（1：2） 

**基本特征:**	

- 每个结点最多只有两棵子树（**不存在度大于2的结点**）；
- 左子树和右子树次序不能颠倒（**有序树**）。

 **基本形态:**（最右边表示连根节点都没有的也算树）

![img](https://raw.githubusercontent.com/che77a38/blogImage2/main/%E5%9B%BE%E7%89%8737.png)

**二叉树性质**

- 性质1: 在二叉树的第i层上至多有2i-1个结点（i>0）
- 性质2: 深度为k的二叉树至多有2k-1个结点（k>0）
- 性质3: 对于任何一棵二叉树，若度为2的结点数有n2个，则叶子数（n0）必定为n2＋1 （即n0=n2+1）
- n 性质4: 具有n个结点的完全二叉树的深度必为log<sub>2</sub>n+1(log<sub>2</sub>n取整)***(***如 log2 (15)   点击 15  log  /  2  log =***)***
- 性质5: 对完全二叉树，若从上至下、从左至右编号，则编号为i 的结点，其左孩子编号必为2i，其右孩子编号必为2i＋1；其双亲的编号必为i/2（i＝1 时为根,除外）

使用性质5可以使用完全二叉树实现树的顺序存储。

<img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/%E5%9B%BE%E7%89%8740.png" alt="img" style="zoom:67%;" />

如果不是完全二叉树咋整???

<img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/%E5%9B%BE%E7%89%8741.png" alt="img" style="zoom:67%;" />

***缺点：①浪费空间；②插入、删除不便***

#### 概念解释

###### **满二叉树**

一棵深度为k 且有2k -1个结点的二叉树。

**特点：每层都“充满”了结点**

<img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/%E5%9B%BE%E7%89%8738.png" alt="img" style="zoom:67%;" />

###### **完全二叉树**

除最后一层外，每一层上的[节点](http://baike.baidu.com/view/47398.htm)数均达到最大值；在最后一层上只缺少右边的若干[结点](http://baike.baidu.com/view/549491.htm)。

<img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/%E5%9B%BE%E7%89%8739.png" alt="img" style="zoom:67%;" />

**理解：k-1层与满二叉树完全相同，第k层结点尽力靠左**

#### 二叉树的表示

##### 二叉链表示法

存储结构：

<img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/%E5%9B%BE%E7%89%8742.png" alt="img" style="zoom: 50%;" />

结点数据类型定义：

```c
typedef struct BiTNode
{
	int		data;
	struct BiTNode *lchild, *rchild;
}BiTNode, *BiTree;
```



##### 三叉链表表示法

存储结构：

<img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/%E5%9B%BE%E7%89%8743.png" alt="img" style="zoom:67%;" />

结点数据类型定义：

```c
//三叉链表
typedef struct TriTNode 
{
	int data;
	//左右孩子指针
	struct TriTNode *lchild, *rchild;
	struct TriTNode *parent;
}TriTNode, *TriTree;
```

#### 二叉树的遍历

Ø 遍历定义

指按某条搜索路线***遍访每个结点且不重复***（又称周游）。

Ø 遍历用途

它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。  

Ø 遍历方法

![img](https://raw.githubusercontent.com/che77a38/blogImage2/main/%E5%9B%BE%E7%89%8745.png)

- DLR — 先(根)序遍历，即先根再左再右
- LDR — 中(根)序遍历，即先左再根再右(此遍历方式正是按照顺序排序遍历)
- LRD — 后(根)序遍历，即先左再右再根

***注：“先、中、后”的意思是指访问的结点D是先于子树出现还是后于子树出现。***

***从递归的角度看，这三种算法是完全相同的，或者说这三种遍历算法的访问路径是相同的，只是访问结点的时机不同。***

<img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/%E5%9B%BE%E7%89%8744.png" alt="img" style="zoom: 50%;" />

从虚线的出发点到终点的路径上，每个结点经过3次。

- ***第1次经过时访问＝先序遍历***
- ***第2次经过时访问＝中序遍历***
- ***第3次经过时访问＝后序遍历***

#### BTree.h头文件

```c
/***************************************************** ************************* 
* @版权所有（c）2020，Peng，保留所有权利。 
* @文件路径:    C:\USERS\ADMINISTRATOR\DESKTOP\C语言学习案例（内含数据结构）\二叉树案例\BTREE\BTree.h 
* @版本：1.0版 
* @作者：Peng 
* @创建时间：2020 / 12 / 04 20：46 
* @文件描述： 二叉树头文件
****************************************************** ************************/  
#pragma once

typedef struct _BTreeNode
{
	void* data;
	struct _BTreeNode *lchild, *rchild;
}BTreeNode,*PBTreeNode;

typedef struct __BTree
{
	PBTreeNode root;
	int m_size;
}_BTree,*PBTree;



typedef void* BTree;

typedef void* TreeNode;

//初始化二叉树
BTree init_BinaryTree();

//顺序插入
void insert_BinaryTree(BTree _tree,void* data, int(*myCompare)(void* myInsertData, void* TreeData));



//以下均为递归版对应功能的封装////////////////////////////////////////////
//先序遍历
void firstShow_BinaryTree(BTree _tree, void(*myShow)(void*));

//计算树的叶子节点个数
int calculateLeafNum_BinaryTree(BTree _tree);

//计算树的层数
int GetHeight_BinaryTree(BTree _tree);

//二叉树拷贝
BTree Copy_BinaryTree(BTree _tree);

//释放二叉树
void Release_BinaryTree(BTree* _tree);

//////////////////////////////////////////////////////////////////////////

//递归版先序遍历二叉树
void firstRecursionShow_BinaryTree(TreeNode root, void(*myShow)(void*));

//递归版中序遍历二叉树
void middleRecursionShow_BinaryTree(TreeNode root, void(*myShow)(void*));

//递归版后序遍历二叉树
void lastRecursionShow_BinaryTree(TreeNode root, void(*myShow)(void*));

//递归版计算树的叶子节点个数
void RecursionCalculateLeafNum_BinaryTree(TreeNode root, int* num);

//递归版计算树的层数
int RecursionGetHeight_BinaryTree(TreeNode root);

//递归版二叉树拷贝
TreeNode RecursionCopy_BinaryTree(TreeNode root);

//递归版释放二叉树
void RecursionRelease_BinaryTree(TreeNode* root);
```

#### BTree.c源文件

```c
/***************************************************** ************************* 
* @版权所有（c）2020，Peng，保留所有权利。 
* @文件路径:    C:\USERS\ADMINISTRATOR\DESKTOP\C语言学习案例（内含数据结构）\二叉树案例\BTREE\BTree.c 
* @版本：1.0版 
* @作者：Peng 
* @创建时间：2020 / 12 / 04 20：47 
* @文件描述： 二叉树源文件
****************************************************** ************************/  
#include "BTree.h"
#include <stdio.h>
#include <stdlib.h>

BTree init_BinaryTree()
{
	PBTree tree = malloc(sizeof(_BTree));
	if (!tree)
	{
		return NULL;
	}
	tree->m_size = 0;
	tree->root = NULL;
	return tree;
}

void insert_BinaryTree(BTree _tree,void* data,int(*myCompare)(void* myInsertData,void* TreeData))
{
	if (!_tree ||!data)
	{
		return;
	}
	PBTree tree = _tree;
	if (!tree->root)//空树
	{
		tree->root = malloc(sizeof(BTreeNode));
		if (!tree->root)
		{
			return;
		}
		tree->root->data = data;
		tree->root->lchild = NULL;
		tree->root->rchild = NULL;
		tree->m_size++;
	}
	else
	{
		PBTreeNode Pcurrent = tree->root;
		while (Pcurrent!=NULL)
		{
			if (myCompare(data,Pcurrent->data))//1表示插入左边
			{
				if (Pcurrent->lchild == NULL)//执行插入操作
				{
					Pcurrent->lchild = malloc(sizeof(BTreeNode));//未做成功校验
					Pcurrent->lchild->data = data;
					Pcurrent->lchild->lchild = NULL;
					Pcurrent->lchild->rchild = NULL;
					tree->m_size++;
					return;
				}
				Pcurrent = Pcurrent->lchild;
			}
			else
			{
				if (Pcurrent->rchild == NULL)//执行插入操作
				{
					Pcurrent->rchild = malloc(sizeof(BTreeNode));//未做成功校验
					Pcurrent->rchild->data = data;
					Pcurrent->rchild->lchild = NULL;
					Pcurrent->rchild->rchild = NULL;
					tree->m_size++;
					return;
				}
				Pcurrent = Pcurrent->rchild;
			}
		}
	}
}


void firstShow_BinaryTree(BTree _tree, void(*myShow)(void*))
{
	if (!_tree||!myShow)
	{
		return;
	}
	PBTree tree = _tree;
	firstRecursionShow_BinaryTree(tree->root, myShow);
}

int calculateLeafNum_BinaryTree(BTree _tree)
{
	if (!_tree )
	{
		return 0;
	}
	PBTree tree = _tree;
	int num = 0;
	RecursionCalculateLeafNum_BinaryTree(tree->root, &num);
	return num;
}

int GetHeight_BinaryTree(BTree _tree)
{
	if (!_tree)
	{
		return 0;
	}
	PBTree tree = _tree;
	int result = RecursionGetHeight_BinaryTree(tree->root);
}

BTree Copy_BinaryTree(BTree _tree)
{
	if (!_tree)
	{
		return NULL;
	}
	PBTree tree = _tree;
	PBTree newTree = malloc(sizeof(_BTree));
	if (!newTree)
	{
		return NULL;
	}
	newTree->m_size = tree->m_size;
	newTree->root = RecursionCopy_BinaryTree(tree->root);
	return newTree;
}


void Release_BinaryTree(BTree* _tree)
{
	if (!*_tree)
	{
		return;
	}
	PBTree tree = *_tree;
	if (tree->root)
	{
		RecursionRelease_BinaryTree(&tree->root);
	}
	if (tree)
	{
		free(tree);
		*_tree = NULL;
	}
}


void firstRecursionShow_BinaryTree(TreeNode root,void(*myShow)(void*))
{
	if (!root || !myShow)
	{
		return;
	}
	PBTreeNode tree = root;
	myShow(tree->data);
	firstRecursionShow_BinaryTree(tree->lchild, myShow);
	firstRecursionShow_BinaryTree(tree->rchild, myShow);
}

void middleRecursionShow_BinaryTree(TreeNode root, void(*myShow)(void*))
{
	if (!root || !myShow)
	{
		return;
	}
	PBTreeNode tree = root;
	middleRecursionShow_BinaryTree(tree->lchild, myShow);
	myShow(tree->data);
	middleRecursionShow_BinaryTree(tree->rchild, myShow);
}

void lastRecursionShow_BinaryTree(TreeNode root, void(*myShow)(void*))
{
	if (!root||!myShow)
	{
		return;
	}
	PBTreeNode tree = root;
	lastRecursionShow_BinaryTree(tree->lchild, myShow);
	lastRecursionShow_BinaryTree(tree->rchild, myShow);
	myShow(tree->data);
}


void RecursionCalculateLeafNum_BinaryTree(TreeNode root,int* num)
{
	if (!root||!num)
	{
		return;
	}
	PBTreeNode tree = root;
	if (!tree->lchild&&!tree->rchild)
	{
		(*num)++;
	}
	RecursionCalculateLeafNum_BinaryTree(tree->lchild, num);
	RecursionCalculateLeafNum_BinaryTree(tree->rchild, num);
}


int RecursionGetHeight_BinaryTree(TreeNode root)
{
	if (!root)
	{
		return 0;
	}
	PBTreeNode tree = root;
	int left = RecursionGetHeight_BinaryTree(tree->lchild);
	int right = RecursionGetHeight_BinaryTree(tree->rchild);
	return left > right ? left + 1 : right + 1;

}

TreeNode RecursionCopy_BinaryTree(TreeNode root)
{
	if (!root)
	{
		return NULL;
	}
	PBTreeNode oldTree = root;
	PBTree leftTree= RecursionCopy_BinaryTree(oldTree->lchild);
	PBTree rightTree = RecursionCopy_BinaryTree(oldTree->rchild);
	PBTreeNode newNode = malloc(sizeof(BTreeNode));
	newNode->data = oldTree->data;
	newNode->lchild = leftTree;
	newNode->rchild = rightTree;
	return newNode;
}

void RecursionRelease_BinaryTree(TreeNode* root)
{
	if (!(*root))
	{
		return;
	}
	PBTreeNode tree = *root;
	RecursionRelease_BinaryTree(&tree->lchild);
	RecursionRelease_BinaryTree(&tree->rchild);
	//最后释放根节点
	free(*root);
	*root = NULL;
}
```











