---
title: C语言入门
date: 2020-12-23 22:51:13
tags: C语言
categories: 技术
---

c语言入门学习

<!-- more -->

# C语言基础

## C语言特点

作用

1. 所有大学理工科必修课
2. 名企，外企，高薪程序员面试必考
3. 写外挂，做黑客必须掌握的语言
4. 学习数据结构和C++的基石
5. 绝对重要的基石语言，Unix，Linux，Windows，JAVA，C++，C#底层实现都靠C

<!-- more -->

![image-20200909140723886](https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200909140723886.png)



### 1）优点

1. 代码量效
2. 执行速度快
3. 功能强大
4. 编程自由

### 2）缺点

1. 写代码实现周期长
2. 可移植性较差
3. 过于自由，经验不足易出错
4. 对于平台依赖较多

中央处理器（CPU）的主要模块

1. 运算器
2. 控制器
3. 寄存器

内存----（内）存储器

外部设备

1. 输入设备
2. 输出设备
3. 外存----（外）存储器

C语言关键字

C语言仅有32个关键字，9种控制语句，34种运算符

## 32个关键字

```
auto，break，case，char，const，continue，default，do，double，else，enum，extern，float，for，goto，if，int，long，register，return，short，signed，sizeof，static，struct，switch，typedef，unsigned，union，void，volatile,while
```

## 9种控制语句

```
if()else{}
for(){}
while(){}
do{}while()
continue
break
switch
goto
return
```

## 34种运算符

```
算术运算符:  +  -  *  /  %  ++  --  
关系运算符： <  <=  ==  >  >=  !=
逻辑运算符： !  &&  ||  
位运算符：  <<  >>  ~  |  ^  &  
赋值运算符：  =及其拓展
条件运算符：  ?=
逗号运算符：  ,
指针运算符：  *  &
求字节数：  sizeof
强制类型转换:  (类型)
分量运算符：  .  ->
下标运算符： []
其他： ()
```

算数运算符：先 * / % 后 + -

运算符优先级：

	[]() > ++ -- (后缀高于前缀) (强转) sizeof > 算数运算（先乘除取余，后加减）> 
	
	比较运算 > 逻辑运算 > 三目运算（条件运算）> 赋值运算 > 逗号运算

 解决控制台一闪而过：

1. 在return 0之前添加system（“pause”）
2. 在项目上--》右键--》属性--》配置属性--》链接器--》系统--》子系统--》在下拉框中选择“控制台”（/SUBSYSTEM:CONSOLE）

导入头文件（）

> 使用C语言库函数需要提前包含库函数对应的头文件

```
#：关键标识符，表示引入头文件
include:引入头文件关键字
stdio.h:系统标准输入输出库对应的头文件
<>：表示系统直接按系统指定的目录检索
"":表示系统先在 "" 指定的路径(没写路径代表当前路径)查找头文件，如果找不到，再按系统指定的目录检索
```

## gcc编译器

我们用编辑器编写程序，由编译器编译后才可以运行！

> gcc（GNU Compiler Collection，GNU 编译器套件），是由 GNU 开发的编程语言编译器。gcc原本作为GNU操作系统的官方编译器，现已被大多数类Unix操作系统（如Linux、BSD、Mac OS X等）采纳为标准的编译器，gcc同样适用于微软的Windows。

gcc最初用于编译C语言，随着项目的发展gcc已经成为了能够编译C、C++、Java、Ada、fortran、Object C、Object C++、Go语言的编译器大家族。

格式：

```
gcc [-option1] ... <filename>
g++ [-option1] ... <filename>
```

- 命令、选项和源文件之间使用空格分隔
- 一行命令中可以有零个、一个或多个选项
- 文件名可以包含文件的绝对路径，也可以使用相对路径
- 如果命令中不包含输出可执行文件的文件名，可执行文件的文件名会自动生成一个默认名，Linux平台为a.out，Windows平台为a.exe

gcc、g++编译常用选项

```
-o file	指定生成的输出文件名为file
-E	只进行预处理
-S(大写)	只进行预处理和编译
-c(小写)	只进行预处理、编译和汇编
```

## Windows平台下gcc环境配置

> windows命令行界面下，默认是没有gcc编译器，我们需要配置一下环境。由于我们安装了Qt，Qt是一个集成开发环境，内部集成gcc编译器，配置一下环境变量即可使用gcc。

## C语言编译过程

C代码编译成可执行程序经过4步：

1. 预处理：宏定义展开、头文件展开、条件编译等，同时将代码中的注释删除，这里并不会检查语法
2. 编译：检查语法，将预处理后文件编译生成汇编文件
3. 汇编：将汇编文件生成目标文件(二进制文件)
4. 链接：C语言写的程序是需要依赖各种库的，所以编译之后还需要把库链接到最终的可执行程序中去

```
gcc编译4步骤：【重点】
	1. 预处理	-E	xxx.i	预处理文件
		gcc -E xxx.c -o xxx.i
		1) 头文件展开。 --- 不检查语法错误。 可以展开任意文件。
		2）宏定义替换。 --- 将宏名替换为宏值。
		3）替换注释。	--- 变成空行
		4）展开条件编译 --- 根据条件来展开指令。
		...
	2. 编译		-S	xxx.s	汇编文件
		gcc -S hello.i -o hello.s
		1）逐行检查语法错误。【重点】	--- 整个编译4步骤中最耗时的过程。
		2）将C程序翻译成 汇编指令，得到.s 汇编文件。
	3. 汇编		-c	xxx.o	目标文件
		gcc -c hello.s -o hello.o
		1）翻译：将汇编指令翻译成对应的 二进制编码。
	4. 链接		无	xxx.exe	可执行文件。
		gcc  hello.o -o hello.exe
		1）数据段合并
		2）数据地址回填
		3）库引入
```

 ![img](https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8714.png)

```
预处理：gcc -E hello.c -o hello.i
编  译：gcc -S hello.i -o hello.s
汇  编：gcc -c hello.s -o hello.o
链  接：gcc    hello.o -o hello
```

| **选项** | **含义**                    |
| -------- | --------------------------- |
| -E       | 只进行预处理                |
| -S(大写) | 只进行预处理和编译          |
| -c(小写) | 只进行预处理、编译和汇编    |
| -o file  | 指定生成的输出文件名为 file |

| **文件后缀** | **含义**              |
| ------------ | --------------------- |
| .c           | C 语言文件            |
| .i           | 预处理后的 C 语言文件 |
| .s           | 编译后的汇编文件      |
| .o           | 编译后的目标文件      |

记忆方式：iso     ESC

### 预处理

#### ***文件包含处理***

![img](https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8721.png)

***#incude<>和#include******""******区别***

- "" 表示系统先在file1.c所在的当前目录找file1.h，如果找不到，再按系统指定的目录检索。
- < > 表示系统直接按系统指定的目录检索。

#### 宏定义

##### 无参数的宏定义(宏常量)

```c
#define num 100
```

*说明*：

1) 宏名一般用大写，以便于与变量区别；

2) 宏定义可以是常数、表达式等；

3) 宏定义不作语法检查，只有在编译被宏展开后的源程序才会报错；

4) 宏定义不在行末加分号；

5) 宏名有效范围为从定义到本源文件结束；

6) 可以用#undef命令终止宏定义的作用域；

7) 在宏定义中，可以引用已定义的宏名；

##### 带参数的宏定义(宏函数)

```c
//仅仅只是做文本替换,由于宏函数没有普通函数参数压栈、跳转、返回等的开销，可以调高程序的效率。
#define SUM(x,y) (( x )+( y ))
```

*注意:*

1) 宏的名字中不能有空格，但是在替换的字符串中可以有空格。ANSI C允许在参数列表中使用空格；

2) 用括号括住每一个参数，并括住宏的整体定义。

3) 用大写字母表示宏的函数名。

4) 如果打算宏代替函数来加快程序运行速度。假如在程序中只使用一次宏对程序的运行时间没有太大提高。

#### 条件编译

![img](https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8722.png)

```c
//防止头文件被重复包含引用
#ifndef _SOMEFILE_H
#define _SOMEFILE_H

//需要声明的变量、函数
//宏定义
//结构体

#endif
```

#### *一些特殊的预定宏*

C编译器，提供了几个特殊形式的预定义宏，在实际编程中可以直接使用，很方便。

```c
//	__FILE__			宏所在文件的源文件名 
//	__LINE__			宏所在行的行号
//	__DATE__			代码编译的日期
//	__TIME__			代码编译的时间

void test()
{
	printf("%s\n", __FILE__);
	printf("%d\n", __LINE__);
	printf("%s\n", __DATE__);
	printf("%s\n", __TIME__);
}
```



## system函数

- 功能：在已经运行的程序中执行另外一个外部程序
- 参数：外部可执行程序名字
- 返回值：成功：0        失败：任意数字
- 参数如：pause，cmd，calc，mspaint，notepad，cls。。。。。。

注释

- 单行注释：//（注意是斜杠，\叫反斜杠，要区分开）
- 多行注释：/*   */

## CPU 内部结构与寄存器

CPU对外是通过总线（地址，控制，数据）来和外部设备交互的，总线的宽度是8位，同时cpu的寄存器也是8位的，那么这个cpu就叫8位cpu

存储器按与CPU远近来分：

寄存器 --- 缓存  ---（CPU缓存） --- 内存 --- 外存

为什么要有缓存呢？

因为如果经常操作内存中的同一个地址的数据，就会影响速度，因此在内存和寄存器中设置一个缓存

## IDE用法（VS+QT）

IDE 集成开发环境，QT就是一个轻量级的集成开发环境，vs也是IDE

QT常用快捷键

| ***快捷键*** | ***含义***                 |
| ------------ | -------------------------- |
| Ctrl + i     | 自动格式化代码             |
| Ctrl + /     | 注释/取消注释              |
| Alt + Enter  | 自动完成类函数定义         |
| F4           | .h 文件和对应.cpp 文件切换 |
| F9           | 设置断点                   |
| F5           | 调试运行                   |
| Ctrl + r     | 编译，但不调试运行         |
| Ctrl + b     | 编译，不运行               |
| F10          | next调试(单步步过)         |
| F11          | step调试(单步步入)         |

VS的快捷键

| ***快捷键***      | ***含义***     |
| :---------------- | -------------- |
| Alt+Shift         | 多光标选择     |
| Ctrl + k,Ctrl + f | 自动格式化代码 |
| Ctrl + k,Ctrl + c | 注释代码       |
| Ctrl + k,Ctrl + u | 取消注释代码   |
| F9                | 设置断点       |
| F5                | 调试运行       |
| Ctrl + F5         | 不调试运行     |
| Ctrl + Shift + b  | 编译，不运行   |
| F10               | next调试       |
| F11               | step调试       |

VS的代码快捷导入

新建文件后缀为xxx.snippet

VS --》 工具--》 代码片段管理器 --》 Visual C++

###  VS2013的C4996错误

由于微软在VS2013中不建议再使用C的传统库函数scanf,strcpy,sprintf等，所以直接使用这些库函数会提示C4996错误：

VS建议采用带_s的函数，如scanf_s、strcpy_s，但这些并不是标准C函数。

要想继续使用scanf,strcpy,sprintf等，需要在源文件中添加以下指令就可以避免这个错误提示：

```c
#define _CRT_SECURE_NO_WARNINGS  //这个宏定义最好要放到.c文件的第一行

#pragma warning(disable:4996)	//或者使用这个
```

**vs注意点**：另一个文件中的函数，未声明直接用会默认当成**int 函数名()**这样的函数处理

##  数据类型

![img](https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8713.png)

既能读又能写的内存对象，称为**变量**；

若一旦初始化后不能修改的对象则称为**常量**。

### 变量特点：

1. 变量在编译时为其分配相应的内存空间
2. 可以通过其名字和地址访问相应内存

 声明和定义区别：

1. 不需要建立存储空间，如：extern;
2. 定义变量需要建立存储空间，如：int b;

- int b 它既是声明，同时又是定义
- 对于 extern  int a来讲它只是声明不是定义

> 一般的情况下，把建立存储空间的声明称之为“定义”，而把不需要建立存储空间的声明称之为“声明”。

变量标识符命名规则：

- 标识符不能是关键字
- 标识符只能由字母、数字、下划线组成
- 第一个字符必须为字母或下划线
- 标识符中字母区分大小写

### 整形:int

整型变量的定义和输出

| ***\*打印格式\**** | ***\*含义\****                      |
| ------------------ | ----------------------------------- |
| %d                 | 输出一个有符号的10进制int类型       |
| %o(字母o)          | 输出8进制的int类型                  |
| %x                 | 输出16进制的int类型，字母以小写输出 |
| %X                 | 输出16进制的int类型，字母以大写输出 |
| %u                 | 输出一个10进制的无符号数            |

### short、int、long、long long

| ***\*数据类型\****  | ***\*占用空间\****                              |
| ------------------- | ----------------------------------------------- |
| short(短整型)       | 2字节                                           |
| int(整型)           | 4字节                                           |
| long(长整形)        | Windows为4字节，Linux为4字节(32位)，8字节(64位) |
| long long(长长整形) | 8字节                                           |

注意点：

> 需要注意的是，整型数据在内存中占的字节数与所选择的操作系统有关。虽然 C 语言标准中没有明确规定整型数据的长度，但 long 类型整数的长度不能短于 int 类型， short 类型整数的长度不能长于 int 类型。

> l当一个小的数据类型赋值给一个大的数据类型，不会出错，因为编译器会自动转化。但当一个大的类型赋值给一个小的数据类型，那么就可能丢失高位。

| ***整型常量*** | ***所需类型***             |
| -------------- | -------------------------- |
| 10             | 代表int类型                |
| 10l, 10L       | 代表long类型               |
| 10ll, 10LL     | 代表long long类型          |
| 10u, 10U       | 代表unsigned int类型       |
| 10ul, 10UL     | 代表unsigned long类型      |
| 10ull, 10ULL   | 代表unsigned long long类型 |

| ***打印格式*** | ***含义***                 |
| -------------- | -------------------------- |
| %hd            | 输出short类型              |
| %d             | 输出int类型                |
| %ld            | 输出long类型               |
| %lld           | 输出long long类型          |
| %hu            | 输出unsigned short类型     |
| %u             | 输出unsigned int类型       |
| %lu            | 输出unsigned long类型      |
| %llu           | 输出unsigned long long类型 |

### 有符号数和无符号数区别

有无符号位

| ***数据类型*** | ***占用空间*** | ***取值范围***                           |
| -------------- | -------------- | ---------------------------------------- |
| short          | 2字节          | -32768 到 32767 (-215 ~ 215-1)           |
| int            | 4字节          | -2147483648 到 2147483647 (-231 ~ 231-1) |
| long           | 4字节          | -2147483648 到 2147483647 (-231 ~ 231-1) |
| unsigned short | 2字节          | 0 到 65535 (0 ~ 216-1)                   |
| unsigned int   | 4字节          | 0 到 4294967295 (0 ~ 232-1)              |
| unsigned long  | 4字节          | 0 到 4294967295 (0 ~ 232-1)              |

比如说内存中的32个1二进制存储的整形读取可能是-1，也可能是2147483647 ，看你以什么格式读取

#### 有符号数和无符号的数值溢出的区别

符号位溢出会导致数的正负发生改变，但无符号最高位的溢出会导致最高位丢失。

注意了，补码的补码还是其本身

### 类型转换

#### 隐式类型转换：

由编译器自动完成。

由赋值产生的类型转换。 小--》大 没问题。 大 --》 小 有可能发生数据丢失。

#### 强制类型转换：

语法：	（目标类型）带转换变量

​				（目标类型）带转换表达式

大多数用于函数调用期间，实参给形参传值。

### sizeof关键字

- **sizeof不是函数，而是操作符**，所以不需要包含任何头文件，它的功能是计算一个数据类型的大小，单位为字节
- sizeof的返回值为size_t
- size_t类型在32位操作系统下是unsigned int，是一个无符号的整数

sizeof后跟变量名或类型名的区别：

- 如果后跟的是变量名的话，sizeof d或sizeof(d)都成立
- 但后跟的是类型名的话，sizeof必须加括号，即sizeof(double)

### 字符型：char

> 字符型变量用于存储一个单一字符，在 C 语言中用 char 表示，其中每个字符变量都会占用 1 个字节。在给字符型变量赋值时，需要用一对英文半角格式的单引号(' ')把字符括起来。

字符变量实际上并不是把该字符本身放到变量的内存单元中去，而是将该字符对应的 ASCII 编码放到变量的存储单元中。char的本质就是一个1字节大小的整型。

#### ASCII对照表

| ***ASCII值*** | ***控制字符*** | ***ASCII值*** | ***字符*** | ***ASCII值*** | ***字符*** | ***ASCII值*** | ***字符*** |
| ------------- | -------------- | ------------- | ---------- | ------------- | ---------- | ------------- | ---------- |
| 0             | NUT            | 32            | (space)    | 64            | @          | 96            | 、         |
| 1             | SOH            | 33            | !          | 65            | A          | 97            | a          |
| 2             | STX            | 34            | "          | 66            | B          | 98            | b          |
| 3             | ETX            | 35            | #          | 67            | C          | 99            | c          |
| 4             | EOT            | 36            | $          | 68            | D          | 100           | d          |
| 5             | ENQ            | 37            | %          | 69            | E          | 101           | e          |
| 6             | ACK            | 38            | &          | 70            | F          | 102           | f          |
| 7             | BEL            | 39            | ,          | 71            | G          | 103           | g          |
| 8             | BS             | 40            | (          | 72            | H          | 104           | h          |
| 9             | HT             | 41            | )          | 73            | I          | 105           | i          |
| 10            | LF             | 42            | *          | 74            | J          | 106           | j          |
| 11            | VT             | 43            | +          | 75            | K          | 107           | k          |
| 12            | FF             | 44            | ,          | 76            | L          | 108           | l          |
| 13            | CR             | 45            | -          | 77            | M          | 109           | m          |
| 14            | SO             | 46            | .          | 78            | N          | 110           | n          |
| 15            | SI             | 47            | /          | 79            | O          | 111           | o          |
| 16            | DLE            | 48            | 0          | 80            | P          | 112           | p          |
| 17            | DCI            | 49            | 1          | 81            | Q          | 113           | q          |
| 18            | DC2            | 50            | 2          | 82            | R          | 114           | r          |
| 19            | DC3            | 51            | 3          | 83            | S          | 115           | s          |
| 20            | DC4            | 52            | 4          | 84            | T          | 116           | t          |
| 21            | NAK            | 53            | 5          | 85            | U          | 117           | u          |
| 22            | SYN            | 54            | 6          | 86            | V          | 118           | v          |
| 23            | TB             | 55            | 7          | 87            | W          | 119           | w          |
| 24            | CAN            | 56            | 8          | 88            | X          | 120           | x          |
| 25            | EM             | 57            | 9          | 89            | Y          | 121           | y          |
| 26            | SUB            | 58            | :          | 90            | Z          | 122           | z          |
| 27            | ESC            | 59            | ;          | 91            | [          | 123           | {          |
| 28            | FS             | 60            | <          | 92            | /          | 124           | \|         |
| 29            | GS             | 61            | =          | 93            | ]          | 125           | }          |
| 30            | RS             | 62            | >          | 94            | ^          | 126           | `          |
| 31            | US             | 63            | ?          | 95            | _          | 127           | DEL        |

ASCII 码大致由以下两部分组成：

1. ASCII 非打印控制字符： ASCII 表上的数字 0-31 分配给了控制字符，用于控制像打印机等一些外围设备。
2. ASCII 打印字符：数字 32-126 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。数字 127 代表 Del 命令。

| ***转义字符*** | ***含义***                          | ***ASCII码值（十进制）*** |
| -------------- | ----------------------------------- | ------------------------- |
| \a             | 警报                                | 007                       |
| \b             | 退格(BS) ，将当前位置移到前一列     | 008                       |
| \f             | 换页(FF)，将当前位置移到下页开头    | 012                       |
| \n             | 换行(LF) ，将当前位置移到下一行开头 | 010                       |
| \r             | 回车(CR) ，将当前位置移到本行开头   | 013                       |
| \t             | 水平制表(HT) （跳到下一个TAB位置）  | 009                       |
| \v             | 垂直制表(VT)                        | 011                       |
| \\             | 代表一个反斜线字符"\"               | 092                       |
| \'             | 代表一个单引号（撇号）字符          | 039                       |
| \"             | 代表一个双引号字符                  | 034                       |
| \?             | 代表一个问号                        | 063                       |
| \0             | 数字0                               | 000                       |
| \ddd           | 8进制转义字符，d范围0~7             | 3位8进制                  |
| \xhh           | 16进制转义字符，h范围0~9，a~f，A~F  | 3位16进制                 |

### 实型(浮点型)：float、double

单精度浮点数(float)、 双精度浮点数(double)， 但是double型变量所表示的浮点数比 float 型变量更精确。

> 由于浮点型变量是由有限的存储单元组成的，因此只能提供有限的有效数字。在有效位以外的数字将被舍去，这样可能会产生一些误差。因此做浮点数的判断是否相等时候最好用两浮点数之差和某个很小的精度小数坐标，具体看你要什么精度，比如0.000001

不以f结尾的常量是double类型，以f结尾的常量(如3.14f)是float类型。

### 进制

> 当前的计算机系统使用的基本上是二进制系统，数据在计算机中主要是以补码的形式存储的。

2进制与十进制转换图

![img](https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8711.png)![img](https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8712.png)

#### C语言如何表示相应进制数

| 十进制   | 以正常数字1-9开头，如123  |
| -------- | ------------------------- |
| 八进制   | 以数字0开头，如0123       |
| 十六进制 | 以0x开头，如0x123         |
| 二进制   | C语言不能直接书写二进制数 |

***在计算机系统中，数值一律用补码来存储***

## 类型限定符

| ***限定符***                                                 | ***含义***                                                   |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| extern                                                       | 声明一个变量，extern声明的变量没有建立存储空间。extern int a;//变量在定义的时候创建存储空间 |
| const                                                        | 定义一个常量，常量的值不能修改。const int a = 10;            |
| [Volatile](https://blog.csdn.net/weixin_44363885/article/details/92838607) | 防止编译器优化代码                                           |
| register                                                     | 定义寄存器变量，提高效率。register是建议型的指令，而不是命令型的指令，如果CPU有空闲寄存器，那么register就生效，如果没有空闲寄存器，那么register无效。 |

### Volatile详解

> volatile的本意是“易变的”,volatile关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。

**volatile表示不想被意想不到的改变，const表示程序不应该试图去修改它**

```c
volatile int i=10;
int a = i;
//其他代码，并未明确告诉编译器，对i进行过操作
int b = i;
```

volatile 指出 i是随时可能发生变化的，每次使用它的时候必须从i的地址中读取，因而编译器生成的汇编代码会重新从i的地址读取数据放在b中。而优化做法是，由于编译器发现两次从i读数据的代码之间的代码没有对i进行过操作，它会自动把上次读的数据放在b中。而不是重新从i里面读。这样以来，如果i是一个寄存器变量或者表示一个端口数据就容易出错，所以说volatile可以保证对特殊地址的稳定访问。

注意，在vc6中，一般调试模式没有进行代码优化，所以这个关键字的作用看不出来。下面通过插入汇编代码，测试有无volatile关键字，对程序最终代码的影响。首先用classwizard建一个win32 console工程，插入一个voltest.cpp文件，输入下面的代码：

```c
#include <stdio.h>
void main()
{
int i=10;
int a = i;
printf("i= %d\n",a);
//下面汇编语句的作用就是改变内存中i的值，但是又不让编译器知道
__asm {
 mov dword ptr [ebp-4], 20h
}
int b = i;
printf("i= %d\n",b);
}
/*然后，在调试版本模式运行程序，输出结果如下：
i = 10
i = 32
然后，在release版本模式运行程序，输出结果如下：
i = 10
i = 10
输出的结果明显表明，release模式下，编译器对代码进行了优化，第二次没有输出正确的i值。下面，我们把 i的声明加上volatile关键字，看看有什么变化：*/
#include <stdio.h>
void main()
{
volatile int i=10;
int a = i;
printf("i= %d\n",a);
__asm {
 mov dword ptr [ebp-4], 20h//这个在VS2015中debug版本不一定设置的ebp-4。
}
int b = i;
printf("i= %d\n",b);
}
/*分别在调试版本和release版本运行程序，输出都是：
i = 10
i = 32
这说明这个关键字发挥了它的作用！*/
```

下面是volatile变量的几个例子：

1. 并行设备的硬件寄存器（如：状态寄存器）
2. 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)
3. 多线程应用中被几个任务共享的变量

这是区分C程序员和嵌入式系统程序员的最基本的问题。嵌入式系统程序员经常同硬件、中断、RTOS等等打交道，所用这些都要求volatile变量。不懂得volatile内容将会带来灾难。

## 字符串常量

![img](https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%876.png)

每个字符串的结尾，编译器会自动的添加一个结束标志位'\0'，即 "a" 包含两个字符'a'和’\0’。

## printf函数和putchar函数

printf是输出一个字符串，putchar输出一个char。、

### printf格式字符：

| ***\*打印格式\**** | ***\*对应数据类型\**** | ***\*含义\****                                               |
| ------------------ | ---------------------- | ------------------------------------------------------------ |
| %d                 | int                    | 接受整数值并将它表示为有符号的十进制整数                     |
| %hd                | short int              | 短整数                                                       |
| %hu                | unsigned short         | 无符号短整数                                                 |
| %o                 | unsigned int           | 无符号8进制整数                                              |
| %u                 | unsigned int           | 无符号10进制整数                                             |
| %x,%X              | unsigned int           | 无符号16进制整数，x对应的是abcdef，X对应的是ABCDEF           |
| %f                 | float                  | 单精度浮点数                                                 |
| %lf                | double                 | 双精度浮点数                                                 |
| %e,%E              | double                 | 科学计数法表示的数，此处"e"的大小写代表在输出时用的"e"的大小写 |
| %c                 | char                   | 字符型。可以把输入的数字按照ASCII码相应转换为对应的字符      |
| %s                 | char *                 | 字符串。输出字符串中的字符直至字符串中的空字符（字符串以'\0‘结尾，这个'\0'即空字符） |
| %p                 | void *                 | 以16进制形式输出指针                                         |
| %%                 | %                      | 输出一个百分号                                               |

printf附加格式：

| ***\*字符\****    | ***\*含义\****                                               |
| ----------------- | ------------------------------------------------------------ |
| l(字母l)          | 附加在d,u,x,o前面，表示长整数                                |
| -                 | 左对齐                                                       |
| m(代表一个整数)   | 数据最小宽度                                                 |
| 0(数字0)          | 将输出的前面补上0直到占满指定列宽为止不可以搭配使用-         |
| m.n(代表一个整数) | m指域宽，即对应的输出项在输出设备上所占的字符数。n指精度，用于说明输出的实型数的小数位数。对数值型的来说，未指定n时，隐含的精度为n=6位。 |

![image-20200922183129000](https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200922183129000.png)

## scanf函数与getchar函数

- getchar是从标准输入设备读取一个char。
- scanf通过%转义的方式可以得到用户通过标准输入设备输入的数据。
- 借助“正则表达式”, scanf获取带有空格的字符串：scanf("%[^\n]", str);

### scanf格式字符：

| ***格式*** | ***作用***                                                   |
| ---------- | ------------------------------------------------------------ |
| %\*s或%\*d | 跳过数据(遇到空格或\t代表结束忽略)                           |
| %[width]s  | 读指定宽度的数据，此处[]括号并不需要真写                     |
| %[a-z]     | 匹配a到z中任意字符(尽可能多的匹配)（只要有一个字符匹配失败，就不继续匹配了） |
| %[aBc]     | 匹配a、B、c中一员，贪婪性                                    |
| %\[^a]     | 匹配非a的任意字符，贪婪性                                    |
| %\[^a-z]   | 表示读取除a-z以外的所有字符                                  |

p.s.上面所有都是可以加星表示跳过的，并且都可以指定读指定宽度的数据

## 字符串的输入输出

fgets：从stdin获取一个字符串， 预留 \0 的存储空间。空间足够读 \n, 空间不足舍弃 \n  【安全】

### 用户输入：

| 函数  | 终止条件                           | 用户输入时候是否包含结尾的“\n” |
| ----- | ---------------------------------- | ------------------------------ |
| scanf | 遇到空格或换行符                   | 否                             |
| gets  | 遇到换行符                         | 否                             |
| fgets | 遇到换行符或读到***size***-1个字符 | 是                             |

### 输出显示：

| 函数   | 输出内容后是否多输出一个“\n” | 输出内容结尾的‘0’是否输出 |
| ------ | ---------------------------- | ------------------------- |
| printf | 否                           | 是                        |
| puts   | 是                           | 是                        |
| fputs  | 否                           | 否                        |

由于fgets安全，因此正经编写代码的时候用fgets

### strlen()	

计算指定指定字符串s的长度，不包含字符串结束符‘\0’

## 函数的声明

> 如果使用用户自己定义的函数，而该函数与调用它的函数（即主调函数）不在同一文件中，或者函数定义的位置在主调函数之后，则必须在调用此函数之前对被调用的函数作声明。

**所谓函数声明**，就是在函数尚在未定义的情况下，事先将该函数的有关信息通知编译系统，相当于告诉编译器，函数在后面定义，以便使编译能正常进行。

***注意***：一个函数只能被定义一次，但可以声明多次。

> p.s.在一个文件中（比如a.c）定义一个全局变量int a = 10;然后在另一个代码文件（比如main.c）中需要使用变量a，可以写int a;单独看main.c文件时就会出现二义性，一个含义是当其他文件中没有定义过全局变量a，则这里定义一个变量a。另一个含义是当其他文件中包含声明全局变量a，则这里声明一个变量a。所以当a.c中定义了全局变量a时，在main.c中最好使用：extern int a;

## main函数与exit函数

在main函数中调用exit和return结果是一样的，但在子函数中调用return只是代表子函数终止了，在子函数中调用exit，那么程序终止。



## 随机数：

1. 播种随机数种子： srand(time(NULL));
2. 引入头文件 #include <stdlib.h>  <time.h>
3. 生成随机数： rand() % 100;

## exit函数： 

	#include <stdlib.h>
	return关键字：
	
		返回当前函数调用，将返回值返回给调用者。
	
	exit()函数：
	
		退出当前程序。

## 头文件的意义（重点）

```c
//文件名 First.c
main()
{
printStr();
}


printStr()
{ 
     printf(“Hello world!”);
}
```

如上图，编译报错，这里涉及到一个顶层作用域的问题：

**顶层作用域**就是从声明点延伸到源程序文本结束

因此在没有声明的前提下，main必须放在最后面。然后如果遇到两函数互相嵌套的情况，就会发生，谁放前面都没用的情况，因此在一切都还没开始之前进行顶层声明就是最通用的解决方式了。我们将这些顶层声明拿出来单独管理，组织成一个所谓的**头文件**。

**因此test1.h头文件的目的是为了使test2可以通过test1.h快速建立对test2的函数声明，以此使用test2的函数**

------

### 声明和定义的表示区别：

#### 变量的声明和定义：

```C
int a；//需要建立存储空间      既是定义，也是声明
extern int a；//不需要建立存储空间     只是声明，不是定义
//如果声明有初始化，就被当作定义，即使前面有extern，例如：
extern int a = 5;   //定义
```

#### 函数的声明和定义：

带有{ }的都是定义，否则就是声明。

------

C语言的存储类说明符有以下几个:



| 说明符 | 用  法                                                       |
| ------ | ------------------------------------------------------------ |
| Auto   | 只在块内变量声明中被允许, 表示变量具有本地生存期.            |
| Extern | 出现在顶层或块的外部变量函数与变量声明中，表示声明的对象具有静态生存期, 连接程序知道其名字. |
| Static | 可以放在函数与变量声明中,在函数定义时,只用于指定函数名,而不将函数导出到链接程序,在函数声明中,表示其后边会有定义声明的函数,存储类型static.在数据声明中,总是表示定义的声明不导出到连接程序. |

1. **说明符auto**表明一个变量具有自动存储时期.该说明符只能用在具有代码块作用域的变量声明中,而这样的变量已经拥有自动存储时期,因此它主要是用来明确指明意图,使程序更易读.
2. **说明符register**也只能用于具有代码块作用域的变量.它将一根变量归入寄存器存储类,这相当于请求将该变量存储在一个寄存器内,以更快的存取.它的使用也使你不能获得该变量的地址.
3. **说明符static**在用于具有代码块作用域的变量的声明时,使该变量具有静态存储时期,从而得以在程序运行期间(即使在包含该变量的代码块并没有运行时)存在并保留其值.变量仍具有代码块作用域和空链接.static用于具有文件作用域的变量的声明时,表明该变量具有内部链接.(静态函数只能在声明他的文件中可见，其他文件不能引用该函数，不同的文件可以使用相同名字的静态函数，互不影响)
4. **说明符extern**表明你在声明一个已经在别处定义了的变量.如果包含extern的声明具有代码块作用域,所指向的变量可能具有外部链接也可能具有内部链接,这取决于该变量的定义声明

由上面可知，extern修饰的变量可以供其他文件使用。

但为什么头文件中的函数大多不需要extern，因为**C语言中有默认的存储类标志符. C99中规定, 所有顶层的默认存储类标志符都是extern**

**但为了区分是否别的文件定义，因此有了人为规范：**在.h文件中声明的函数,如果在其对应的.c文件中有定义,那么我们在声明这个函数时,不使用extern修饰符, 如果反之,则必须显示使用extern修饰符.

注意：并不能用数组来声明指针，反之亦然。（很明显呀。。。）

**注意：**在同一个工程的不同的需要包含a.h的文件当中,你只能定义AAA一次,否则在连接这些目标文件时会出现
重复定义的错误,即使你的单独目标文件编译没有任何的问题.因此：在头文件中使用宏定义实现对整个头文件的防止重复包含就很重要**（防止重复包含的目的是为了解决整个项目中同一个东西定义超过一次报错的问题）**

------

最后给出一点点大型编程时候全局变量使用需要注意的问题,这也仅仅是个建议,或者说一种编程习惯 

1) 所有全局变量全部以g_开头,并且尽可能声明成static类型. 
2) 尽量杜绝跨文件访问全局变量.如果的确需要在多个文件内访问同一变量,应该由该变量定义所在文件内提供GET/PUT函数实现. 
3) 全局变量必须要有一个初始值,全局变量尽量放在一个专门的函数内初始化. 
4) 如调用的函数少于三个,请考虑改为局部变量实现.

## 多文件(分文件)编程

- **把函数声明放在头文件xxx.h中，在主函数中包含相应头文件**
- **在头文件对应的xxx.c中实现xxx.h声明的函数**

###  防止头文件重复包含

头文件重复包含错误

当一个项目比较大时，往往都是分文件，这时候有可能不小心把同一个头文件 include 多次，或者头文件嵌套包含。

![img](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml6660\wps6.jpg)

为了避免同一个文件被include多次，C/C++中有两种方式，一种是 #ifndef 方式

```
#ifndef __SOMEFILE_H__
#define __SOMEFILE_H__

// 声明语句

#endif
```

一种是 #pragma once 方式。

```
#pragma once

// 声明语句
```

头文件放

1. #include头文件
2. 函数声明
3. 类型定义
4. 宏定义

源文件中只要加一个#include自己同名头文件。

对于函数来说，默认为extern。

不需要额外在声明时加extern，加不加是等价的。

## 内存

- 存储器：计算机的组成中，用来存储程序和数据，辅助CPU进行运算处理的重要部分。
- 内存：内部存贮器，暂存程序/数据——掉电丢失 SRAM、DRAM、DDR、DDR2、DDR3。
- 外存：外部存储器，长时间保存程序/数据—掉电不丢ROM、ERRROM、FLASH（NAND、NOR）、硬盘、光盘。

只读存储器（ROM）

`里面的内容是厂家生产时预先录制(烧制/烧写)好的信息，如BIOS信息，断电后数据不消失，可多次读取。`

随机存储器（RAM）

`断电后数据消失`

### 有关内存的两个概念：物理存储器和存储地址空间

物理存储器：实际存在的具体存储器芯片。

- 主板上装插的内存条
- 显示卡上的显示RAM芯片
- 各种适配卡上的RAM芯片和ROM芯片

 

存储地址空间：对存储器编码的范围。我们在软件上常说的内存是指这一层含义。

- 编码：对每个物理存储单元（一个字节）分配一个号码
- 寻址：可以根据分配的号码找到相应的存储单元，完成数据的读写

## 指针注意点：

指针定义注意：

```c
char* p,p2;//这里p才是char指针类型，p2只是char类型
char* p,*p2;//这样才是两者均为指针
```

一级指针传参：

```c
int c = 3;
void hello(int* i)
{
	i = &c;
}
void main()
{
    int b = 5;
	int* a = &b;
	hello(a);
	printf("%d", *a);
}
//输出结果为5，因为该参数传递是值传递，不对本身指针造成影响
```

改成地址传递应该如下：(二级指针传参)

```c
int c = 3;

void hello(int** i)
{
	*i = &c;
}
void main()
{
    int b = 5;
	int* a = &b;
	hello(&a);
	printf("%d", *a);
}
//输出结果为3,函数成功对指针进行修改
```

**用n级指针形参，去间接修改了n-1级指针(实参)的值。**

指针的步长体现在：

- +1之后跳跃的字节数
- 解引用 解出的字节数

> **结构体中算偏移量的函数**
>
> 通过 offsetof( 结构体名称， 属性)  找到属性对应的偏移量
>
> offsetof 引入头文件 #include<stddef.h>

```c
//实际定义如下：
typedef unsigned int size_t
#define offsetof(s,m) (size_t)&(((*s)0)->m)
```

指针做函数参数，具备输入和输出特性：

- 输入：主调函数分配内存
- 输出：被调用函数分配内存

### 指针改变后的释放出错

```c
void test(){
	char *p = (char *)malloc(50);
	char buf[] = "abcdef";
	int n = strlen(buf);
	int i = 0;

	for (i = 0; i < n; i++)
	{
		*p = buf[i];
		p++; //修改原指针指向
	}

	free(p);//此处出错，因为此时的p已经不是指向原来位置的指针了
}
```

出错显示：

![image-20200925162410473](https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200925162410473.png)

## 野指针,空指针,哑指针，垂悬指针

> 指针变量也是变量，是变量就可以任意赋值，不要越界即可（32位为4字节，64位为8字节），但是，任意数值赋值给指针变量没有意义，因为这样的指针就成了野指针，此指针指向的区域是未知(操作系统不允许操作此指针指向的内存区域)。所以，野指针不会直接引发错误，操作野指针指向的内存区域才会出问题。

指针操作应该记住：1. 初始化时置NULL    2. 释放时置NULL

### 空指针

- 不能向NULL或者非法内存拷贝数据

往空指针里塞东西：报错如下：

![image-20200921222715218](https://raw.githubusercontent.com/che77a38/blogImage/main/image-20200921222715218.png)

往野指针里塞东西也是报上图错误，仅红线部分不为0地址而已

### 野指针

导致野指针的三种情况

- 指针变量未初始化

任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。

- 指针释放后未置空

有时指针在free或delete后未赋值 NULL，便会使人以为是合法的。别看free和delete的名字（尤其是delete），它们只是告诉系统 ，指针指向的内存可以回收了，以此把指针所指的内存给释放掉，但并没有把指针本身干掉。此时指针指向的就是“垃圾”内存。释放后的指针应立即将指针置为NULL，防止产生“野指针”。

**空指针可以重复释放、野指针不可以重复释放**

- 指针操作超越变量作用域

不要返回指向栈内存的指针或引用，因为栈内存在函数结束时会被释放。

```c
int* doWork()
{
	int a=10;
	int*p=&a;
	return p;
}


void main()
{
	int *p=doWork();
	printf("%d\n",*p);//输出10，成功输出但实际上已经指向不合法的空间
	printf("%d\n",*p);//输出乱七八糟的数据，因为10已经被覆盖了
}
//会产生无法预测的值（第一次往往能正确输出）
```

****

```C++
//但是，野指针和有效指针变量保存的都是数值，为了标志此指针变量没有指向任何变量(空闲可用)，C语言中，可以把NULL赋值给此指针，这样就标志此指针为空指针，没有任何指针
int *p = NULL;
```

NULL是一个值为0的宏常量：

```c++
#define NULL    ((void *)0)
```

p.s.  int* p;-----windows      int *p; ---------Linux

### 哑指针和垂悬指针

**垂悬指针**：指向曾经存在的对象，但该对象已经不再存在了

**哑指针**：除了指向，没有其他任何动作的指针

## 二级指针的输入输出特性

### 二级指针的输出特性

```c
//被调函数,由参数n确定分配多少个元素内存
void allocate_space(int **arr,int n){
	//堆上分配n个int类型元素内存
	int *temp = (int *)malloc(sizeof(int)* n);
	if (NULL == temp){
		return;
	}
	//给内存初始化值
	int *pTemp = temp;
	for (int i = 0; i < n;i ++){
		//temp[i] = i + 100;
		*pTemp = i + 100;
		pTemp++;
	}
	//指针间接赋值
	*arr = temp;
}
//打印数组
void print_array(int *arr,int n){
	for (int i = 0; i < n;i ++){
		printf("%d ",arr[i]);
	}
	printf("\n");
}
//二级指针输出特性(由被调函数分配内存)
void test(){
	int *arr = NULL;
	int n = 10;
	//给arr指针间接赋值
	allocate_space(&arr,n);
	//输出arr指向数组的内存
	print_array(arr, n);
	//释放arr所指向内存空间的值
	if (arr != NULL){
		free(arr);
		arr = NULL;
	}
}
```

### 二级指针的输入特性

```c
//打印数组
void print_array(int **arr,int n){
	for (int i = 0; i < n;i ++){
		printf("%d ",*(arr[i]));
	}
	printf("\n");
}
//二级指针输入特性(由主调函数分配内存)
void test(){
	
	int a1 = 10;
	int a2 = 20;
	int a3 = 30;
	int a4 = 40;
	int a5 = 50;

	int n = 5;

	int** arr = (int **)malloc(sizeof(int *) * n);
	arr[0] = &a1;
	arr[1] = &a2;
	arr[2] = &a3;
	arr[3] = &a4;
	arr[4] = &a5;

	print_array(arr,n);

	free(arr);
	arr = NULL;
}
```



## 万能指针void *

void *指针可以指向任意变量的内存空间

**void* 常用于数据类型的封装**

## const关键字

### 修饰变量：

```c
const int a = 20;//依然可以通过指针修改a的值
int *p = &a;
*p = 650;
printf("%d\n", a);
```

### 修饰指针：

- const int *p;（指向常量的指针）

  - 可以修改p
  - 不可以修改*p

- int const *p;（指向常量的指针）

  同上。

- int * const p;（常量指针）

  - 可以修改*p
  - 不可以修改p

- const int *const p;

  - 不可以修改*p
  - 不可以修改p

**总结**：***const 向右修饰，被修饰的部分即为只读。***

常用：在函数形参内，用来限制指针所对应的内存空间为只读。

- 全局变量

直接修改 失败 ，间接修改 语法通过，运行失败，受到常量区保护

- 局部变量

直接修改 失败 ， 间接修改  成功，放在栈上

**主要作用**：修饰形参防止误操作

结构体作为参数时，往往会用指针传值，但用指针会有副作用，可能会不小心修改原数据，因此const诞生

p.s.定义const变量最好初始化,因为定义后无法赋值

注意：C中的const依然是**变量**，而C++中const修饰的东西，实际上是**常量**

## 位运算

### 用法（n未知项）

```c
//打开位
00000100 | n//打开第二位  
//打开所有位
n | ~n
//关闭所有位
n & ~n
```

### ***左移 <<***

左移一位相当于原值*2.

### ***右移 >>***

> 对于有符号类型，结果依赖于机器。空出的位可能用0填充，或者使用符号(最左端)位的副本填充。

**移位运算符能够提供快捷、高效（依赖于硬件）对2的幂的乘法和除法。**

| number << n     | number乘以2的n次幂                         |
| --------------- | ------------------------------------------ |
| **number >> n** | **如果number非负，则用number除以2的n次幂** |

## 数组名

> 在C中，在几乎所有数组名的表达式中，数组名的值是一个***指针常量***，也就是数组第一个元素的地址。它的类型取决于数组元素的类型：如果他们是int类型，那么数组名的类型就是“指向int的常量指针”；如果它们是其他类型，那么数组名的类型也就是“指向***其他类型***的常量指针”。

数组名字是数组的首元素地址，但它是一个**地址常量**，不可以做任何和赋值有关的操作

- sizeof（数组）=数组的实际字节数
- sizeof（指针）=4/8

p.s.要注意数组名和指针变量的区别。通常情况下，我们总觉得数组名和指针变量差不多，但是在用sizeof的时候差别很大，对数组名用sizeof返回的是整个数组的大小，而对指针变量进行操作的时候返回的则是指针变量本身所占得空间，在32位机的条件下一般都是4。**而且当数组名作为函数参数时，在函数内部，形参也就是个指针，所以不再返回数组的大小；**

数组做函数函数参数，将**退化为指针**,在函数内部不再返回数组大小

### ***数组和指针的区别***

**但实际上，数组名和指针并不是等价的**

答案是***否定***的。**数组名在表达式中使用的时候，编译器才会产生一个指针常量**。那么数组在什么情况下不能作为指针常量呢？在以下两种场景下：

当数组名作为sizeof操作符的操作数的时候，此时sizeof返回的是整个数组的长度，而不是指针数组指针的长度。n 当数组名作为&操作符的操作数的时候，此时返回的是一个指向数组的指针，而不是指向某个数组元素的指针常量。

```c
int arr[10];
//arr = NULL; //arr作为指针常量，不可修改
int *p = arr; //此时arr作为指针常量来使用
printf("sizeof(arr):%d\n", sizeof(arr)); //此时sizeof结果为整个数组的长度
printf("&arr type is %s\n", typeid(&arr).name()); //int(*)[10]而不是int*
```

声明一个数组时，编译器根据声明所指定的元素数量为数组分配内存空间，然后再创建数组名，指向这段空间的起始位置。声明一个指针变量的时候，编译器只为指针本身分配内存空间，并不为任何整型值分配内存空间，指针并未初始化指向任何现有的内存空间。

因此，表达式\*a是完全合法的，但是表达式\*b却是非法的。*b将访问内存中一个不确定的位置，将会导致程序终止。另一方面b++可以通过编译，a++却不行，因为a是一个常量值。

**除了两种特殊情况外，都是指向数组第一个元素的指针**

- 特殊情况1  sizeof 统计数组长度
- 特殊情况2  对数组名取地址，数组指针，步长整个数组长度

### ***作为函数参数的数组名***

```C
int print_array(int *arr);
int print_array(int arr[]);
```

我们可以使用任何一种声明，但哪一个更准确一些呢？答案是**指针**。因为实参实际上是个指针，而不是数组。同样sizeof arr值是指针的长度，而不是数组的长度。

​	现在我们清楚了，为什么一维数组中无须写明它的元素数目了，因为形参只是一个指针，并不需要为数组参数分配内存。另一方面，这种方式使得函数无法知道数组的长度。如果函数需要知道数组的长度，它必须显式传递一个长度参数给函数。

### 数组下标可为负值

```c
int arr[] = { 5, 3, 6, 8, 2, 9 };
int *p = arr + 2;
printf("*p = %d\n", *p);//6
printf("*p = %d\n", p[-1]);//3
```

### 二维数组名

####  二维数组的3种形式参数

```c
void PrintArray01(int arr[3][3])
void PrintArray02(int arr[][3])
void PrintArray03(int(*arr)[3])
```

### 多维数组名间的区别

```c
int a[5]={0};
int b[5][5]={0};
int c[5][5][5]={0};
//a的类型为int*            &a的类型为int(*)[5]
//b的类型为int(*)[5]       &b的类型为int(*)[5][5]
//c的类型为int(*)[5][5]    &b的类型为int(*)[5][5][5]
```



## 数组指针

数组的类型由***元素类型***和***数组大小***共同决定：int array[5]  的类型为  int[5]；

定义数组指针有一下三种方式：

1. 先定义数组类型，再用数组类型定义数组指针

```c
void test01(){

	//先定义数组类型，再用数组类型定义数组指针
	int arr[10] = {1,2,3,4,5,6,7,8,9,10};
	//有typedef是定义类型，没有则是定义变量,下面代码定义了一个数组类型ArrayType
	typedef int(ArrayType)[10];
	//int ArrayType[10]; //定义一个数组，数组名为ArrayType

	ArrayType myarr; //等价于 int myarr[10];
	ArrayType* pArr = &arr; //定义了一个数组指针pArr，并且指针指向数组arr
	for (int i = 0; i < 10;i++){
		printf("%d ",(*pArr)[i]);
	}
	printf("\n");
}
```

2. 直接定义数组指针类型

```c
void test02(){

	int arr[10];
	//定义数组指针类型
	typedef int(*ArrayType)[10];
	ArrayType pArr = &arr; //定义了一个数组指针pArr，并且指针指向数组arr
	for (int i = 0; i < 10; i++){
		(*pArr)[i] = i + 1;
	}
	for (int i = 0; i < 10; i++){
		printf("%d ", (*pArr)[i]);
	}
	printf("\n");

}
```

3. 直接定义数组指针类型的变量

```c
void test03(){
	
	int arr[10];
	int(*pArr)[10] = &arr;

	for (int i = 0; i < 10; i++){
		(*pArr)[i] = i + 1;

	}
	for (int i = 0; i < 10; i++){
		printf("%d ", (*pArr)[i]);
	}
	printf("\n");
}
```



## 字符串注意点：

- vs 将多个相同字符串常量看成一个
- 不可以修改字符串常量
- ANSI并没有制定出字符串是否可以修改的标准，根据编译器不同，可能最终结果也是不同的

## 指针加减运算

- 指针计算不是简单的整数相加减
- 如果是一个int *，+1的结果是增加一个int的大小
- 如果是一个char *，+1的结果是增加一个char大小

## 多级指针 

```C++
	int a = 10;
	int *p = &a; //一级指针
	*p = 100; //*p就是a

	int **q = &p;
	//*q就是p
	//**q就是a

	int ***t = &q;
	//*t就是q
	//**t就是p
	//***t就是a
```

## 指针数组做为main函数的形参

```C++
int main(int argc, char *argv[]);
```

- main函数是操作系统调用的，第一个参数标明argc数组的成员数量，argv数组的每个成员都是char *类型
- argv是命令行参数的字符串数组
- argc代表命令行参数的数量，程序名字本身算一个参数

在VS中。项目名称上 --》右键--》属性--》调试--》命令行参数 --》将 命令行写入。

##  数组做函数返回值

C语言，不允许！！！只能写成指针形式(指针做返回值时候注意不要返回局部变量地址)

## 字符串格式化注意点

```c
    //字符数组只能初始化5个字符，当输出的时候，从开始位置直到找到0结束
	char str1[] = { 'h', 'e', 'l', 'l', 'o' };
	printf("%s\n",str1);

	//字符数组部分初始化，剩余填0
	char str2[100] = { 'h', 'e', 'l', 'l', 'o' };
	printf("%s\n", str2);

	//请问下面输入结果是多少？sizeof结果是多少？strlen结果是多少？
	char str5[] = "hello\0world"; 
	printf("%s\n",str5);
	printf("sizeof str5:%d\n",sizeof(str5));//12
	printf("strlen str5:%d\n",strlen(str5));//5

	//再请问下面输入结果是多少？sizeof结果是多少？strlen结果是多少？
	char str6[] = "hello\012world";
	printf("%s\n", str6);
	printf("sizeof str6:%d\n", sizeof(str6));//12
	printf("strlen str6:%d\n", strlen(str6));//11
```

### 八进制和十六进制转义字符： 

   在C中有两种特殊的字符，八进制转义字符和十六进制转义字符，八进制字符的一般形式是'\ddd'，d是0-7的数字。十六进制字符的一般形式是'\xhh'，h是0-9或A-F内的一个。八进制字符和十六进制字符表示的是字符的ASCII码对应的数值。

比如 ： 

- '\063'表示的是字符'3'，因为'3'的ASCII码是30（十六进制），48（十进制），63（八进制）。
- '\x41'表示的是字符'A'，因为'A'的ASCII码是41（十六进制），65（十进制），101（八进制）。

## 字符串

```c
char str1[] = {'h', 'i', '\0'};			 //变量，可读可写

char str2[] = "hi";						//变量，可读可写

char *str3 = "hi";						//常量，只读
//str3中存的是常量地址
```



## 字符串处理函数 #include <string.h> 

### strcpy()

把src所指向的字符串复制到dest所指向的空间中，'\0'也会拷贝过去

```c++
char *strcpy(char *dest, const char *src);
//参数： dest：目的字符串首地址   src：源字符首地址
//返回值： 成功：返回dest字符串的首地址  失败：NULL
```

### strncpy()

功能：把src指向字符串的前n个字符复制到dest所指向的空间中，是否拷贝结束符看指定的长度是否包含'\0'。

```c++
char *strncpy(char *dest, const char *src, size_t n);
```

### strcat()

功能：将src字符串连接到dest的尾部，‘\0’也会追加过去

### strncat()

功能：将src字符串前n个字符连接到dest的尾部，‘\0’也会追加过去

### strcmp()

功能：比较 s1 和 s2 的大小，比较的是字符ASCII码大小。

###  strncmp()

只比较 s1 和 s2 前n个字符的大小，比较的是字符ASCII码大小。

### strchr()

```c
#include <string.h>
char *strchr(const char *s, int c);
//功能：在字符串s中查找字母c出现的位置
//参数：
//	s：字符串首地址
//	c：匹配字母(字符)c
//返回值：
//	成功：返回第一次出现的c地址
//	失败：NULL
```



### strstr()

```c
#include <string.h>
char *strstr(const char *haystack, const char *needle);
//功能：在字符串haystack中查找字符串needle出现的位置
//参数：
//	haystack：源字符串首地址
//	needle：匹配字符串首地址
//返回值：
//	成功：返回第一次出现的needle地址
//	失败：NULL
```



### strtok()

功能：来将字符串分割成一个个片段。当strtok()在参数s的字符串中发现参数delim中包含的分割字符时, 则会将该字符改为\0 字符，当连续出现多个时只替换第一个为\0。

```c++
char *strtok(char *str, const char *delim);
//参数：str：指向欲分割的字符串  delim：分隔符字符（如果传入字符串，则传入的字符串中每个字符均为分割符）
//返回值：成功：分割后字符串首地址  失败：NULL
```

- 在第一次调用时：strtok()必需给予参数s字符串

- 往后的调用则将参数s设置成NULL，每次调用成功则返回指向被分割出片段的指针

  > strtok函数会破坏被分解字符串的完整，调用前和调用后的s已经不一样了。如果要保持原字符串的完整，可以使用strchr和sscanf的组合等。

**???待理解点**： strtok是一个线程不安全的函数，因为它使用了静态分配的空间来存储被分割的字符串位置,[线程安全](https://baike.baidu.com/item/线程安全)的函数叫strtok_r,ca



## 字符串处理函数 \#include <stdio.h>

### sprintf()

功能：根据参数format字符串来转换并格式化数据，然后将结果输出到str指定的空间中，直到出现字符串结束符 '\0' 为止。

```C++
int sprintf(char *str, const char *format, ...);
//参数：str：字符串首地址    format：字符串格式，用法和printf()一样
//返回值：成功：实际格式化的字符个数    失败： - 1
```

### sscanf()

功能：从str指定的字符串读取数据，并根据参数format字符串来转换并格式化数据。

```C++
int sscanf(const char *str, const char *format, ...);
//参数：str：指定的字符串首地址   format：字符串格式，用法和scanf()一样
//返回值：成功：参数数目，成功转换的值的个数    失败： - 1
```

| ***格式*** | ***作用***                                                   |
| ---------- | ------------------------------------------------------------ |
| %\*s或%\*d | 跳过数据(遇到空格或\t代表结束忽略)                           |
| %[width]s  | 读指定宽度的数据，此处[]括号并不需要真写                     |
| %[a-z]     | 匹配a到z中任意字符(尽可能多的匹配)（只要有一个字符匹配失败，就不继续匹配了） |
| %[aBc]     | 匹配a、B、c中一员，贪婪性                                    |
| %\[^a]     | 匹配非a的任意字符，贪婪性                                    |
| %\[^a-z]   | 表示读取除a-z以外的所有字符                                  |

p.s.上面所有都是可以加星表示跳过的，并且都可以指定读指定宽度的数据

例子：

```c
//例子1
char *ip="127.0.0.1";
int num1=0,num2=0,num3=0,num4=0;
sscanf(ip,"%d.%d.%d.%d",&num1,&num2,&num3,&num4);
//例子2
char *str="abcdef#helloworld@123456";//提取字符串#和@间的数据
char buf[1024]={0};
sscanf(str,"%*[^#]#%[^@]",buf);
//例子3
char *str="helloworld@itcast.cn";//提取helloworld和itcast.cn
char buf1[1024]={0};
char buf2[1024]={0};
sscanf(str,"%[^@]@%s",buf1，buf2);
```



## 字符串处理函数 #include <stdlib.h>

### atoi()

功能：把一个整形形式的字符串转化为一个整数。atoi()会扫描nptr字符串，跳过前面的空格字符，直到遇到数字或正负号才开始做转换，而遇到非数字或字符串结束符('\0')才结束转换，并将结果返回返回值。

```c++
int atoi(const char *nptr);
//参数：nptr：待转换的字符串  返回值：成功转换后整数
```

类似的函数还有以下

### atof()

功能：把一个小数形式的字符串转化为一个浮点数。

### atol()

功能：将一个字符串转化为long类型

>  atof()   将字符串转换为双精度浮点型值
>  atoi()   将字符串转换为整型值
>  atol()   将字符串转换为长整型值
>  strtod()  将字符串转换为双精度浮点型值，并报告不能被转换的所有剩余数字
>  strtol()  将字符串转换为memset***\*(\****buf***\*,\**** 0***\*,\**** 1024***\*);\****
>
>  ​	sprintf***\*(\****buf***\*,\**** "%-8d"***\*,\**** num***\*);\****
>
>  ​	printf***\*(\****"buf:%s\n"***\*,\**** buf***\*);\****长整值，并报告不能被转换的所有剩余数字
>  strtoul() 将字符串转换为无符号长整型值，并报告不能被转换的所有剩余数字

**自己实现字符串拷贝：**

```c
void copy_string03(char* dest, char* source){
	//判断*dest是否为0，0则退出循环
	while (*dest++ = *source++){}
}
```

## 内存管理

### 作用域

C语言变量的作用域分为：

- 代码块作用域(代码块是{}之间的一段代码)
- 函数作用域
- 文件作用域

### 局部变量

> 局部变量也叫auto自动变量(auto可写可不写)，一般情况下代码块{}内部定义的变量都是自动变量

它有如下特点：

- 在一个函数内定义，只在函数范围内有效
- 在复合语句中定义，只在复合语句中有效
- 随着函数调用的结束或复合语句的结束局部变量的声明声明周期也结束
- 如果没有赋初值，内容为随机

- [x] **同一源文件中,允许全局变量和局部变量同名，在局部变量的作用域内，全局变量不起作用。**

### 静态(static)局部变量

- static局部变量的作用域也是在定义的函数内有效
- static局部变量的生命周期和程序运行周期一样，同时staitc局部变量的值只初始化一次，但可以赋值多次
- static局部变量若未赋以初值，则由系统自动赋值：数值型变量自动赋初值0，字符型变量赋空字符

### 全局变量

- 在函数外定义，可被本文件及其它文件中的函数所共用，若其它文件中的函数调用此变量,须用extern声明
- 全局变量的生命周期和程序运行周期一样
- 不同文件的全局变量不可重名

### 静态(static)全局变量

- 在函数外定义,作用范围被限制在所定义的文件中
- 不同文件静态全局变量可以重名,但作用域不冲突
- static全局变量的生命周期和程序运行周期一样，同时staitc全局变量的值只初始化一次

静态全局变量和普通全局变量的区别，说明：

> 全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。
> 全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。
> 这两者的区别在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。

### extern全局变量声明

> extern int a;声明一个变量，这个全局变量在别的文件中已经定义了，这里只是声明，而不是定义。

###  全局函数和静态函数

> 在C语言中函数默认都是全局的，使用关键字static可以将函数声明为静态，函数定义为static就意味着这个函数只能在定义这个函数的文件中使用，在其他文件中不能调用，即使在其他文件中声明这个函数都没用。

对于不同文件中的staitc函数名字可以相同。

p.s.所有的函数默认都是全局的，意味着所有的函数都不能重名，但如果是staitc函数，那么作用域是文件级的，所以不同的文件static函数名是可以相同的。

### 总结

| ***类型***     | ***作用域*** | ***生命周期*** |      |
| -------------- | ------------ | -------------- | ---- |
| auto变量       | 一对{}内     | 当前函数       |      |
| static局部变量 | 一对{}内     | 整个程序运行期 |      |
| extern变量     | 整个程序     | 整个程序运行期 |      |
| static全局变量 | 当前文件     | 整个程序运行期 |      |
| extern函数     | 整个程序     | 整个程序运行期 |      |
| static函数     | 当前文件     | 整个程序运行期 |      |
| register变量   | 一对{}内     | 当前函数       |      |
| 全局变量       | 整个程序     | 整个程序运行期 |      |

## 内存布局

#### 内存分区

##### 可执行文件结构

C代码经过预处理、编译、汇编、链接4步后生成一个可执行程序。

在 Windows 下，程序是一个普通的可执行文件，以下列出一个二进制可执行文件的基本情况：

![img](https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%872.png)

> 通过上图可以得知，在没有运行程序前，也就是说程序没有加载到内存前，可执行程序内部已经分好3段信息，分别为代码区（text）、数据区（data）和未初始化数据区（bss）3 个部分（**有些人直接把data和bss合起来叫做静态区或全局区**）。

###### **代码区**（text segment）

存放 CPU 执行的机器指令。通常代码区是可共享的（即另外的执行程序可以调用它），使其可共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。代码区通常是只读的，使其只读的原因是防止程序意外地修改了它的指令。另外，代码区还规划了局部变量的相关信息。

###### **全局初始化数据区/静态数据区（data段）**

该区包含了在程序中明确被初始化的全局变量、已经初始化的静态变量（包括全局静态变量和局部静态变量）和常量数据（如字符串常量）。

###### **未初始化数据区（又叫 bss 区）**

存入的是全局未初始化变量和未初始化静态变量。未初始化数据区的数据在程序开始执行之前被内核初始化为 0 或者空（NULL）。

程序在加载到内存前，代码区和全局区(data和bss)的大小就是固定的，程序运行期间不能改变。然后，运行可执行程序，系统把程序加载到内存，除了根据可执行程序的信息分出代码区（text）、数据区（data）和未初始化数据区（bss）之外，还额外增加了栈区、堆区。

![img](https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%871.png)

![img](https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%874.png)

- .text 　　代码段
- .rodata  存储字符串常量
- .data　　存储已初始化的全局/静态变量
- .bss 　　 存储为初始化/初始化为0的全局/静态变量(在可执行文件中只占一个占位符，程序加载的时候才分配空间)

##### 进程内存结构

###### **代码区（text segment）**(翻译：文本部分)

加载的是可执行文件代码段，所有的可执行代码都加载到代码区，这块内存是不可以在运行期间修改的。

###### **未初始化数据区（BSS）**

加载的是可执行文件BSS段，位置可以分开亦可以紧靠数据段，存储于数据段的数据（全局未初始化，静态未初始化数据）的生存周期为整个程序运行过程。

###### **全局初始化数据区/静态数据区（data segment）**

加载的是可执行文件数据段，存储于数据段（全局初始化，静态初始化数据，文字常量(只读)）的数据的生存周期为整个程序运行过程。

全局静态区内的变量在编译阶段已经**分配好内存空间并初始化**。这块内存在程序运行期间一直存在,它主要存储***全局变量***、***静态变量***和***常量***。

示例代码：

```c
int v1 = 10;//全局/静态区
const int v2 = 20; //常量，一旦初始化，不可修改
static int v3 = 20; //全局/静态区
char *p1; //全局/静态区，编译器默认初始化为NULL

//那么全局static int 和 全局int变量有什么区别？

void test(){
	static int v4 = 20; //全局/静态区
}
```

###### **栈区（stack）**

栈是一种先进后出的内存结构，由编译器自动分配释放，存放函数的参数值、返回值、局部变量等。在程序运行过程中实时加载和释放，因此，局部变量的生存周期为申请到释放该段栈空间。

![img](https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%873.png)

![img](https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%875.png)

如图为：内存生长方向(小端模式)

***函数的调用方和被调用方对于函数是如何调用的必须有一个明确的约定，只有双方都遵循同样的约定，函数才能够被正确的调用，这样的约定被称为*****调用惯例(*Calling Convention)”

调用惯例包含如下几点：

- ***函数参数的传递顺序和方式***
- ***栈的维护方式***

***注意: _cdecl不是标准的关键字，在不同的编译器里可能有不同的写法，例如gcc里就不存在_cdecl这样的关键字，而是使用__attribute__((cdecl)).***

| 调用惯例 | 出栈方     | 参数传递                                       | 名字修饰                   |
| -------- | ---------- | ---------------------------------------------- | -------------------------- |
| cdecl    | 函数调用方 | 从右至左参数入栈                               | 下划线+函数名              |
| stdcall  | 函数本身   | 从右至左参数入栈                               | 下划线+函数名+@+参数字节数 |
| fastcall | 函数本身   | 前两个参数由寄存器传递，其余参数通过堆栈传递。 | @+函数名+@+参数的字节数    |
| pascal   | 函数本身   | 从左至右参数入栈                               | 较为复杂，参见相关文档     |



****

###### 堆区（heap）

堆是一个大容器，它的容量要远远大于栈，但没有栈那样先进后出的顺序。用于动态内存分配。堆在内存中位于BSS区和栈区之间。一般由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。

##### 注意:

全局静态存储区内的常量分为常变量和字符串常量，一经初始化，不可修改。静态存储内的常变量是全局变量，与局部常变量不同，区别在于局部常变量存放于栈，实际可间接通过指针或者引用进行修改，而全局常变量存放于静态常量区则不可以间接修改。

***数据区包括***：堆，栈，全局/静态存储区。
***全局/静态存储区包括***：常量区，全局区、静态区。
***常量区包括***：字符串常量区、常变量区。
***代码区***：存放程序编译后的二进制代码，不可寻址区。

***可以说，C/C++内存分区其实只有两个，即代码区和数据区。***



##### 存储类型总结

| ***类型***     | ***作用域*** | ***生命周期*** | ***存储位置***                  |
| -------------- | ------------ | -------------- | ------------------------------- |
| auto变量       | 一对{}内     | 当前函数       | 栈区                            |
| static局部变量 | 一对{}内     | 整个程序运行期 | 初始化在data段，未初始化在BSS段 |
| extern变量     | 整个程序     | 整个程序运行期 | 初始化在data段，未初始化在BSS段 |
| static全局变量 | 当前文件     | 整个程序运行期 | 初始化在data段，未初始化在BSS段 |
| extern函数     | 整个程序     | 整个程序运行期 | 代码区                          |
| static函数     | 当前文件     | 整个程序运行期 | 代码区                          |
| register变量   | 一对{}内     | 当前函数       | 运行时存储在CPU寄存器           |
| 字符串常量     | 当前文件     | 整个程序运行期 | data段                          |

![1568374636_120805](https://raw.githubusercontent.com/che77a38/blogImage/main/1568374636_120805.jpg)

## 内存操作函数

### \#include <string.h>

#### memset()

```c++
void *memset(void *s, int c, size_t n);
//功能：将s的内存区域的前n个字节以参数c填入
//参数：
//	s：需要操作内存s的首地址
//	c：填充的字符，c虽然参数为int，但必须是unsigned char , 范围为0~255
//	n：指定需要设置的大小
//返回值：s的首地址
```

#### memcpy()

```C++
void *memcpy(void *dest, const void *src, size_t n);
//功能：拷贝src所指的内存内容的前n个字节到dest所值的内存地址上。
//参数：
//	dest：目的内存首地址
//	src：源内存首地址，注意：dest和src所指的内存空间不可重叠，可能会导致程序报错
//	n：需要拷贝的字节数
//返回值：dest的首地址
```

### memmove()

> memmove()功能用法和memcpy()一样，区别在于：dest和src所指的内存空间重叠时，memmove()仍然能处理，不过执行效率比memcpy()低些。

#### memcmp()

```C++
int memcmp(const void *s1, const void *s2, size_t n);
//功能：比较s1和s2所指向内存区域的前n个字节
//参数：
//	s1：内存首地址1
//	s2：内存首地址2
//	n：需比较的前n个字节
//返回值：
//	相等：=0
//	大于：>0
//	小于：<0
```

### 堆区内存分配和释放\#include <stdlib.h>

#### malloc() 

```c++
void *malloc(size_t size);
//功能：在内存的动态存储区(堆区)中分配一块长度为size字节的连续区域，用来存放类型说明符指定的类型。分配的内存空间内容不确定，一般使用memset初始化。
//参数：
//	size：需要分配内存大小(单位：字节)
//返回值：
//成功：分配空间的起始地址
//失败：NULL
```

#### free()

```C++
void free(void *ptr);
//功能：释放ptr所指向的一块内存空间，ptr是一个任意类型的指针变量，指向被释放区域的首地址。对同一内存空间多次释放会出错。
//参数：
//ptr：需要释放空间的首地址，被释放区应是由malloc函数所分配的区域。
//返回值：无
```

#### calloc（）

```c
void *calloc(size_t nmemb, size_t size);
//功能：
//在内存动态存储区中分配nmemb块长度为size字节的连续区域。calloc自动将分配的内存	置0。
//参数：
//nmemb：所需内存单元数量
//size：每个内存单元的大小（单位：字节）
//返回值：
//	成功：分配空间的起始地址
//失败：NULL
```

#### realloc()

```C
void *realloc(void *ptr, size_t size);
//功能：
//重新分配用malloc或者calloc函数在堆中分配内存空间的大小。
//realloc不会自动清理增加的内存，需要手动清理，如果指定的地址后面有连续的空间，那么就会在已有地址基础上增加内存，如果指定的地址后面没有空间，那么realloc会重新分配新的连续内存，把旧内存的值拷贝到新内存，同时释放旧内存。
//参数：
//ptr：为之前用malloc或者calloc分配的内存地址，如果此参数等于NULL，那么和realloc与malloc功能一致
//size：为重新分配内存的大小, 单位：字节
//返回值：
//成功：新分配的堆内存地址
//失败：NULL
```



## 复合类型(自定义类型)

### 结构体

定义结构体变量的方式：

- 先声明结构体类型再定义变量名
- 在声明类型的同时定义变量
- 直接定义结构体类型变量（无类型名）

![img](https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8710.png)

```c
struct test{
  //...  
};
typedef struct test myTest;
//给struct test起别名为myTest，下面为等价简化版本
typedef struct test{
    //...
}myTest;
//即结构体定义时候，有typedef的话，myTest是类型别名，没有typedef的情况下，myTest直接就是结构体test的变量了
```



#### 结构体变量的初始化

```c
struct Person{
	char name[64];
	int age;
}p1 = {"john",10}; //定义类型同时初始化变量

struct{
	char name[64];
	int age;
}p2 = {"Obama",30}; //定义类型同时初始化变量

struct Person p3 = {"Edward",33}; //通过类型直接定义
```

#### 结构体赋值

##### 深拷贝和浅拷贝

重点：

- 系统提供的赋值操作是 浅拷贝 – 简单值拷贝，逐字节拷贝
- 如果结构体中有属性 创建在堆区，就会出现问题，在释放期间，一段内存重复释放，一段内存泄露

解决方案：自己手动去做赋值操作，提供深拷贝

**堆创建并释放带指针的结构体数组的案例：**（要求如下图：）

![img](https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8715.png)

```c
struct Person {
	char* name;
	int age;
};

//顺序创建
	struct Person** pArray = (struct Person**)malloc(sizeof(struct Person*) * 3);
	for (size_t i = 0; i < 3; i++)
	{
		pArray[i] = (struct Person*)malloc(sizeof(struct Person));
		pArray[i]->age = i + 100;
		pArray[i]->name = (char*)malloc(sizeof(char)*64);
	}
	memcpy(pArray[0]->name, "小明",strlen("小明")+1);
	memcpy(pArray[1]->name, "小方", strlen("小方") + 1);
	memcpy(pArray[2]->name, "王晓东", strlen("王晓东") + 1);
	for (size_t i = 0; i < 3; i++)
	{
		printf("%d号同学   名称:%s   年龄：%d\r\n", i, pArray[i]->name, pArray[i]->age);
	}
	//倒序释放
	for (size_t i = 0; i < 3; i++)
	{
		if (pArray[i]->name!=NULL)
		{
			free(pArray[i]->name);
			pArray[i]->name = NULL;
		}
		if (pArray[i]!=NULL)
		{
			free(pArray[i]);
			pArray[i] = NULL;
		}
	}
	if (pArray!=NULL)
	{
		free(pArray);
		pArray = NULL;
	}
```

创建和释放可封装成函数，创建的话需要传出地址，释放要修改地址为NULL，因此有两种方案解决如下：

1. 创建释放时通过参数传递进去，此时由于需要改变指针，因此应该传进指针的指针
2. 创建的时候可以通过返回值，返回创建的指针，避免多级指针的使用

#### 结构体字节对齐

1. 从第一个属性开始，从0开始偏移
2. 从第二个往后的属性开始，要放在***min（当前成员的大小，#pargama pack(n)）***的整数倍地址上
3. 所有属性都计算完后，结构体总的大小，也就是sizeof的结果必须是***min（结构体内部最大成员（子结构体需要拆解来看），#pargama pack(n)）***的整数倍，不足要补齐。
4. 注意，结构体嵌套结构体的时候，子结构体只需要放在子结构体中最大类型和对齐模数比的最大值的整数倍上

```c
//显示当前packing alignment的字节数，生成项目的时候以warning message的形式被显示。
#pragma pack(show)
```

![image-20201010154522488](https://raw.githubusercontent.com/che77a38/blogImage/main/image-20201010154522488.png)

**案例如下：**

```c
#pragma pack(show)//==8
struct student
{
	int a;//0~3
	char b;//4
	double c;//8~15
	float d;//16~19
};
struct teacher
{
	int a ;//0~3
	struct student b;//8~31
	int c;//32~35

};
int main(int argc, char *argv[])
{
	struct student stu1;
	stu1.a = 10;
	stu1.b = 'b';
	stu1.c = 100;
	stu1.d = 200;
	struct teacher teac1;
	teac1.a = 10;
	teac1.b = stu1;
	teac1.c = 10;
	printf("%d", sizeof(struct student));
	printf("%d", sizeof(struct teacher));
	return 0;
}
```

stu1内存占用如下：

![image-20201010164139876](https://raw.githubusercontent.com/che77a38/blogImage/main/image-20201010164139876.png)

其他字节对齐命令：

- **\#pragma pack(push)：**

英文单词push是“压入”的意思。编译器编译到此处时将保存对齐状态（保存的是push指令之前的对齐状态）。

- **\#pragma pack(pop)：**

英文单词pop是”弹出“的意思。编译器编译到此处时将恢复push指令前保存的对齐状态（请在使用该预处理命令之前使用#pragma pack(push)）。

push和pop是一对应该同时出现的名词，只有pop没有push不起作用，只有push没有pop可以保持之前对齐状态（但是这样就没有使用push的必要了）。

- **\#pragma pack() 能够取消自定义的对齐方式，恢复默认对齐。**

### 共用体(联合体)

- 联合union是一个能在同一个存储空间存储不同类型数据的类型；
- 联合体所占的内存长度等于其最长成员的长度倍数，也有叫做共用体；
- 同一内存段可以用来存放几种不同类型的成员，但每一瞬时只有一种起作用；
- 共用体变量中起作用的成员是最后一次存放的成员，在存入一个新的成员后原有的成员的值会被覆盖；
- 共用体变量的地址和它的各成员的地址都是同一地址。

```C++
#include <stdio.h>

//共用体也叫联合体 
union Test
{
	unsigned char a;
	unsigned int b;
	unsigned short c;
};

int main()
{
	//定义共用体变量
	union Test tmp;

	//1、所有成员的首地址是一样的
	printf("%p, %p, %p\n", &(tmp.a), &(tmp.b), &(tmp.c));

	//2、共用体大小为最大成员类型的大小
	printf("%lu\n", sizeof(union Test));

	//3、一个成员赋值，会影响另外的成员
	//左边是高位，右边是低位
	//低位放低地址，高位放高地址
	tmp.b = 0x44332211;

	printf("%x\n", tmp.a); //11
	printf("%x\n", tmp.c); //2211

	tmp.a = 0x00;
	printf("short: %x\n", tmp.c); //2200
	printf("int: %x\n", tmp.b); //44332200

	return 0;
}
```

### 枚举

枚举：将变量的值一一列举出来，变量的值只限于列举出来的值的范围内。

```C++
//枚举类型定义：
enum  枚举名
{
	//枚举值表
};
```

- 在枚举值表中应列出所有可用值，也称为枚举元素。
- 枚举值是常量，不能在程序中用赋值语句再对它赋值。
- 举元素本身由系统定义了一个表示序号的数值从0开始顺序定义为0，1，2 …

示例如下：

```C++
#include <stdio.h>

enum weekday
{
	sun = 2, mon, tue, wed, thu, fri, sat
} ;

enum bool
{
	flase, true
};

int main()
{
	enum weekday a, b, c;
	a = sun;
	b = mon;
	c = tue;
	printf("%d,%d,%d\n", a, b, c);

	enum bool flag;
	flag = true;

	if (flag == 1)
	{
		printf("flag为真\n");
	}
	return 0;
}
```

## typedef

typedef为C语言的关键字，作用是为一种数据类型(基本类型或自定义数据类型)定义一个新名字，不能创建新类型

- 与#define不同，typedef仅限于数据类型，而不是能是表达式或具体的值
- #define发生在预处理，typedef发生在编译阶段

## void数据类型

> void字面意思是”无类型”,void* 无类型指针，无类型指针可以指向任何类型的数据。void定义变量是没有任何意义的，当你定义void a，编译器会报错。

void真正用在以下两个方面：

- 对函数返回的限定；
- 对函数参数的限定；

**void的使用**

- **不可以利用void创建变量**  无法给无类型变量分配内存
- 用途：限定函数返回值，函数参数
- void * 万能指针  可以不通过强制类型转换就转成其他类型指针

## 文件操作

### 磁盘文件和设备文件

#### 磁盘文件

指一组相关数据的有序集合,通常存储在外部介质(如磁盘)上，使用时才调入内存。

#### 设备文件

在操作系统中把每一个与主机相连的输入、输出设备看作是一个文件，把它们的输入、输出等同于对磁盘文件的读和写。

#### 磁盘文件的分类

计算机的存储在物理上是二进制的，所以物理上所有的磁盘文件本质上都是一样的：以字节为单位进行顺序存储。

从用户或者操作系统使用的角度（逻辑上）把文件分为：

1. 文本文件：基于字符编码的文件  
2. 二进制文件：基于值编码的文件

**重点：**

1. **fwrite/fread将以二进制形式写入/读取文件，例如像例子中的int类型，将会以数值形式保存。若使用记事本等程序打开将会看到无法识别的内容。**
2. **fprintf/fscanf把数据内容格式化为字符串，实际写入文件的内容为该字符串每一个字符的ASCII码。若用记事本打开则显示文本内容。**

### 文本文件和二进制文件

#### 文本文件

- 基于字符编码，常见编码有ASCII、UNICODE等
- 一般可以使用文本编辑器直接打开
- 数5678的以ASCII存储形式(ASCII码)为：00110101 00110110 00110111 00111000

#### 二进制文件

- 基于值编码,自己根据具体应用,指定某个值是什么意思
- 把内存中的数据按其在内存中的存储形式原样输出到磁盘上
- 数5678的存储形式(二进制码)为：00010110 00101110

> **二者区别：**当对文件使用文本方式打开的时候，读写的windows文件中的换行符\r\n会被替换成\n读到内存中，当在windows下写入文件的时候，\n被替换成\r\n再写入文件。如果使用二进制方式打开文件，则不进行\r\n和\n之间的转换。 那么由于Linux下的换行符就是\n,所以文本文件方式和二进制方式无区别。

**理解：**

1. **r 读到\r\n会改为\n,读到\x1a会返回EOF**
2. **rb 读到什么返回什么,读到文件末尾才会返回EOF**

**文件I/O的特点：**

1. 程序为同时处于活动状态的每个文件声明一个指针变量，其类型为FILE*。这个指针指向这个FILE结构，当它处于活动状态时由流使用。
2. 流通过fopen函数打开。为了打开一个流，我们必须指定需要访问的文件或设备以及他们的访问方式(读、写、或者读写)。Fopen和操作系统验证文件或者设备是否存在并初始化FILE。
3. 根据需要对文件进行读写操作。
4. 最后调用fclose函数关闭流。关闭一个流可以防止与它相关的文件被再次访问，保证任何存储于缓冲区中的数据被正确写入到文件中，并且释放FILE结构。

**p.s.**标准I/O更为简单，因为它们并不需要打开或者关闭。

**I/O函数家族：**

| 家族名  | 目的       | 可用于所有流 | 只用于stdin和stdout |
| ------- | ---------- | ------------ | ------------------- |
| getchar | 字符输入   | fgetc、getc  | getchar             |
| putchar | 字符输出   | fputc、putc  | putchar             |
| gets    | 文本行输入 | fgets        | gets                |
| puts    | 文本行输出 | fputs        | puts                |
| scanf   | 格式化输入 | fscanf       | scanf               |
| printf  | 格式化输出 | fprintf      | printf              |



### 文件指针

在C语言中用一个指针变量指向一个文件，这个指针称为文件指针。

```c++
//ANSI C并未规定FILE的成员，不同编译器可能有不同的定义。
typedef struct
{
	short           level;	//缓冲区"满"或者"空"的程度 
	unsigned        flags;	//文件状态标志（读到文件尾巴，该标志为true，否则false） 
	char            fd;		//文件描述符
	unsigned char   hold;	//如无缓冲区不读取字符
	short           bsize;	//缓冲区的大小
	unsigned char   *buffer;//数据缓冲区的位置 
	unsigned        ar;	 //指针，当前的指向 
	unsigned        istemp;	//临时文件，指示器
	short           token;	//用于有效性的检查 
}FILE;
```

FILE是系统使用typedef定义出来的有关文件信息的一种结构体类型，结构中含有文件名、文件状态和文件当前位置等信息。

声明FILE结构体类型的信息包含在头文件“stdio.h”中，一般设置一个指向FILE类型变量的指针变量，然后通过它来引用这些FILE类型变量。通过文件指针就可对它所指的文件进行各种操作。 

![img](https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%879.png)

**C语言中有三个特殊的文件指针由系统默认打开**，用户无需定义即可直接使用:

1. stdin： 标准输入，默认为当前终端（键盘），我们使用的scanf、getchar函数默认从此终端获得数据。
2. stdout：标准输出，默认为当前终端（屏幕），我们使用的printf、puts函数默认输出信息到此终端。
3. stderr：标准出错，默认为当前终端（屏幕），我们使用的perror函数默认输出信息到此终端。



### 文件缓冲区

ANSI C标准采用“缓冲文件系统”处理数据文件。

所谓缓冲文件系统是指系统自动地在内存区为程序中每一个正在使用的文件开辟一个文件缓冲区从内存向磁盘输出数据必须先送到内存中的缓冲区，装满缓冲区后才一起送到磁盘去。

如果从磁盘向计算机读入数据，则一次从磁盘文件将一批数据输入到内存缓冲区(充满缓冲区)，然后再从缓冲区逐个地将数据送到程序数据区(给程序变量) 。

#### 磁盘文件的存取

![img](http://images.51cto.com/files/uploadimg/20090731/162655699.jpg)

![img](https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%878.png)

- 磁盘文件，一般保存在硬盘、U盘等掉电不丢失的磁盘设备中，在需要时调入内存
- 在内存中对文件进行编辑处理后，保存到磁盘中
- 程序与磁盘之间交互，不是立即完成，系统或程序可根据需要设置缓冲区，以提高存取效率

#### 更新缓冲区

```c
#include <stdio.h>
int fflush(FILE *stream);
//功能：更新缓冲区，让缓冲区的数据立马写到文件中。
//参数：
//stream：文件指针
//返回值：
//成功：0
//失败：-1
```

#### 缓冲区的优势

1. 提高硬件寿命（减少读写硬盘的次数）
2. 提高读写效率，直接从内存进行读写

### 文件的打开和关闭

#### 文件的打开

任何文件使用之前必须打开：

```C
#include <stdio.h>
FILE * fopen(const char * filename, const char * mode);
//功能：打开文件
//参数：
//	filename：需要打开的文件名，根据需要加上路径
//	mode：打开文件的模式设置
//返回值：
//	成功：文件指针
//	失败：NULL
```

第一个参数的几种形式:

```C
	FILE *fp_passwd = NULL;

	//相对路径：
	//打开当前目录passdw文件：源文件(源程序)所在目录
	FILE *fp_passwd = fopen("passwd.txt", "r");
	
	//打开当前目录(test)下passwd.txt文件
	fp_passwd = fopen(". / test / passwd.txt", "r");
	
	//打开当前目录上一级目录（相对当前目录）passwd.txt文件
	fp_passwd = fopen(".. / passwd.txt", "r");
		
	//绝对路径：
	//打开C盘test目录下一个叫passwd.txt文件
	fp_passwd = fopen("c:/test/passwd.txt","r");
```

第二个参数的几种形式(打开文件的方式)：

| ***打开模式*** | ***含义***                                                   |
| -------------- | ------------------------------------------------------------ |
| r或rb          | 以只读方式打开一个文本文件（不创建文件，若文件不存在则报错） |
| w或wb          | 以写方式打开文件(如果文件存在则清空文件，文件不存在则创建一个文件) |
| a或ab          | 以追加方式打开文件，在末尾添加内容，若文件不存在则创建文件   |
| r+或rb+        | 以可读、可写的方式打开文件(不创建新文件)                     |
| w+或wb+        | 以可读、可写的方式打开文件(如果文件存在则清空文件，文件不存在则创建一个文件) |
| a+或ab+        | 以添加方式打开可读、可写的文件。若文件不存在则创建文件；如果文件存在，则写入的数据会被加到文件尾后，即文件原先的内容会被保留。 |

| 方式  | 含义                                                         |
| ----- | ------------------------------------------------------------ |
| “r”   | 打开，只读，文件必须已经存在。                               |
| “w”   | 只写,如果文件不存在则创建,如果文件已存在则把文件长度截断(Truncate)为0字节。再重新写,也就是替换掉原来的文件内容文件指针指到头。 |
| “a”   | 只能在文件末尾追加数据,如果文件不存在则创建                  |
| “rb”  | 打开一个二进制文件，只读                                     |
| “wb”  | 打开一个二进制文件，只写                                     |
| “ab"  | 打开一个二进制文件，追加                                     |
| “r+”  | 允许读和写,文件必须已存在                                    |
| “w+”  | 允许读和写,如果文件不存在则创建,如果文件已存在则把文件长度截断为0字节再重新写 。 |
| “a+”  | 允许读和追加数据,如果文件不存在则创建                        |
| “rb+” | 以读/写方式打开一个二进制文件                                |
| “wb+” | 以读/写方式建立一个新的二进制文件                            |
| “ab+” | 以读/写方式打开一个二进制文件进行追加                        |

注意：

- b是二进制模式的意思，b只是在Windows有效，在Linux用r和rb的结果是一样的
- Unix和Linux下所有的文本文件行都是\n结尾，而Windows所有的文本文件行都是\r\n结尾
- 在Windows平台下，以“文本”方式打开文件，不加b：
  - 当读取文件的时候，系统会将所有的 "\r\n" 转换成 "\n"
  - 当写入文件的时候，系统会将 "\n" 转换成 "\r\n" 写入 
  - 以"二进制"方式打开文件，则读写都不会进行这样的转换

- 在Unix/Linux平台下，“文本”与“二进制”模式没有区别，"\r\n" 作为两个字符原样输入输出

> P.S.
>
> "\\"这样的路径形式，只能在windows使用
>
> "/"这样的路径形式，windows和linux平台下都可用，建议使用这种

#### 文件的关闭

任何文件在使用后应该关闭：

- 打开的文件会占用内存资源，如果总是打开不关闭，会消耗很多内存
- 一个进程同时打开的文件数是有限制的，超过最大同时打开文件数，再次调用fopen打开文件会失败
- 如果没有明确的调用fclose关闭打开的文件，那么程序在退出的时候，操作系统会统一关闭。

```C
#include <stdio.h>
int fclose(FILE * stream);
//功能：关闭先前fopen()打开的文件。此动作让缓冲区的数据写入文件中，并释放系统所提供的文件资//源。
//参数：
//	stream：文件指针
//返回值：
//	成功：0
//	失败：-1
```

### 文件的顺序读写

- 按照字符读写文件：fgetc(), fputc()
- 按照行读写文件：fputs(), fgets()
- 按照块读写文件：fread(), fwirte()
- 按照格式化读写文件：fprintf(), fscanf()
- 按照随机位置读写文件：fseek(), ftell(), rewind()	

首先一定要记住fread函数只用于读二进制文件（即fopen打开方式必须带b），而fscanf可以读文本也可以读二进制。



#### 按照字符读写文件fgetc、fputc、feof

##### 写文件

```c
#include <stdio.h>
int fputc(int ch, FILE * stream);
//功能：将ch转换为unsigned char后写入stream指定的文件中
//参数：
//	ch：需要写入文件的字符
//	stream：文件指针
//返回值：
//	成功：成功写入文件的字符
//	失败：返回-1
```

##### 文件结尾

在C语言中，EOF表示文件结束符(end of file)。在while循环中以EOF作为文件结束标志，这种以EOF作为文件结束标志的文件，必须是文本文件。在文本文件中，数据都是以字符的ASCII代码值的形式存放。我们知道，ASCII代码值的范围是0~127，不可能出现-1，因此可以用EOF作为文件结束标志。

```c
#define EOF    (-1)
```

当把数据以二进制形式存放到文件中时，就会有-1值的出现，因此不能采用EOF作为二进制文件的结束标志。为解决这一个问题，ANSI C提供一个feof函数，用来判断文件是否结束。feof函数既可用以判断二进制文件又可用以判断文本文件。

```c
#include <stdio.h>
int feof(FILE * stream);
//功能：检测是否读取到了文件结尾。判断的是最后一次“读操作的内容”，不是当前位置内容(上一个内容)。
//参数：
//	stream：文件指针
//返回值：
//	非0值：已经到文件结尾
//	0：没有到文件结尾
```



##### 读文件

```c
#include <stdio.h>
int fgetc(FILE * stream);
//功能：从stream指定的文件中读取一个字符
//参数：
//	stream：文件指针
//返回值：
//	成功：返回读取到的字符
//	失败：-1
```

案例：

```c
char ch;
#if 0
while ((ch = fgetc(fp)) != EOF)//读到的不是EOF则循环
{
	printf("%c", ch);
}
printf("\n");
#endif

while (!feof(fp)) //文件没有结束，则执行循环
{
	ch = fgetc(fp);
	printf("%c", ch);
}
printf("\n");
```

### 按照行读写文件fgets、fputs

##### 写文件

```c
#include <stdio.h>
int fputs(const char * str, FILE * stream);
//功能：将str所指定的字符串写入到stream指定的文件中，字符串结束符 '\0'  不写入文件。 
//参数：
//	str：字符串
//	stream：文件指针
//返回值：
//	成功：0
//	失败：-1
```

##### 读文件

```c
#include <stdio.h>
char * fgets(char * str, int size, FILE * stream);
//功能：从stream指定的文件内读入字符，保存到str所指定的内存空间，直到出现换行字符、读到文件结尾或是已读了size - 1个字符为止，最后会自动加上字符 '\0' 作为字符串结束。
//参数：
//	str：字符串
//	size：指定最大读取字符串的长度（size - 1）
//	stream：文件指针
//返回值：
//	成功：成功读取的字符串
//	读到文件尾或出错： NULL
```

### 格式化文件fprintf、fscanf

#### 写文件

```c
#include <stdio.h>
int fprintf(FILE * stream, const char * format, ...);
//功能：根据参数format字符串来转换并格式化数据，然后将结果输出到stream指定的文件中，直到出现字符串结束符 '\0'  为止。
//参数：
//	stream：已经打开的文件
//	format：字符串格式，用法和printf()一样
//返回值：
//	成功：实际写入文件的字符个数
//	失败：-1

fprintf(fp, "%d %d %d\n", 1, 2, 3);
```

#### 读文件

```c
#include <stdio.h>
int fscanf(FILE * stream, const char * format, ...);
//功能：从stream指定的文件读取字符串，并根据参数format字符串来转换并格式化数据。
//注意:遇到空格和换行时结束
//参数：
//	stream：已经打开的文件
//	format：字符串格式，用法和scanf()一样
//返回值：
//	成功：参数数目，成功转换的值的个数
//	失败： - 1
```

### 按照块读写文件fread、fwrite

#### 写文件

```c
#include <stdio.h>
size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);
//功能：以数据块的方式给文件写入内容
//参数：
//	ptr：准备写入文件数据的地址
//	size： size_t 为 unsigned int类型，此参数指定写入文件内容的块数据大小
//	nmemb：写入文件的块数，写入文件数据总大小为：size * nmemb
//	stream：已经打开的文件指针
//返回值：
//	成功：实际成功写入文件数据的块数目，此值和 nmemb 相等
//	失败：0
```

##### 读文件

```c
#include <stdio.h>
size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
//功能：以数据块的方式从文件中读取内容
//参数：
//	ptr：存放读取出来数据的内存空间
//	size： size_t 为 unsigned int类型，此参数指定读取文件内容的块数据大小（单位是字节）
//	nmemb：读取文件的块数，读取文件数据总大小为：size * nmemb
//	stream：已经打开的文件指针
//返回值：
//	成功：实际成功读取到内容的块数，如果此值比nmemb小，但大于0，说明读到文件的结尾。
//	失败：0
//	0: 表示读到文件结尾。(feof())
```

### 文件的随机读写

```c
#include <stdio.h>
int fseek(FILE *stream, long offset, int whence);
功能：移动文件流（文件光标）的读写位置。
参数：
	stream：已经打开的文件指针
	offset：根据whence来移动的位移数（偏移量），可以是正数，也可以负数，如果正数，则相对于whence往右移动，如果是负数，则相对于whence往左移动。如果向前移动的字节数超过了文件开头则出错返回，如果向后移动的字节数超过了文件末尾，再次写入时将增大文件尺寸。
	whence：其取值如下：
		SEEK_SET：从文件开头移动offset个字节
		SEEK_CUR：从当前位置移动offset个字节
		SEEK_END：从文件末尾移动offset个字节
返回值：
	成功：0
	失败：-1

#include <stdio.h>
long ftell(FILE *stream);
功能：获取文件流（文件光标）的读写位置。
参数：
	stream：已经打开的文件指针
返回值：
	成功：当前文件流（文件光标）的读写位置
	失败：-1

#include <stdio.h>
void rewind(FILE *stream);
功能：把文件流（文件光标）的读写位置移动到文件开头。
参数：
	stream：已经打开的文件指针
返回值：
	无返回值
```

负数移动光标：

![image-20201010182023642](https://raw.githubusercontent.com/che77a38/blogImage/main/image-20201010182023642.png)

### Windows和Linux文本文件区别

判断文本文件是Linux格式还是Windows格式:

```c
#include<stdio.h>

int main(int argc, char **args)
{
	if (argc < 2)
		return 0;

	FILE *p = fopen(args[1], "rb");
	if (!p)
		return 0;

	char a[1024] = { 0 };
	fgets(a, sizeof(a), p);

	int len = 0;
	while (a[len])
	{
		if (a[len] == '\n')
		{
			if (a[len - 1] == '\r')
			{
				printf("windows file\n");
			}
			else
			{
				printf("linux file\n");
			}
		}
		len++;
	}

	fclose(p);

	return 0;
}
```

### 获取文件状态

```c
#include <sys/types.h>
#include <sys/stat.h>
int stat(const char *path, struct stat *buf);
//功能：获取文件状态信息
//参数：
//path：文件名
//buf：保存文件信息的结构体
//返回值：
//成功：0
//失败-1
```

stat结构体如下：

```c
struct stat {
	dev_t         st_dev;         //文件的设备编号
	ino_t         st_ino;          //节点
	mode_t        st_mode;   //文件的类型和存取的权限
	nlink_t       st_nlink;     //连到该文件的硬连接数目，刚建立的文件值为1
	uid_t         st_uid;         //用户ID
	gid_t         st_gid;         //组ID
	dev_t         st_rdev;      //(设备类型)若此文件为设备文件，则为其设备编号
	off_t         st_size;        //文件字节数(文件大小)
	unsigned long st_blksize;   //块大小(文件系统的I/O 缓冲区大小)
	unsigned long st_blocks;    //块数
	time_t        st_atime;     //最后一次访问时间
	time_t        st_mtime;    //最后一次修改时间
	time_t        st_ctime;     //最后一次改变时间(指属性)
};
```

### 删除文件、重命名文件名

```c
#include <stdio.h>
int remove(const char *pathname);
功能：删除文件
参数：
	pathname：文件名
返回值：
	成功：0
	失败：-1

#include <stdio.h>
int rename(const char *oldpath, const char *newpath);
功能：把oldpath的文件名改为newpath
参数：
oldpath：旧文件名
newpath：新文件名
返回值：
成功：0
失败： - 1
```

### 文件操作注意点

1. feof()函数有滞后性，不要用feof按照字符方式读文件，会读出EOF，EOF打印出来是“  ”，比空格长的一段空白间距
2. 如果属性开辟到堆区，不要存指针到文件中，要将指针指向的内容存放在文件中

### 打印错误：

```c
perror("文件打开失败\n");//会在"打印文件打开失败\n"之后，继续打印系统自带的错误显示
```

## 函数指针

### 函数指针

***注意：***通过函数类型定义的变量是不能够直接执行，因为没有函数体。只能通过类型定义一个函数指针指向某一个具体函数，才能调用。

函数指针没有步长

#### 函数指针和指针函数的区别

- 函数指针：指向函数的指针
- 指针函数：返回值为指针的函数

#### **指针函数数组（重点）**

返回值和参数均为void的函数指针的长度为10的数组类型定义方式如下：

```c
typedef void(*函数指针的数组类型[10])();
//定义该类型变量
函数指针的数组类型 a;
//赋值(testFunc为函数名，即函数指针)
a[0]=testFunc;
//通过a调用testFunc
a[0]();
```

#### 回调函数(函数指针做函数参数)（难点）

提供一个函数实现对任意类型数组进行排序，排序规则利用选择排序，排序的顺序可以用户自己指定

案例如下：





## 随机数

srand函数是[随机数](https://baike.baidu.com/item/随机数)发生器的[初始化](https://baike.baidu.com/item/初始化)函数。修改随机数种子：(修改为当前时间戳)

```c
srand((unsigned)time(NULL));
```

srand设置产生一系列伪随机数发生器的起始点，要想把发生器重新初始化，可用1作seed值。任何其它的值都把发生器匿成一个随机的起始点。rand检索生成的伪随机数。在任何调用srand之前调用rand与以1作为seed调用srand产生相同的序列。

获取随机数：

```c
cout<<rand();
```

参数[seed](https://baike.baidu.com/item/seed/27784)是rand()的种子，用来初始化rand()的起始值。

可以认为rand()在每次被调用的时候，它会查看：

1） 如果用户在此之前调用过srand(seed)，给seed指定了一个值，那么它会自动调用srand(seed)一次来初始化它的起始值。

2） 如果用户在此之前没有调用过srand(seed)，它会自动调用srand(1)一次。



**理解上**：srand会产生一个随机数序列，种子决定了其起始点，rand为往后取。同样的种子，rand往后取多次产生的随机序列相同。





## 库

### 静态库的创建

1. 配置项目属性。因为这是一个静态链接库，所以应在项目属性的“配置属性”下选择“常规”，在其下的配置类型中选择“静态库（.lib）。
2. 编译生成新的解决方案，在Debug文件夹下会得到mylib.lib (对象文件库），将该.lib文件和相应头文件（头文件是给用户阅读知道库提供了什么函数）给用户，用户就可以使用该库里的函数了。

### 静态库的使用

3种方法：

1. **配置项目属性**

```javascript
A、添加工程的头文件目录：工程---属性---配置属性---c/c++---常规---附加包含目录：加上头文件存放目录。
B、添加文件引用的lib静态库路径：工程---属性---配置属性---链接器---常规---附加库目录：加上lib文件存放目录。
C  然后添加工程引用的lib文件名：工程---属性---配置属性---链接器---输入---附加依赖项：加上lib文件名。
```

2. **使用编译语句**

```c
#pragma comment(lib,"./mylib.lib")
```

3. **直接添加到工程中**（2,3步骤等价）

```c
就像你添加.h和.c文件一样,把lib文件添加到工程文件列表中去.
切换到"解决方案视图",--->选中要添加lib的工程-->点击右键-->"添加"-->"现有项"-->选择lib文件-->确定.
```

### 静态库优缺点

- 静态库对函数库的链接是放在编译时期完成的，静态库在程序的链接阶段被复制到了程序中，和程序运行的时候没有关系；
- 程序在运行时与函数库再无瓜葛，移植方便。
- 浪费空间和资源，所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。

p.s.一旦程序中有任何模块更新，整个程序就要重新编译链接、发布给用户，用户要重新安装整个程序。

p.s.静态链接的方式对于计算机内存和磁盘空间浪费非常严重。特别是多进程操作系统下，静态链接极大的浪费了内存空间。在现在的linux系统中，一个普通程序会用到c语言静态库至少在1MB以上，那么如果磁盘中有2000个这样的程序，就要浪费将近2GB的磁盘空间。

### 动态库的创建

> 简单地讲，就是不对哪些组成程序的目标程序进行链接，等程序运行的时候才进行链接。也就是说，把整个链接过程推迟到了运行时再进行，这就是动态链接的基本思想。

1. 创建一个新项目，在已安装的模板中选择“常规”，在右边的类型下选择“空项目”，在名称和解决方案名称中输入mydll。点击确定。
2. 在解决方案资源管理器的头文件中添加,mydll.h文件，在源文件添加mydll.c文件（即实现文件）。
3. 在test.h文件中添加如下代码：

```c
//想导出的函数声明必须加，定义可加可不加__declspec(dllexport)
__declspec(dllexport) int myminus(int a, int b);
//字面翻译declare special声明特殊(dllexport动态链接库导出)
```

4. 配置项目属性。因为这是一个动态链接库，所以应在项目属性的“配置属性”下选择“常规”，在其下的配置类型中选择“动态库（.dll）。
5. 编译生成新的解决方案，在Debug文件夹下会得到mydll.dll (对象文件库），将该.dll文件、.lib文件和相应头文件给用户，用户就可以使用该库里的函数了。

导出方式有以下两种：

1. *.def 文件

```c
//*.def 文件必须至少包含下列模块定义语句：

//文件中的第一个语句必须是 LIBRARY 语句。此语句将 .def 文件标识为属于 DLL。LIBRARY 语句的后面是 DLL 的名称。链接器将此名称放到 DLL 的导入库中。

//EXPORTS 语句列出名称，可能的话还会列出 DLL 导出函数的序号值。通过在函数名的后面加上 @ 符和一个数字，给函数分配序号值。当指定序号值时，序号值的范围必须是从 1 到 N，其中 N 是 DLL 导出函数的个数。

//注释语句，在语句前面加分号 “;” 。

//例如：
//;DLLTest.def : Declares the module parameters for the DLL.
LIBRARY "DLLTest"
EXPORTS
add @1
fun @2
```

如果是VS平台，必须要在连接器中添加.def文件

![img](https://raw.githubusercontent.com/che77a38/blogImage/main/1.WEBP)

2. __declspec(dllexport) 关键字



**重要理解：**

1. 动态链接库中定义有两种函数：**导出函数(export  function)和内部函数(internal  function)**。 导出函数可以被其它模块调用，内部函数在定义它们的DLL程序内部使用。
2. **动态库的lib文件和静态库的lib文件的区别？**

**在使用动态库的时候，往往提供两个文件：一个引入库（.lib）文件（也称“导入库文件”）和一个DLL（.dll）文件。**虽然引入库的后缀名也是“lib”，但是，动态库的引入库文件和静态库文件有着本质的区别，**对一个DLL文件来说，其引入库文件（.lib）包含该DLL导出的函数和变量的符号名，而.dll文件包含该DLL实际的函数和数据。**在使用动态库的情况下，在编译链接可执行文件时，只需要链接该DLL的引入库文件，该DLL中的函数代码和数据并不复制到可执行文件，直到可执行程序运行时，才去加载所需的DLL，将该DLL映射到进程的地址空间中，然后访问DLL中导出的函数。

### 动态库的使用

#### 方法一：隐式调用

 创建主程序TestDll，将mydll.h、mydll.dll和mydll.lib复制到源代码目录下。

(P.S：头文件Func.h并不是必需的，只是C++中使用外部函数时，需要先进行声明)

在程序中指定链接引用链接库 : #pragma comment(lib,"./mydll.lib")

 #pragma comment(lib,"./mydll.lib")和直接把mydll.lib添加进项目等价

#### 方法二：显式调用

```c
	HANDLE hDll; //声明一个dll实例文件句柄
	hDll = LoadLibrary("mydll.dll"); //导入动态链接库
	MYFUNC minus_test; //创建函数指针
	//获取导入函数的函数指针
	minus_test = (MYFUNC)GetProcAddress(hDll, "myminus");
```





#  面向接口编程

以函数指针为接口，双方分割来开发

# 数据结构

**数据结构**是计算机存储、组织数据的方式。是相互之间存在一种或多种特定关系的数据元素集合

**算法**是特定问题求解步骤的描述，在计算机中表现为***指令的有限序列***，算法是独立存在的一种解决问题的方法和思想。

> 对于算法而言，语言并不重要，重要的是思想。

***算法和数据结构区别***

1. ***算法是为了解决实际问题而设计的。***
2. **数据结构是算法需要处理的问题载体。**
3. 数据结构与算法相辅相成。

***算法具有五个基本的特性：输入、输出、有穷性、确定性和可行性***

-  **输入输出**：算法具有零个或多个输入、至少有一个或多个输出。
-  **有穷性**：指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。
-  **确定性**：算法的每一步骤都有确定的含义，不会出现二义性。
-  **可行性**：算法的每一步都必须是可行的，也就是说，每一步都能通过执行有限次数完成。

## ***数据结构分类***

###  ***逻辑结构***

#### 集合结构

集合结构中的数据元素除了同属于一个集合外，他们之间没有其他关系。各个数据元素是平等的。他们共同属于同一个集合，数据结构中的集合关系类似于数学中的集合。如图：

![img](https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8723.png)

#### 线性结构

线性结构中的数据元素之间是**一对一**的关系。

> 一对一：第一个元素没有前驱，最后一个元素没有后续，其他元素都有一个前驱一个后继

如图：

![img](https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8724.png)

#### 树形结构

树形结构中是数据元素之间存在一种**一对多**的层次关系，如图：

![img](https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8725.png)



#### 图形结构

图形结构的数据元素**多对多**的关系，如图：

![img](https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8726.png)

### 物理结构

物理结构：是指数据的逻辑结构在计算机中的存储形式，共分为两种：顺序存储和链式存储。

#### 顺序存储

是把数据元素存放在地址连续的存储单元里，其数据的逻辑关系和物理关系是一致的，如图：

![img](https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8727.png)



#### 链式存储结构

是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关数据的位置。如图：

![img](https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8728.png)

## 线性表

线性结构是一种最简单且常用的数据结构。线性结构的基本特点是节点之间满足线性关系。

**动态数组、链表、栈、队列**都属于线性结构。

线性表是零个或者多个数据元素的有限序列，***数据元素之间是有顺序的***，***数据元素个数是有限的***，***数据元素的类型必须相同***

### 动态数组

下图中的链表指的就是**动态数组**

![img](https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8729.png)

优点：

- 无需为线性表中的逻辑关系增加额外的空间。
- 可以快速的获取表中合法位置的元素。

缺点：

- 插入和删除操作需要移动大量元素。

#### 动态数组案例：

##### dynamicArray.h头文件

```c
/***************************************************** ************************* 
* @版权所有（c）2020，Peng，保留所有权利。 
* @文件路径:    C:\USERS\ADMINISTRATOR\DESKTOP\C语言学习案例（内含数据结构）\动态数组案例\DYNAMICARRAY\dynamicArray.h 
* @版本：1.0版 
* @作者：Peng 
* @创建时间：2020 / 11 / 05 17：06 
* @文件描述： 动态数组头文件
****************************************************** ************************/  


#pragma once
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//未使用void*重命名隐藏DynamicArray指针的索引，并且未将如下结构体置于源文件中，防止生成库时用户直接在头文件中看到
typedef struct _DynamicArray
{
	void **ArrayAddr;//动态数组首地址
	int m_capacity;//动态数组当前容量
	int m_size;//动态数组当前占用大小
}DynamicArray;


//动态数组初始化
DynamicArray* init_DynamicArray(int capacity);

//动态数组遍历
void foreach_DynamicArray(DynamicArray* dynamicArray,void(*myPrintf)(void*));


//动态数组末尾添加
void append_DynamicArray(DynamicArray* dynamicArray,void* data);


//动态数组插入
void insert_DynamicArray(DynamicArray* dynamicArray, int pos, void* data);


//动态数组修改
void change_DynamicArray(DynamicArray* dynamicArray, int pos, void* data);


//动态数组项删除
void removeByPos_DynamicArray(DynamicArray* dynamicArray,int pos);


//动态数组清空
void clear_DynamicArray(DynamicArray* dynamicArray);


//动态数组销毁
void destroy_DynamicArray(DynamicArray** dynamicArray);

```

##### dynamicArray.c源文件

```c
/***************************************************** ************************* 
* @版权所有（c）2020，Peng，保留所有权利。 
* @文件路径:    C:\USERS\ADMINISTRATOR\DESKTOP\C语言学习案例（内含数据结构）\动态数组案例\DYNAMICARRAY\dynamicArray.c 
* @版本：1.0版 
* @作者：Peng 
* @创建时间：2020 / 11 / 05 17：06 
* @文件描述： 动态数组源文件
****************************************************** ************************/  
#include "dynamicArray.h"

DynamicArray* init_DynamicArray(int capacity)
{
	if (capacity<=0)
	{
		return NULL;
	}
	DynamicArray* dynamicArray = malloc(sizeof(DynamicArray));
	if (!dynamicArray)
	{
		return NULL;
	}
	dynamicArray->ArrayAddr = malloc(sizeof(void*)*capacity);
	if (!dynamicArray->ArrayAddr)
	{
		free(dynamicArray);
		return NULL;
	}
	dynamicArray->m_capacity = capacity;
	dynamicArray->m_size = 0;
	return dynamicArray;
}

void foreach_DynamicArray(DynamicArray* dynamicArray, void(*myPrintf)(void*))
{
	if (!dynamicArray||!myPrintf)
	{
		return;
	}
	printf("容量：%d  占用大小：%d\r\n",dynamicArray->m_capacity,dynamicArray->m_size);
	for (size_t i = 0; i < dynamicArray->m_size; i++)
	{
		myPrintf(dynamicArray->ArrayAddr[i]);
	}
}


void insert_DynamicArray(DynamicArray* dynamicArray, int pos, void* data)
{
	if (!dynamicArray||!data)
	{
		return;
	}
	//无效位置，则尾插
	if (pos<0||pos>dynamicArray->m_size)
	{
		pos = dynamicArray->m_size;
	}
	//空间不够则拓展空间
	if (dynamicArray->m_size==dynamicArray->m_capacity)
	{
		dynamicArray->ArrayAddr = realloc(dynamicArray->ArrayAddr, dynamicArray->m_capacity *sizeof(void*)*2);
		dynamicArray->m_capacity*=2;
	}
	//后面元素往后移动
	for (int i = dynamicArray->m_size-1; i >=pos; i--)
	{
		dynamicArray->ArrayAddr[i + 1] = dynamicArray->ArrayAddr[i];
	}
	//插入新元素
	dynamicArray->ArrayAddr[pos] = data;
	dynamicArray->m_size++;
	
	
}


void change_DynamicArray(DynamicArray* dynamicArray, int pos, void* data)
{
	if (!dynamicArray || !data)
	{
		return;
	}
	//无效位置
	if (pos<0 || pos>=dynamicArray->m_size)
	{
		return;
	}
	dynamicArray->ArrayAddr[pos] = data;
}

void clear_DynamicArray(DynamicArray* dynamicArray)
{
	if (!dynamicArray )
	{
		return;
	}
	memset(dynamicArray->ArrayAddr, 0,sizeof(void*)*dynamicArray->m_size);
	dynamicArray->m_size = 0;
}



void destroy_DynamicArray(DynamicArray** dynamicArray)
{
	if (!(*dynamicArray))
	{
		return;
	}
	if ((*dynamicArray)->ArrayAddr!=NULL)
	{
		free((*dynamicArray)->ArrayAddr);
		(*dynamicArray)->ArrayAddr = NULL;
	}
	free(*dynamicArray);
	*dynamicArray = NULL;
	
}


void removeByPos_DynamicArray(DynamicArray* dynamicArray, int pos)
{
	if (!dynamicArray)
	{
		return;
	}
	if (pos < 0 || pos >= dynamicArray->m_size)
	{
		return;
	}
	for (int i = 0; i < dynamicArray->m_size-1; i++)
	{
		if (i>=pos)
		{
			dynamicArray->ArrayAddr[i] = dynamicArray->ArrayAddr[i + 1];
		}
	}
	dynamicArray->ArrayAddr[dynamicArray->m_size - 1] = NULL;
	dynamicArray->m_size--;
}


```



### 链表

数组缺陷：

1. 静态空间，一旦分配内存就不可以动态扩展，如果分配过多，造成资源浪费，空间操作不精确
2. 插入删除效率低

> **链表的构成**
>
> 链表由节点构成
>
> 节点由数据域（维护数据）和指针域（维护上一个或下一个节点）组成

**带头节点指针pHeader，和尾节点指针pTail**

但大多数链表都只带头节点，如下图

![img](https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8716.png)

不带链表头节点如下图：

![img](https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8720.png)

> 头结点不固定，根据实际需要变换头结点(如在原来头结点前插入新节点，然后，新节点重新作为链表的头结点)。

优势：带头结点永远固定了头节点和尾节点的位置，方便头部和尾部的操作

链表的分类一：

1. 静态链表 （在栈上分配内存）

```c
//链表节点的结构体
typedef struct _LinkNode
{
	int num;//数据域
	struct LinkNode* next;//指针域
}LinkNode;

void main()
{
    //创建节点
    LinkNode node1={10,NULL};
    LinkNode node2={20,NULL};
    LinkNode node3={30,NULL};
    //建立关系
    node1.next=&node2;
    node2.next=&node3;
    //遍历链表
    LinkNode* pCurrent=&node1;
    while(pCurrent!=NULL)
    {
        //此处可遍历数据
        printf("%d\r\n",pCurrent.num);
        pCurrent=pCurrent->next;
	}  
}
```

2. 动态链表（在堆上分配内存）

```c
//链表节点的结构体
typedef struct _LinkNode
{
	int num;//数据域
	struct LinkNode* next;//指针域
}LinkNode;

void main()
{
    //创建节点
    LinkNode* node1=malloc(sizeof(LinkNode));
    LinkNode* node2=malloc(sizeof(LinkNode));
    LinkNode* node3=malloc(sizeof(LinkNode));
    node1->num=100;
    node2->num=200;
    node3->num=300;
    //建立关系
    node1->next=node2;
    node2->next=node3;
    node3->next=NULL;
    //遍历链表
    LinkNode* pCurrent=node1;
    while(pCurrent!=NULL)
    {
        //此处可遍历数据
        printf("%d\r\n",pCurrent->num);
        pCurrent=pCurrent->next;
	}  
    //释放空间
    free(node1);
    free(node2);
    free(node3);
    node1=null;
    node2=null;
    node3=null;
}
```

链表的分类二

1. 单向链表

![img](https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8717.png)

2. 双向链表

![img](https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8718.png)

3. 单向循环链表

![img](https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8719.png)

4. 双向循环链表



#### **链表案例：**

##### linkList.h头文件

```c
/***************************************************** ************************* 
* @版权所有（c）2020，Peng，保留所有权利。 
* @文件路径:    C:\USERS\ADMINISTRATOR\DESKTOP\C语言学习案例（内含数据结构）\链表案例\LINKNODETEST\linkList.h 
* @版本：1.0版 
* @作者：Peng 
* @创建时间：2020 / 11 / 06 15：38 
* @文件描述： 链表头文件，链表一切空间申请释放均已处理
****************************************************** ************************/  

#pragma once
#include <stdio.h>
#include <string.h>
#include <stdlib.h>


//此处由于C语言中没有C++类似的保护内部数据防止直接访问的机制，因此用void*的方式可以防止使用我们代码的用户访问到内部成员（就是点不出来），而我们自己使用的时候再自己进行强转使用。
typedef void* LinkList;


//初始化链表
LinkList* init_LinkList();


//遍历链表
void foreach_LinkList(LinkList* linklist, void(*myPrintf)(void*));


//添加节点
void append_LinkList(LinkList* linklist, void* data);


//插入链表
void insert_LinkList(LinkList* linklist, int pos, void* data);


//删除节点
void delete_LinkList(LinkList* linklist, int pos);


//反转链表
void reverse_LinkList(LinkList* linklist);


//清空链表 
void clear_LinkList(LinkList* linklist);


//销毁链表
void destroy_LinkList(LinkList** linklist);


//返回长度
int getLength_LinkList(LinkList* linklist);
```

##### linkList.cpp源文件

```c
/***************************************************** ************************* 
* @版权所有（c）2020，Peng，保留所有权利。 
* @文件路径:    C:\USERS\ADMINISTRATOR\DESKTOP\C语言学习案例（内含数据结构）\链表案例\LINKNODETEST\linkList.cpp 
* @版本：1.0版 
* @作者：Peng 
* @创建时间：2020 / 11 / 06 15：38 
* @文件描述： 链表源文件，链表一切空间申请释放均已处理
****************************************************** ************************/  
#include "linkList.h"

//重点：该结构体放在源文件中的目的是当把这个文件生成库文件时，可以避免用户直接在头文件中直接看到该结构的真实情况
//节点结构体，用于组织成链表
typedef struct _LinkNode
{
	void* data;
	struct _LinkNode* next;
}LinkNode;


//链表结构体，用于维护链表整体的必要数据
typedef struct __LinkList
{
	LinkNode* pHeader;//链表头节点
	int m_size;//链表长度
}_LinkList;

LinkList* init_LinkList()
{
	LinkList* linklist = (LinkList*)malloc(sizeof(LinkList));
	LinkNode* pHeader = (LinkNode*)malloc(sizeof(LinkNode));
	if (!pHeader)
	{
		return NULL;
	}
	pHeader->data = NULL;//无用数据
	pHeader->next = NULL;
	((_LinkList*)linklist)->m_size = 0;
	((_LinkList*)linklist)->pHeader = pHeader;
	return linklist;
}


void foreach_LinkList(LinkList* _linklist, void(*myPrintf)(void*))
{
	_LinkList* linklist = _linklist;
	//参数校验
	if (!linklist || !linklist->pHeader||!myPrintf)
	{
		return;
	}
	printf("-------------------------------------------------\r\n");
	//遍历操作
	LinkNode* pCurrent = linklist->pHeader->next;
	while (pCurrent)
	{
		myPrintf(pCurrent->data);
		pCurrent = pCurrent->next;
	}
	printf("链表数量为%d\r\n", linklist->m_size);
	printf("-------------------------------------------------\r\n");
	printf("\r\n");
	
}

void append_LinkList(LinkList* _linklist, void* data)
{
	_LinkList* linklist = _linklist;
	//参数校验
	if (!linklist || !linklist->pHeader ||  !data)
	{
		return;
	}
	//申请空间并拷贝添加节点内存
	LinkNode* pAppend = (LinkNode*)malloc(sizeof(LinkNode));
	if (!pAppend)
	{
		return;
	}
	pAppend->data = data;
	//添加操作
	LinkNode* pCurrent = linklist->pHeader;
	while (pCurrent->next)
	{
		pCurrent = pCurrent->next;
	}
	pCurrent->next = pAppend;
	pAppend->next = NULL;
	linklist->m_size++;

}




void insert_LinkList(LinkList* _linklist, int pos, void* data)
{
	_LinkList* linklist = _linklist;
	//参数校验
	if ( !linklist||!linklist->pHeader || !data ||!linklist)
	{
		return;
	}
	if (pos < 0||pos> linklist->m_size)//无效位置,强制做尾插
	{
		pos = linklist->m_size;
	}
	//找到插入位置
	LinkNode* pCurrent = linklist->pHeader;
	int curPos = 0;
	while (pCurrent->next)
	{
		if (pos == curPos)
		{
			break;
		}
		pCurrent = pCurrent->next;
		curPos++;
	}


	//申请空间并拷贝插入节点内存
	LinkNode* pInsert = (LinkNode*)malloc(sizeof(LinkNode));
	if (!pInsert)
	{
		return;
	}
	pInsert->data = data;

	//插入操作
	pInsert->next = pCurrent->next;
	pCurrent->next = pInsert;
	linklist->m_size++;


}

void delete_LinkList(LinkList* _linklist, int pos)
{
	_LinkList* linklist = _linklist;
	if (!linklist || !linklist->pHeader)
	{
		return;
	}
	if (pos < 0 || pos>= linklist->m_size)
	{
		return;
	}
	//找到位置
	LinkNode* pCurrent = linklist->pHeader;
	int curPos = 0;
	while (pCurrent->next)
	{
		if (pos == curPos)
		{
			break;
		}
		pCurrent = pCurrent->next;
		curPos++;
	}
	//删除操作票
	if (!pCurrent->next)
	{
		return;
	}
	LinkNode* pNext = pCurrent->next->next;//临时储存后面链表
	free(pCurrent->next);
	pCurrent->next = pNext;
	linklist->m_size--;



}

void reverse_LinkList(LinkList* _linklist)
{
	_LinkList* linklist = _linklist;
	if (!linklist || !linklist->pHeader&&!linklist->pHeader->next)//排除链表没有或者只有一个的情况
	{
		return;
	}
	LinkNode* pCurrent = linklist->pHeader->next;
	LinkNode* pCurrentNext = pCurrent->next;
	LinkNode* pCurrentNextNext = NULL;
	while (pCurrentNext)//链表还有两个节点以上的时候
	{
		if (pCurrentNext->next)//链表还有第三个节点的时候，记录第三个节点,否则记录为NULL
		{
			pCurrentNextNext = pCurrentNext->next;
		}
		else
		{
			pCurrentNextNext = NULL;
		}
		//对前两个节点进行翻转操作
		pCurrentNext->next = pCurrent;
		//两指针后移一段
		pCurrent = pCurrentNext;
		pCurrentNext = pCurrentNextNext;
	}
	//跳出循环后pCurrent为尾节点指针,现将头节点指向的节点的next置空，然后头节点指针指向尾节点
	linklist->pHeader->next->next = NULL;
	linklist->pHeader->next = pCurrent;
}




void clear_LinkList(LinkList* _linklist)
{
	_LinkList* linklist = _linklist;
	if (!linklist || !linklist->pHeader)
	{
		return;
	}
	LinkNode* tmpCurrent = NULL;
	while (linklist->pHeader->next)
	{
		tmpCurrent = linklist->pHeader->next->next;
		free(linklist->pHeader->next);
		linklist->pHeader->next = tmpCurrent;
		tmpCurrent = NULL;
	}
	linklist->m_size=0;
}


void destroy_LinkList(LinkList** _linklist)
{
	_LinkList** linklist = _linklist;
	if (!*linklist || !(*linklist)->pHeader)
	{
		return;
	}
	LinkNode* tmpCurrent = NULL;
	LinkNode* pCurrent = (*linklist)->pHeader;
	while (pCurrent)
	{
		tmpCurrent = pCurrent->next;
		free(pCurrent);
		pCurrent = tmpCurrent;
	}
	(*linklist)->pHeader = NULL;
	if (!*linklist)
	{
		free(*linklist);
		*linklist = NULL;
	}
}


int getLength_LinkList(LinkList* _linklist)
{
	_LinkList* linklist = _linklist;
	if (!linklist|| !linklist->pHeader)
	{
		return 0;
	}
	return linklist->m_size;
}



```

## 受限线性表

### 栈(Stack)

Ø 概念：

> 首先它是一个线性表，也就是说，栈元素具有线性关系，即前驱后继关系。只不过***\*它是一种特殊的线性表\****而已。定义中说是在线性表的表尾进行插入和删除操作，这里表尾是指栈顶，而不是栈底。

***它的特殊之处在于限制了这个线性表的插入和删除的位置，它始终只在栈顶进行。这也就使得：栈底是固定的，最先进栈的只能在栈底。***（**先入后出**）

![img](https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8730.png)

栈顶：top 

#### 栈的作用**

##### **就近匹配**

当需要检测成对出现但又互不相邻的事物时可以使用栈“后进先出”的特性

括号匹配检测案例如下：

```c
//从第一个字符开始扫描
//--当遇见普通字符时忽略，
//--当遇见左括号时压入栈中
//--当遇见右括号时从栈中弹出栈顶符号，并进行匹配
//----匹配成功：继续读入下一个字符
//----匹配失败：立即停止，并报错
//结束：
//成功: 所有字符扫描完毕，且栈为空
//失败：匹配失败或所有字符扫描完毕但栈非空

void 利用栈判断字符串括号是否匹配_printfError(char* originStr,char* myErrorStr,char* p)
{
	printf("%s\r\n", myErrorStr);
	printf("--------------------[ErrorPos]-------------------\r\n");
	printf("%s\r\n",originStr);
	for (int i = 0; i < p-originStr; i++)
	{
		printf(" ");
	}
	printf("|\r\n");
	printf("-------------------------------------------------\r\n");
}


int 利用栈判断字符串括号是否匹配(char* str,char left,char right)
{
	if (left==right)
	{
		return 0;
	}
	if (!str)
	{
		return 0;
	}
	char* p = str;
	SeqStack stack = init_SeqStack();

	while (*p !=0)
	{
		if (*p== left)
		{
			push_SeqStack(stack, p);
		}
		if (*p== right)
		{
			if (size_SeqStack(stack)>0)
			{
				pop_SeqStack(stack);
			}
			else
			{
				利用栈判断字符串括号是否匹配_printfError(str,"多余右括号无匹配!",p);
				return 0;
			}
		}

		p++;
	}
	if (size_SeqStack(stack)==0)
	{
		return 1;//匹配
	}
	while (size_SeqStack(stack)>0)
	{
		利用栈判断字符串括号是否匹配_printfError(str, "多余左括号无匹配!", top_SeqStack(stack));
		pop_SeqStack(stack);
	}
	return 0;//不匹配
}
```

##### 中缀表达式转后缀表达式计算

功能：为了解决运算符优先度问题

**后缀表达式**（由波兰科学家在20世纪50年代提出）

将运算符放在数字后面，符合计算机运算

我们习惯的数学表达式叫做中缀表达式，符合人类思考习惯

```javascript
//中缀表达式=>后缀表达式
//符合人类思考习惯=>符合计算机运算
//如下：
5 + 4 => 5 4 +  
1 + 2 * 3 => 1 2 3 * +  
8 +( 3 – 1 ) * 5 => 8 3 1 – 5 * +
```

中缀转后缀算法案例:

```c
//遍历中缀表达式中的数字和符号：
//--对于数字：直接输出
//--对于符号：
//----左括号：进栈  
//----运算符号：与栈顶符号进行优先级比较
//------若栈顶符号优先级低：此符号进栈  
//--------（默认栈顶若是左括号，左括号优先级最低）
//------若栈顶符号优先级不低：将栈顶符号弹出并输出，之后进栈
//----右括号：将栈顶符号弹出并输出，直到匹配左括号,将左括号和右括号同时舍弃
//遍历结束：将栈中的所有符号弹出并输出

```

后缀计算出结果算法案例:

```c
//遍历后缀表达式中的数字和符号
//--对于数字：进栈
//--对于符号：
//----从栈中弹出右操作数
//----从栈中弹出左操作数
//----根据符号进行运算
//----将运算结果压入栈中
//遍历结束：栈中的唯一数字为计算结果

```

自己想出来的用双栈进行公式优先级计算的方法

```c
double 双浮点四则运算(double firstNum, double secondNum, char operator)
{
	switch (operator)
	{
	case '+':
		return firstNum + secondNum;
		break;
	case '-':
		return firstNum - secondNum;
		break;
	case '*':
		return firstNum * secondNum;
		break;
	case '/':
		return firstNum / secondNum;
		break;
	}
}

//只允许一个小数点，否则结果无意义,结果为精确到小数后6位
double 字符数组转小数(char* numStr)
{
	if (!numStr)
	{
		return 0;
	}
	int spotPos = -1;
	int i;
	for (i = 0; numStr[i] != '\0'; i++)
	{
		if (numStr[i] == '.')
		{
			spotPos = i;
		}
	}
	double answer = 0;
	if (spotPos != -1)//有小数点
	{
		int numWeight = spotPos - 1;
		for (int j = 0; numStr[j] != '\0'; j++)
		{
			if (numStr[j] == '.')
			{
				continue;
			}
			int tmp = numStr[j] - '0';
			answer += pow(10, numWeight)*tmp;


			numWeight--;
		}
	}
	else
	{
		int numWeight = i - 1;
		for (int j = 0; numStr[j] != '\0'; j++)
		{
			int tmp = numStr[j] - '0';
			answer += pow(10, numWeight)*tmp;
			numWeight--;
		}
	}
		return answer;
}

//对两个栈中单符号进行运算后将返回运算结果
double 双栈单符号运算(SeqStack numStack,SeqStack operatorStack)
{
	char topCh = *(char*)top_SeqStack(operatorStack);
	pop_SeqStack(operatorStack);
	double secondNum = *(double*)top_SeqStack(numStack);
	pop_SeqStack(numStack);
	double firstNum=0;
	if (top_SeqStack(numStack) != NULL)
	{
		firstNum = *(double*)top_SeqStack(numStack);
		pop_SeqStack(numStack);
	}
	return 双浮点四则运算(firstNum, secondNum, topCh);
}


//运算过程中允许使用的最大double类型空间使用个数
#define MAXALLOW 999

//若为符号  右括号，就近匹配左括号，将中间运算做完，将结果入数字栈
//第一个要解决的是多位数字问题
double 双栈公式计算法(char* formulas)
{
	if (!formulas)
	{
		return;
	}
	if (!利用栈判断字符串括号是否匹配(formulas, '(', ')'))//符号匹配校验
	{
		return;
	}
	
	int dIndex = 0;
	double dArray[MAXALLOW] = { 0 };
	SeqStack numStack = init_SeqStack();
	SeqStack operatorStack = init_SeqStack();
	dynamicChArray chArray = init_dynamicChArray(5);
	for (int i = 0; formulas[i] != '\0'; i++)
	{
		//////////////////////////////////////////////////////////////////////////此处思考解决多位数字
		if ((formulas[i] <= '9'&&formulas[i] >= '0')||(formulas[i] =='.'))//若为单个数字或者小数点，入数字字符动态数组(此处未规避非单小数点风险)
		{
			append_dynamicChArray(chArray, formulas[i]);
		}
		else//若为符号入栈
		{
			if (size_dynamicChArray(chArray)>0)//当遇到任意符号时将累积下来的数字字符转成小数入数字栈
			{
				if (dIndex < MAXALLOW)
				{
					dArray[dIndex] = 字符数组转小数(pChar_dynamicChArray(chArray));
					push_SeqStack(numStack, &dArray[dIndex]);
					clear_dynamicChArray(chArray);
					dIndex++;
				}
				else//溢出错误
					return;
			}
			//处理括号
			char tmpCh;
			char* top = top_SeqStack(operatorStack);
			//处理四则运算优先级
			//按照优先级，当栈顶是*，/而准备入栈的是+—的时候，直接运算*，/后再入栈
			if (top && (*top == '*' || *top == '/') && (formulas[i] == '+' || formulas[i] == '-'))
			{
				//结果的浮点数入数字栈
				dArray[dIndex] = 双栈单符号运算(numStack, operatorStack);
				push_SeqStack(numStack, &dArray[dIndex]);
				dIndex++;
				push_SeqStack(operatorStack, &formulas[i]);
			}
			else if (formulas[i] == ')')//遇到右括号，循环进行配对括号中所有计算
			{
				
				while ((tmpCh = *(char*)top_SeqStack(operatorStack)) != '(')//将符号栈中除了左括号之外的所有符号运算完
				{
					if (size_SeqStack(numStack) < 2)//并未具体针对（1）这样的给出解决方案
					{
						return;
					}
					dArray[dIndex] = 双栈单符号运算(numStack,operatorStack);
					push_SeqStack(numStack, &dArray[dIndex]);
					dIndex++;
				}
				pop_SeqStack(operatorStack);//弹出多余左括号
			}
			else 
				push_SeqStack(operatorStack, &formulas[i]);




		}

	}
	if (size_dynamicChArray(chArray) > 0)//当遇到任意符号时将累积下来的数字字符转成小数入数字栈(此处重复是为了避免数字封尾，最后的数字无法入数字栈)
	{
		if (dIndex < MAXALLOW)
		{
			dArray[dIndex] = 字符数组转小数(pChar_dynamicChArray(chArray));
			push_SeqStack(numStack, &dArray[dIndex]);
			clear_dynamicChArray(chArray);
			dIndex++;
		}
		else//溢出错误
			return;
	}



	//括号，*，/已经已全部剔除完毕情况的运算
	while (size_SeqStack(operatorStack) > 0)//符号栈非空
	{
		dArray[dIndex] = 双栈单符号运算(numStack,operatorStack);
		push_SeqStack(numStack, &dArray[dIndex]);
		dIndex++;
	}
	double answer = *(double*)top_SeqStack(numStack);
	//空间释放
	destroy_SeqStack(&numStack);
	destroy_SeqStack(&operatorStack);
	destroy_dynamicChArray(&chArray);
	return answer;
}
```





**栈主要是两种**

1. 栈的顺序存储（数组）

#### 栈的顺序存储案例

##### SeqStack.h顺序栈头文件

```c
/***************************************************** ************************* 
* @版权所有（c）2020，Peng，保留所有权利。 
* @文件路径:    C:\USERS\ADMINISTRATOR\DESKTOP\C语言学习案例（内含数据结构）\SEQSTACK\SeqStack.h 
* @版本：1.0版 
* @作者：Peng 
* @创建时间：2020 / 11 / 18 15：47 
* @文件描述： 顺序栈头文件
****************************************************** ************************/  
#pragma once


#define MAX_STACK_LENGHT 100



typedef void* SeqStack;


//初始化栈
SeqStack init_SeqStack();

//入栈
void push_SeqStack(SeqStack _stack,void* data);

//出栈
void pop_SeqStack(SeqStack _stack);

//返回栈顶
void* top_SeqStack(SeqStack _stack);

//返回栈大小
int size_SeqStack(SeqStack _stack);

//判断栈是否为空
int isEmpty_SeqStack(SeqStack _stack);

//销毁栈
void destroy_SeqStack(SeqStack* _stack);
```

##### SeqStack.c顺序栈源文件

```c
/***************************************************** ************************* 
* @版权所有（c）2020，Peng，保留所有权利。 
* @文件路径:    C:\USERS\ADMINISTRATOR\DESKTOP\C语言学习案例（内含数据结构）\SEQSTACK\SeqStack.c 
* @版本：1.0版 
* @作者：Peng 
* @创建时间：2020 / 11 / 18 15：46 
* @文件描述： 顺序栈源文件
****************************************************** ************************/  
#include "SeqStack.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//该结构体放在源文件中的目的是当把这个文件生成库文件时，可以避免用户直接在头文件中直接看到该结构的真实情况
typedef struct __SeqStack
{
	void* data[MAX_STACK_LENGHT];
	int m_Size;
}_SeqStack;


SeqStack init_SeqStack()
{
	_SeqStack* stack = (_SeqStack*)malloc(sizeof(_SeqStack));
	if (!stack)
	{
		return;
	}
	stack->m_Size = 0;
	memset(stack->data, NULL, MAX_STACK_LENGHT*sizeof(void*));
	return stack;

}


void push_SeqStack(SeqStack _stack, void* data)
{
	_SeqStack* stack = _stack;
	if (!stack||!data)
	{
		return;
	}
	if (stack->m_Size==MAX_STACK_LENGHT)//超出容量
	{
		return;
	}
	stack->data[stack->m_Size++] = data;
}


void pop_SeqStack(SeqStack _stack)
{
	_SeqStack* stack = _stack;
	if (!stack )
	{
		return;
	}
	stack->data[stack->m_Size--] = NULL;
}


void* top_SeqStack(SeqStack _stack)
{
	_SeqStack* stack = _stack;
	if (!stack )//无栈
	{
		return NULL;
	}
	if (stack->m_Size==0)//空栈
	{
		return NULL;
	}
	return stack->data[stack->m_Size - 1];
}


int size_SeqStack(SeqStack _stack)
{
	_SeqStack* stack = _stack;
	if (!stack)
	{
		return -1;
	}
	return stack->m_Size;
}



int isEmpty_SeqStack(SeqStack _stack)
{
	_SeqStack* stack = _stack;
	if (!stack)
	{
		return -1;
	}
	if (stack->m_Size==0)
	{
		return 1;
	}
	return 0;
}



void destroy_SeqStack(SeqStack* _stack)
{
	if (*_stack)
	{
		_SeqStack** stack = _stack;
		free(*stack);
		*stack = NULL;
	}
}
```

2. 栈的链式存储（链表）

#### 栈的链式存储案例

头节点做栈顶，利于压栈出栈的操作

##### LinkListStack.h链栈头文件

```c
/***************************************************** ************************* 
* @版权所有（c）2020，Peng，保留所有权利。 
* @文件路径:    C:\USERS\ADMINISTRATOR\DESKTOP\C语言学习案例（内含数据结构）\SEQSTACK\LinklistStack.h 
* @版本：1.0版 
* @作者：Peng 
* @创建时间：2020 / 11 / 20 14：24 
* @文件描述： 栈链头文件
****************************************************** ************************/  
#pragma once

typedef void* LStack;

//初始化栈
LStack init_LStack();

//入栈
void push_LStack(LStack _stack, void* data);

//出栈
void pop_LStack(LStack _stack);

//返回栈顶
void* top_LStack(LStack _stack);

//返回栈大小
int size_LStack(LStack _stack);

//判断栈是否为空
int isEmpty_LStack(LStack _stack);

//销毁栈
void destroy_LStack(LStack* _stack);
```

##### LinkListStack.c链栈源文件

```c
/***************************************************** ************************* 
* @版权所有（c）2020，Peng，保留所有权利。 
* @文件路径:    C:\USERS\ADMINISTRATOR\DESKTOP\C语言学习案例（内含数据结构）\SEQSTACK\LinklistStack.c 
* @版本：1.0版 
* @作者：Peng 
* @创建时间：2020 / 11 / 20 14：24 
* @文件描述： 栈链源文件
****************************************************** ************************/  
#include "LinklistStack.h"
#include <stdio.h>

typedef struct _LStackNode
{
	struct _LStackNode* next;
}LStackNode;


typedef struct __LStack
{
	LStackNode* pHeader;
	int m_size;
}_LStack;


LStack init_LStack()
{
	_LStack* stack = malloc(sizeof(_LStack));
	if (!stack)
	{
		return;
	}
	stack->pHeader = NULL;
	stack->m_size = 0;
	return stack;
}


void push_LStack(LStack _stack, void* data)
{
	_LStack* stack =_stack;
	LStackNode* pPush = data;
	if (!stack||!pPush)
	{
		return;
	}
	//入栈操作--链表头插
	pPush->next = stack->pHeader;
	stack->pHeader = pPush;
	stack->m_size++;
}

void pop_LStack(LStack _stack)
{
	_LStack* stack = _stack;
	if (!stack)
	{
		return;
	}
	//出栈操作--链表头删
	stack->pHeader = stack->pHeader->next;
	stack->m_size--;
}

void* top_LStack(LStack _stack)
{
	_LStack* stack = _stack;
	if (!stack)
	{
		return;
	}
	return stack->pHeader;
}


int size_LStack(LStack _stack)
{
	_LStack* stack = _stack;
	if (!stack)
	{
		return;
	}
	return stack->m_size;
}

int isEmpty_LStack(LStack _stack)
{
	_LStack* stack = _stack;
	if (!stack)
	{
		return -1;
	}
	if (stack->m_size)
	{
		return 0;
	}
	return 1;


}


void destroy_LStack(LStack* _stack)
{
	_LStack** stack = _stack;
	if (*stack)
	{
		free(*stack);
		*stack = NULL;
	}

}
```

### 队列(Queue)(发音和Q一样)

***队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。***

![img](https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8731.png)

队头元素：front             队尾元素：back             队列和栈一样不提供遍历功能

#### 队列的顺序存储案例(基于动态数组)

##### **顺序队列的头文件seqQueue.h**

```c
/***************************************************** ************************* 
* @版权所有（c）2020，Peng，保留所有权利。 
* @文件路径:    C:\USERS\ADMINISTRATOR\DESKTOP\C语言学习案例（内含数据结构）\队列案例\QUEUE\seqQueue.h 
* @版本：1.0版 
* @作者：Peng 
* @创建时间：2020 / 11 / 27 12：56 
* @文件描述： 顺序队列的头文件（引用了动态数组文件）
****************************************************** ************************/  
#pragma once

#define  INIT_CAPACITY 1024

typedef void* seqQueue;

//初始化顺序队列
seqQueue init_seqQueue();

//入队
void push_seqQueue(seqQueue queue,void* data);

//出队
void pop_seqQueue(seqQueue queue);

//队头
void* front_seqQueue(seqQueue queue);

//队尾
void* back_seqQueue(seqQueue queue);

//队内项数
int size_seqQueue(seqQueue queue);

//清空队列
void clear_seqQueue(seqQueue queue);

//是否空
int isEmpty_seqQueue(seqQueue queue);

//销毁队列
void destroy_seqQueue(seqQueue* queue);

//调试显示
void debugShow_seqQueue(seqQueue queue, void(*myPrintf)(void*));
```

##### 顺序队列的源文件seqQueue.c

```c
/***************************************************** ************************* 
* @版权所有（c）2020，Peng，保留所有权利。 
* @文件路径:    C:\USERS\ADMINISTRATOR\DESKTOP\C语言学习案例（内含数据结构）\队列案例\QUEUE\seqQueue.c 
* @版本：1.0版 
* @作者：Peng 
* @创建时间：2020 / 11 / 27 12：56 
* @文件描述： 顺序队列的源文件（引用了动态数组文件）
****************************************************** ************************/  
#include "dynamicArray.h"
#include "seqQueue.h"

seqQueue init_seqQueue()
{
	DynamicArray* array = init_DynamicArray(INIT_CAPACITY);
	return array;
}


void push_seqQueue(seqQueue queue, void* data)
{
	if (!queue||!data)
	{
		return;
	}
	DynamicArray* array = queue;
	insert_DynamicArray(queue, array->m_size, data);
}


void pop_seqQueue(seqQueue queue)
{
	if (!queue)
	{
		return;
	}
	DynamicArray* array = queue;
	if (array->m_size<=0)
	{
		return;
	}
	removeByPos_DynamicArray(queue, 0);
}

void* front_seqQueue(seqQueue queue)
{
	if (!queue)
	{
		return NULL;
	}
	DynamicArray* array = queue;
	return array->ArrayAddr[0];
}

void* back_seqQueue(seqQueue queue)
{
	if (!queue)
	{
		return NULL;
	}
	DynamicArray* array = queue;
	return array->ArrayAddr[array->m_size-1];
}


int size_seqQueue(seqQueue queue)
{
	if (!queue)
	{
		return -1;
	}
	DynamicArray* array = queue;
	return array->m_size;
}

void clear_seqQueue(seqQueue queue)
{
	if (!queue)
	{
		return;
	}
	clear_DynamicArray(queue);
}

int isEmpty_seqQueue(seqQueue queue)
{
	if (!queue)
	{
		return -1;
	}
	DynamicArray* array = queue;
	if (array->m_size==0)
	{
		return 1;
	}

	return 0;
}



void destroy_seqQueue(seqQueue* queue)
{
	if (!(*queue))
	{
		return;
	}
	destroy_DynamicArray(queue);
}

void debugShow_seqQueue(seqQueue queue, void(*myShow)(void*))
{
	if (!queue||!myShow)
	{
		return;
	}
	printf("-------------------------------------------------\r\n");
	printf("队头\r\n");
	foreach_DynamicArray(queue, myShow);
	printf("队尾\r\n");
	printf("-------------------------------------------------\r\n");
	
}
```

#### 队列的链式存储案例

##### 链队列的头文件LinkQueue.h

```c
/***************************************************** ************************* 
* @版权所有（c）2020，Peng，保留所有权利。 
* @文件路径:    C:\USERS\ADMINISTRATOR\DESKTOP\C语言学习案例（内含数据结构）\队列案例\QUEUE\LinkQueue.h 
* @版本：1.0版 
* @作者：Peng 
* @创建时间：2020 / 11 / 27 20：40 
* @文件描述：	链表队列头文件
****************************************************** ************************/  
#pragma once

typedef void* linkQueue;

//初始化
linkQueue init_linkQueue();

//入队列
void push_linkQueue(linkQueue _queue,void* data);

//出队列
void pop_linkQueue(linkQueue _queue);

//队头元素
void* front_linkQueue(linkQueue _queue);

//队尾元素
void* back_linkQueue(linkQueue _queue);

//队中项个数
int size_linkQueue(linkQueue _queue);

//是否空
int isEmpty_linkQueue(linkQueue _queue);

//清空队列
void clear_linkQueue(linkQueue _queue);

//销毁队列
void destroy_linkQueue(linkQueue* _queue);
```

##### 链队列的源文件LinkQueue.c

```c
/***************************************************** ************************* 
* @版权所有（c）2020，Peng，保留所有权利。 
* @文件路径:    C:\USERS\ADMINISTRATOR\DESKTOP\C语言学习案例（内含数据结构）\队列案例\QUEUE\LinkQueue.c 
* @版本：1.0版 
* @作者：Peng 
* @创建时间：2020 / 11 / 27 20：40 
* @文件描述： 链表队列源文件
****************************************************** ************************/  
#pragma once
#include "LinkQueue.h"
#include <stdlib.h>

typedef struct _QueueNode
{
	struct  QueueNode* next;
}QueueNode;

typedef struct __LinkQueue
{
	QueueNode* pHeader;//指向头元素
	QueueNode* pTail;//指向尾元素
	int m_size;
}_LinkQueue;


linkQueue init_linkQueue()
{
	_LinkQueue* queue = malloc(sizeof(_LinkQueue));
	if (!queue)
	{
		return NULL;
	}
	queue->m_size = 0;
	queue->pHeader = NULL;
	queue->pTail = NULL;
	return queue;
}

void push_linkQueue(linkQueue _queue, void* data)
{
	_LinkQueue* queue = _queue;
	QueueNode* node = data;
	if (!queue||!data)
	{
		return;
	}
	node->next = NULL;
	if (queue->m_size==0)//初始化
	{
		queue->pTail = node;
		queue->pHeader = node;
	}
	else
	{
		queue->pTail->next = node;
		queue->pTail = node;
	}
	queue->m_size++;
}


void pop_linkQueue(linkQueue _queue)
{
	_LinkQueue* queue = _queue;
	if (!queue)
	{
		return;
	}
	if (queue->m_size<=0)
	{
		return;
	}
	queue->pHeader = queue->pHeader->next;
	queue->m_size--;
	if (queue->m_size == 0)//唯一一个节点被删除的时候，尾节点重新变为空
	{
		queue->pTail = NULL;
	}
}

void* front_linkQueue(linkQueue _queue)
{
	_LinkQueue* queue = _queue;
	if (!queue)
	{
		return;
	}
	return queue->pHeader;
}


void* back_linkQueue(linkQueue _queue)
{
	_LinkQueue* queue = _queue;
	if (!queue)
	{
		return;
	}
	return queue->pTail;
}

int size_linkQueue(linkQueue _queue)
{
	_LinkQueue* queue = _queue;
	if (!queue)
	{
		return -1;
	}
	return queue->m_size;
}

int isEmpty_linkQueue(linkQueue _queue)
{
	_LinkQueue* queue = _queue;
	if (!queue)
	{
		return -1;
	}
	if (queue->m_size==0)
	{
		return 1;
	}
	return 0;
}

void clear_linkQueue(linkQueue _queue)
{
	_LinkQueue* queue = _queue;
	if (!queue)
	{
		return;
	}
	queue->pHeader = NULL;
	queue->pTail = NULL;
	queue->m_size = 0;
}

void destroy_linkQueue(linkQueue* _queue)
{
	_LinkQueue** queue = _queue;
	if (*queue)
	{
		free(*queue);
		*queue = NULL;
	}
}

debugShow_linkQueue(linkQueue _queue, void(*myShow)(void*))
{
	_LinkQueue* queue = _queue;
	if (!queue)
	{
		return;
	}
	printf("-------------------------------------------------\r\n");
	
	printf("队头\r\n");
	QueueNode* pCurrent = queue->pHeader;
	for (int i = 0; i < queue->m_size; i++)
	{
		myShow(pCurrent);
		pCurrent = pCurrent->next;
	}
	printf("队尾\r\n");
	printf("-------------------------------------------------\r\n");
}
```

## **树和二叉树**

**树的定义**：由一个或多个(n≥0)结点组成的有限集合T，有且仅有一个结点称为根（root），当n>1时，其余的结点分为***m(m≥0)个互不相交的有限集合***T1,T2，…，Tm。每个集合本身又是棵树，被称作这个根的子树 。

<img src="https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8732.png" alt="img" style="zoom:67%;" />

**树的结构特点：**

- 非线性结构，有一个直接前驱，但可能有多个直接后继（1:n）

- 树的定义具有递归性，树中还有树。

- 树可以为空，即节点个数为0。

- 根 ------ 即根结点(没有前驱)

- 叶子 ------ 即终端结点(没有后继)

- 森林 ------ 指m棵不相交的树的集合(例如删除A后的子树个数)

- 有序树 ------ 结点各子树从左至右有序，不能互换（左为第一）

- 无序树 ------ 结点各子树可互换位置。

- 双亲 ------ 即上层的那个结点(直接前驱) parent

- 孩子 ------ 即下层结点的子树 (直接后继) child

- 兄弟 ------ 同一双亲下的同层结点（孩子之间互称兄弟）sibling

- 堂兄弟 ------ 即双亲位于同一层的结点（但并非同一双亲）cousin

- 祖先 ------ 即从根到该结点所经分支的所有结点

- 子孙 ------ 即该结点下层子树中的任一结点

- 结点 ------ 即树的数据元素

- 结点的度 ------ 结点挂接的子树数（有几个直接后继就是几度）

- 结点的层次 ------ 从根到该结点的层数（根结点算第一层）  

- 终端结点 ------ 即度为0的结点，即叶子       

- 分支结点 ------ 除树根以外的结点（也称为内部结点）

- 树的度 ------ 所有结点度中的最大值（Max{各结点的度}）     

- 树的深度(或高度) ------ 指所有结点中最大的层数（Max{各结点的层次}）

  上图中的结点数＝ 13，树的度＝ 3，树的深度＝ 4

### 树的表示法

#### 图形表示法

**事物之间的逻辑关系**可以通过图的形式很直观的表示出来，如下图：

<img src="https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8733.png" alt="img" style="zoom:50%;" />

#### 广义表表示法

**根作为由子树森林组成的表的名字写在表的左边。**

<img src="https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8734.png" alt="img" style="zoom: 67%;" />

用广义表表示法表示上图：

```javascript
中国（河北（保定，石家庄），广东（广州，东莞），山东（青岛，济南））
```

#### 左孩子右兄弟表示法

<img src="F:%5C%E9%BB%91%E9%A9%AC%E5%B0%B1%E4%B8%9A%E7%8F%AD%5C01.C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%8F%AD%5C01-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E7%AC%AC01%E5%A4%A9%EF%BC%88helloworld%EF%BC%89%5C1-%E6%95%99%E5%AD%A6%E8%B5%84%E6%96%99%5C%E5%9B%BE%E7%89%8732.png" alt="img" style="zoom: 67%;" />

左孩子右兄弟表示法可以将一颗**多叉树**转化为一颗**二叉树**：

<img src="https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8735.png" alt="img" style="zoom: 67%;" />

左孩子右兄弟表示法节点的结构

<img src="https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8736.png"/>

节点有两个指针域，其中一个指针指向**子节点**，另一个指针指向其**兄弟节点**。

### **二叉树概念**

#### 二叉树基本概念

**定义：**n（n≥0）个结点的有限集合，由一个根结点以及两棵互不相交的、分别称为左子树和右子树的二叉树组成 。

**逻辑结构：**一对二（1：2） 

**基本特征:**	

- 每个结点最多只有两棵子树（**不存在度大于2的结点**）；
- 左子树和右子树次序不能颠倒（**有序树**）。

 **基本形态:**（最右边表示连根节点都没有的也算树）

![img](https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8737.png)

**二叉树性质**

- 性质1: 在二叉树的第i层上至多有2i-1个结点（i>0）
- 性质2: 深度为k的二叉树至多有2k-1个结点（k>0）
- 性质3: 对于任何一棵二叉树，若度为2的结点数有n2个，则叶子数（n0）必定为n2＋1 （即n0=n2+1）
- n 性质4: 具有n个结点的完全二叉树的深度必为log<sub>2</sub>n+1(log<sub>2</sub>n取整)***(***如 log2 (15)   点击 15  log  /  2  log =***)***
- 性质5: 对完全二叉树，若从上至下、从左至右编号，则编号为i 的结点，其左孩子编号必为2i，其右孩子编号必为2i＋1；其双亲的编号必为i/2（i＝1 时为根,除外）

使用性质5可以使用完全二叉树实现树的顺序存储。

<img src="https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8740.png" alt="img" style="zoom:67%;" />

如果不是完全二叉树咋整???

<img src="https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8741.png" alt="img" style="zoom:67%;" />

***缺点：①浪费空间；②插入、删除不便***

#### 概念解释

###### **满二叉树**

一棵深度为k 且有2k -1个结点的二叉树。

**特点：每层都“充满”了结点**

<img src="https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8738.png" alt="img" style="zoom:67%;" />

###### **完全二叉树**

除最后一层外，每一层上的[节点](http://baike.baidu.com/view/47398.htm)数均达到最大值；在最后一层上只缺少右边的若干[结点](http://baike.baidu.com/view/549491.htm)。

<img src="https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8739.png" alt="img" style="zoom:67%;" />

**理解：k-1层与满二叉树完全相同，第k层结点尽力靠左**

#### 二叉树的表示

##### 二叉链表示法

存储结构：

<img src="https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8742.png" alt="img" style="zoom: 50%;" />

结点数据类型定义：

```c
typedef struct BiTNode
{
	int		data;
	struct BiTNode *lchild, *rchild;
}BiTNode, *BiTree;
```



##### 三叉链表表示法

存储结构：

<img src="https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8743.png" alt="img" style="zoom:67%;" />

结点数据类型定义：

```c
//三叉链表
typedef struct TriTNode 
{
	int data;
	//左右孩子指针
	struct TriTNode *lchild, *rchild;
	struct TriTNode *parent;
}TriTNode, *TriTree;
```

#### 二叉树的遍历

Ø 遍历定义

指按某条搜索路线***遍访每个结点且不重复***（又称周游）。

Ø 遍历用途

它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。  

Ø 遍历方法

![img](https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8745.png)

- DLR — 先(根)序遍历，即先根再左再右
- LDR — 中(根)序遍历，即先左再根再右(此遍历方式正是按照顺序排序遍历)
- LRD — 后(根)序遍历，即先左再右再根

***注：“先、中、后”的意思是指访问的结点D是先于子树出现还是后于子树出现。***

***从递归的角度看，这三种算法是完全相同的，或者说这三种遍历算法的访问路径是相同的，只是访问结点的时机不同。***

<img src="https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8744.png" alt="img" style="zoom: 50%;" />

从虚线的出发点到终点的路径上，每个结点经过3次。

- ***第1次经过时访问＝先序遍历***
- ***第2次经过时访问＝中序遍历***
- ***第3次经过时访问＝后序遍历***

#### BTree.h头文件

```c
/***************************************************** ************************* 
* @版权所有（c）2020，Peng，保留所有权利。 
* @文件路径:    C:\USERS\ADMINISTRATOR\DESKTOP\C语言学习案例（内含数据结构）\二叉树案例\BTREE\BTree.h 
* @版本：1.0版 
* @作者：Peng 
* @创建时间：2020 / 12 / 04 20：46 
* @文件描述： 二叉树头文件
****************************************************** ************************/  
#pragma once

typedef struct _BTreeNode
{
	void* data;
	struct _BTreeNode *lchild, *rchild;
}BTreeNode,*PBTreeNode;

typedef struct __BTree
{
	PBTreeNode root;
	int m_size;
}_BTree,*PBTree;



typedef void* BTree;

typedef void* TreeNode;

//初始化二叉树
BTree init_BinaryTree();

//顺序插入
void insert_BinaryTree(BTree _tree,void* data, int(*myCompare)(void* myInsertData, void* TreeData));



//以下均为递归版对应功能的封装////////////////////////////////////////////
//先序遍历
void firstShow_BinaryTree(BTree _tree, void(*myShow)(void*));

//计算树的叶子节点个数
int calculateLeafNum_BinaryTree(BTree _tree);

//计算树的层数
int GetHeight_BinaryTree(BTree _tree);

//二叉树拷贝
BTree Copy_BinaryTree(BTree _tree);

//释放二叉树
void Release_BinaryTree(BTree* _tree);

//////////////////////////////////////////////////////////////////////////

//递归版先序遍历二叉树
void firstRecursionShow_BinaryTree(TreeNode root, void(*myShow)(void*));

//递归版中序遍历二叉树
void middleRecursionShow_BinaryTree(TreeNode root, void(*myShow)(void*));

//递归版后序遍历二叉树
void lastRecursionShow_BinaryTree(TreeNode root, void(*myShow)(void*));

//递归版计算树的叶子节点个数
void RecursionCalculateLeafNum_BinaryTree(TreeNode root, int* num);

//递归版计算树的层数
int RecursionGetHeight_BinaryTree(TreeNode root);

//递归版二叉树拷贝
TreeNode RecursionCopy_BinaryTree(TreeNode root);

//递归版释放二叉树
void RecursionRelease_BinaryTree(TreeNode* root);
```

#### BTree.c源文件

```c
/***************************************************** ************************* 
* @版权所有（c）2020，Peng，保留所有权利。 
* @文件路径:    C:\USERS\ADMINISTRATOR\DESKTOP\C语言学习案例（内含数据结构）\二叉树案例\BTREE\BTree.c 
* @版本：1.0版 
* @作者：Peng 
* @创建时间：2020 / 12 / 04 20：47 
* @文件描述： 二叉树源文件
****************************************************** ************************/  
#include "BTree.h"
#include <stdio.h>
#include <stdlib.h>

BTree init_BinaryTree()
{
	PBTree tree = malloc(sizeof(_BTree));
	if (!tree)
	{
		return NULL;
	}
	tree->m_size = 0;
	tree->root = NULL;
	return tree;
}

void insert_BinaryTree(BTree _tree,void* data,int(*myCompare)(void* myInsertData,void* TreeData))
{
	if (!_tree ||!data)
	{
		return;
	}
	PBTree tree = _tree;
	if (!tree->root)//空树
	{
		tree->root = malloc(sizeof(BTreeNode));
		if (!tree->root)
		{
			return;
		}
		tree->root->data = data;
		tree->root->lchild = NULL;
		tree->root->rchild = NULL;
		tree->m_size++;
	}
	else
	{
		PBTreeNode Pcurrent = tree->root;
		while (Pcurrent!=NULL)
		{
			if (myCompare(data,Pcurrent->data))//1表示插入左边
			{
				if (Pcurrent->lchild == NULL)//执行插入操作
				{
					Pcurrent->lchild = malloc(sizeof(BTreeNode));//未做成功校验
					Pcurrent->lchild->data = data;
					Pcurrent->lchild->lchild = NULL;
					Pcurrent->lchild->rchild = NULL;
					tree->m_size++;
					return;
				}
				Pcurrent = Pcurrent->lchild;
			}
			else
			{
				if (Pcurrent->rchild == NULL)//执行插入操作
				{
					Pcurrent->rchild = malloc(sizeof(BTreeNode));//未做成功校验
					Pcurrent->rchild->data = data;
					Pcurrent->rchild->lchild = NULL;
					Pcurrent->rchild->rchild = NULL;
					tree->m_size++;
					return;
				}
				Pcurrent = Pcurrent->rchild;
			}
		}
	}
}


void firstShow_BinaryTree(BTree _tree, void(*myShow)(void*))
{
	if (!_tree||!myShow)
	{
		return;
	}
	PBTree tree = _tree;
	firstRecursionShow_BinaryTree(tree->root, myShow);
}

int calculateLeafNum_BinaryTree(BTree _tree)
{
	if (!_tree )
	{
		return 0;
	}
	PBTree tree = _tree;
	int num = 0;
	RecursionCalculateLeafNum_BinaryTree(tree->root, &num);
	return num;
}

int GetHeight_BinaryTree(BTree _tree)
{
	if (!_tree)
	{
		return 0;
	}
	PBTree tree = _tree;
	int result = RecursionGetHeight_BinaryTree(tree->root);
}

BTree Copy_BinaryTree(BTree _tree)
{
	if (!_tree)
	{
		return NULL;
	}
	PBTree tree = _tree;
	PBTree newTree = malloc(sizeof(_BTree));
	if (!newTree)
	{
		return NULL;
	}
	newTree->m_size = tree->m_size;
	newTree->root = RecursionCopy_BinaryTree(tree->root);
	return newTree;
}


void Release_BinaryTree(BTree* _tree)
{
	if (!*_tree)
	{
		return;
	}
	PBTree tree = *_tree;
	if (tree->root)
	{
		RecursionRelease_BinaryTree(&tree->root);
	}
	if (tree)
	{
		free(tree);
		*_tree = NULL;
	}
}


void firstRecursionShow_BinaryTree(TreeNode root,void(*myShow)(void*))
{
	if (!root || !myShow)
	{
		return;
	}
	PBTreeNode tree = root;
	myShow(tree->data);
	firstRecursionShow_BinaryTree(tree->lchild, myShow);
	firstRecursionShow_BinaryTree(tree->rchild, myShow);
}

void middleRecursionShow_BinaryTree(TreeNode root, void(*myShow)(void*))
{
	if (!root || !myShow)
	{
		return;
	}
	PBTreeNode tree = root;
	middleRecursionShow_BinaryTree(tree->lchild, myShow);
	myShow(tree->data);
	middleRecursionShow_BinaryTree(tree->rchild, myShow);
}

void lastRecursionShow_BinaryTree(TreeNode root, void(*myShow)(void*))
{
	if (!root||!myShow)
	{
		return;
	}
	PBTreeNode tree = root;
	lastRecursionShow_BinaryTree(tree->lchild, myShow);
	lastRecursionShow_BinaryTree(tree->rchild, myShow);
	myShow(tree->data);
}


void RecursionCalculateLeafNum_BinaryTree(TreeNode root,int* num)
{
	if (!root||!num)
	{
		return;
	}
	PBTreeNode tree = root;
	if (!tree->lchild&&!tree->rchild)
	{
		(*num)++;
	}
	RecursionCalculateLeafNum_BinaryTree(tree->lchild, num);
	RecursionCalculateLeafNum_BinaryTree(tree->rchild, num);
}


int RecursionGetHeight_BinaryTree(TreeNode root)
{
	if (!root)
	{
		return 0;
	}
	PBTreeNode tree = root;
	int left = RecursionGetHeight_BinaryTree(tree->lchild);
	int right = RecursionGetHeight_BinaryTree(tree->rchild);
	return left > right ? left + 1 : right + 1;

}

TreeNode RecursionCopy_BinaryTree(TreeNode root)
{
	if (!root)
	{
		return NULL;
	}
	PBTreeNode oldTree = root;
	PBTree leftTree= RecursionCopy_BinaryTree(oldTree->lchild);
	PBTree rightTree = RecursionCopy_BinaryTree(oldTree->rchild);
	PBTreeNode newNode = malloc(sizeof(BTreeNode));
	newNode->data = oldTree->data;
	newNode->lchild = leftTree;
	newNode->rchild = rightTree;
	return newNode;
}

void RecursionRelease_BinaryTree(TreeNode* root)
{
	if (!(*root))
	{
		return;
	}
	PBTreeNode tree = *root;
	RecursionRelease_BinaryTree(&tree->lchild);
	RecursionRelease_BinaryTree(&tree->rchild);
	//最后释放根节点
	free(*root);
	*root = NULL;
}
```



# 排序算法

- 概念

排序是计算机内经常进行的一种操作，其目的是将一组“无序”的数据元素调整为“有序”的数据元素。

- 排序数学定义：

假设含n个数据元素的序列为{ R1, R2, …, Rn}，其相应的关键字序列为{ K1, K2, …, Kn}这些关键字相互之间可以进行比较，即在它们之间存在着这样一个关系 ：

Kp1≤Kp2≤…≤Kpn

按此固有关系将上式记录序列重新排列为{ Rp1, Rp2, …，Rpn}的操作称作排序

- 排序的稳定性

如果在序列中有两个数据元素r[i]和r[j]，它们的关键字k[i] == k [j]，且在排序之前，对象r[i]排在r[j]前面。如果在排序之后，对象r[i]仍在r[j]前面，则称这个排序方法是稳定的，否则称这个排序方法是不稳定的。

 <img src="https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8746.png" alt="img" style="zoom: 50%;" />

- 内排序和外排序
  1. 内排序：在排序过程中，待排序的所有记录全部都放置在内存中，排序分为：内排序和外排序。
  2. 外排序：由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行。

- 排序的审判
  1. 时间性能：关键性能差异体现在比较和交换的数量
  2. 辅助存储空间：为完成排序操作需要的额外的存储空间，必要时可以“空间换时间”
  3. 算法的实现复杂性：过于复杂的排序法会影响代码的可读性和可维护性，也可能影响排序的性能

- 总结
  1. 排序是数据元素从无序到有序的过程
  2. 排序具有稳定性，是选择排序算法的因素之一
  3. 比较和交换是排序的基本操作
  4. 多关键字排序与单关键字排序无本质区别
  5. 排序的时间性能是区分排序算法好坏的主要因素

### 冒泡排序

- 冒泡排序是一种效率低下的排序方法，在数据规模很小时，可以采用。数据规模比较大时，最好用其它排序方法。
- 上述例子对冒泡做了优化，添加了flag作为标记，记录序列是否已经有序，减少循环次数。

### 选择排序

<img src="https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%8747.png" alt="img"  />

### 插入排序

插入排序算法是一种简单的排序算法，也成为直接插入排序算法。它是一种稳定的排序算法，对局部有序的数据具有较高的效率。

插入排序算法是一个队少量元素进行排序的有效算法。比如，打牌是我们使用插入排序方法最多的日常生活例子。我们在摸牌时，一般会重复一下步骤。期初，我们手里没有牌，摸出第一张，随意放在左手上，以后每一次摸排，都会按照花色从小到大排列，直到所有的牌摸完。插入排序算法采用的类似思路，每一次从无序序列中拿出一个数据，将它放到已排序的序序列的正确位置，如此重复，直到所有的无序序列中的数据都找到了正确位置。



# 技术层次

![img](https://raw.githubusercontent.com/che77a38/blogImage/main/%E5%9B%BE%E7%89%877.png)

里奇最早的C语言是K&R  C

1989第一套标准是：ANSI C/C89标准（C语言的第一个官方标准）

C90标准，C94,C95（与C89完全等同）

C99标准（C语言的第二个官方标准）

- 增加了新关键字 restrict，inline，_Complex，_Imaginary，_Bool

- 支持 long long，long double _Complex，float _Complex 这样的类型

- 支持了不定长的数组。数组的长度就可以用变量了。声明类型的时候呢,就用 int a[*] 这样的写法。不过考虑到效率和实现，这玩意并不是一个新类型。

  

  

  **编程提示**

- 源代码的可读性几乎总是比程序的运行时效率更为重要

- 只要有可能，函数的指针形参都应该声明为const

- 在多维数组的初始值列表中使用完整的多层花括号提高可读性

# 常见报错：

## fatal error LNK1120: 1 个无法解析的外部命令

重点，.c后缀文件和.cpp文件后缀混着用，会导致此报错



# 待理解部分

浮点数转换为定点数的汇编表达方式

通过setwindowshookex hook onpaint的尾部消息





小知识点

如果调用的是另外一个DLL的导出函数，与正常调用没有差别。
如果调用的是被注入的EXE中的内部函数，则需要知道函数的地址。