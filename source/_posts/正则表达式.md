---
title: 正则表达式
tags: 正则表达式
categories: 技术
mathjax: true
abbrlink: 2f57a694
---



正则表达式是一个强大的文本匹配工具

<!-- more -->

	正则表达式是对字符串操作的一种逻辑公式,就是用事先定义好的一些特殊字符 ,及这些特殊字符的组合,组成一个"规则字符串",这个"规则字符串"用来表达对字符串的一种过滤逻辑

# 正则表达式基本语法

[学习正则表达式跳转参考](https://deerchao.cn/tutorials/regex/regex.htm)

[图形化展示正则表达式匹配流程](https://regexper.com/)

## 转义字符  

所有的ASCII码都可以用 `\` 加数字(一般是8进制数字)来表示.而C中定义了一些字母前加"\"来表示常见的哪些不能显示的ASCII字符,如 `\0`, ` \t `, ` \n ` 等.
如:
+ 表示ASCII  -> 大写字母M(ASCII十进制值为77)
	+ 用8进制表示为: `\0115`
	+ 用十六进制表示: `\x4d`
+ C语言中字符的转义
	+ `\a`   响铃
	+ `\b`   退格
	+ `\r`   回车
	+ `\n`   换行
	+ `\\`   代表一个反斜杠

正则表达式中使用的一些具备特殊含义的特殊字符(若要表示原本的字符则要加转义字符在前面)

`? + { } | ( ) [ ]`

## 限定符

> **表示匹配数量的字符**

- `?`  前面修饰的子表达式出现0次或者1次

  `?`  号同时作为**懒惰匹配**的标识符.如:`<.*?>`表示前面的`.*`为懒惰匹配,细节讲解参考下方

- `*` 前面修饰的子表达式出现0次或者多次

- `+` 前面修饰的子表达式出现1次或者多次

- `{n,m}` 前面修饰的子表达式出现n次到m次(`{n,}`为n到无穷次,`{n}`则表示为出现n次)

实例: `abc?d`可以匹配`abd`或`abcd`

所有限定符默认为**贪婪匹配**,**`?`** 才能标识**懒惰匹配**, `<.*?>` 针对 `<1>123<2>` 文本.匹配的是 `<1>` 和 `<2>`;若是 `<.*>` 则匹配为 `<1>123<2>`,为贪婪匹配

### 贪婪与懒惰匹配

默认为贪婪匹配,手动使用`?`设置懒惰匹配如下:

| 代码/语法 | 说明 | 
| --- | --- |
 | *? | 重复任意次，但尽可能少重复 |
 | +? | 重复1次或更多次，但尽可能少重复 |
| ?? | 重复0次或1次，但尽可能少重复 |
 | {n,m}? | 重复n到m次，但尽可能少重复 | 
| {n,}? | 重复n次以上，但尽可能少重复 |

## 界定限定符作用的子表达式范围

- `直接为单个字符` 作用于单个字符  
- `(字符串)` 作用于字符串,()里边的东西代表一个整体
- `[字符序列]` 字符组:作用于字符序列标识的多个字符之一 如`[abc]`匹配a,也匹配b   `[字符1字符2字符3]`相当于`(字符1|字符2|字符3)`   也可以作用为[a-zA-Z0-9]指的范围区间的任意一个字符
- `[^字符序列]`  匹配除了列出的字符序列以外的字符,正和上面相反

实例:

- `[^\x00-\xff] `匹配所有全角符号，包含全角标点和汉字韩文日文等等
- `[一-龥]`匹配所有汉字

或运算符:`|` 或符号

## 元字符

元字符:正则表达式中预先定义好了的一系列常用的字符类型

数字,空白符,单词开头,结尾

多大数元字符以反斜杠开头

- `\d` 数字字符
- `\w` 单词字符:包含英文,数字和下划线
- `\s` 空白符:tab和换行符
- `.` 不包含换行符之外的任意字符
- `\D` 非数字字符
- `\W` 非单词字符
- `\S` 非空白字符
- `\b` 表示单词边界,可以用于前或后,如:`/b单词/b`,这样可以防止匹配多余字符:单词的开头或结尾 单词与符号之前的边界
- `\B` 非单词的边界 符号与符号 单词与单词的边界

## 限定位置的字符

两个: `^` 和 ` $`

- `^` 匹配行首   `^a`  只匹配行首的a
	- `^hello`:要求第一个字符必须是h,后面必须是ello
	- `^(hello)`:要求必须以hello开头的hello   `hellohellohello` 只匹配第一个 `hello`
- `$` 匹配行尾   `a$`  只匹配行尾的a



# 进阶概念

高级概念:

捕获组,断言,递归,平衡组

## 捕获组

> 捕获组就是把正则表达式中子表达式匹配的内容，保存到内存中以数字编号或显式命名的组里，方便后面引用。当然，这种引用既可以是在正则表达式内部，也可以是在正则表达式外部。

捕获组有两种形式，一种是普通捕获组，另一种是命名捕获组，通常所说的捕获组指的是普通捕获组。语法如下：

- 普通捕获组：`(Expression)`
- 命名捕获组：`(?<name>Expression)`

> 普通捕获组在大多数支持正则表达式的语言或工具中都是支持的，而命名捕获组目前只有.NET、PHP、Python等部分语言支持，据说Java会在7.0中提供对这一特性的支持。上面给出的命名捕获组的语法是.NET中的语法，另外在.NET中使用`(?’name’Expression)`与使用`(?<name>Expression)`是等价的。在PHP和Python中命名捕获组语法为：`(?P<name>Expression)`。

### 编号规则

#### 普通捕获组编号规则

如果没有显式为捕获组命名，即没有使用命名捕获组，那么需要按数字顺序来访问所有捕获组。**在只有普通捕获组的情况下**，捕获组的编号是按照“(”出现的顺序，从左到右，从1开始进行编号的。

<img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2//202311261101097.png" alt="image-20231126110121764" style="zoom:50%;" />

**需要说明的是，编号为0的捕获组，指的是正则表达式整体**

#### 命名捕获组编号规则

> 命名捕获组通过显式命名，可以通过组名方便的访问到指定的组，而不需要去一个个的数编号，同时避免了在正则表达式扩展过程中，捕获组的增加或减少对引用结果导致的不可控。
>
> 不过容易忽略的是，命名捕获组也参与了编号的，**在只有命名捕获组的情况下**，捕获组的编号也是按照“(”出现的顺序，从左到右，从1开始进行编号的。

<img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2//202311261103780.png" alt="image-20231126110329139" style="zoom:50%;" />

#### 普通捕获组与命名捕获组混合编号规则

当一个正则表达式中，普通捕获组与命名捕获组混合出现时，捕获组的编号规则稍显复杂。对于其中的命名捕获组，随时都可以通过组名进行访问，而对于普通捕获组，则只能通过确定其编号后进行访问。

混合方式的捕获组编号，首先按照普通捕获组中“(”出现的先后顺序，从左到右，从1开始进行编号，当普通捕获组编号完成后，再按命名捕获组中“(”出现的先后顺序，从左到右，接着普通捕获组的编号值继续进行编号。

> 也就是先忽略命名捕获组，对普通捕获组进行编号，当普通捕获组完成编号后，再对命名捕获组进行编号。

<img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2//202311261105502.png" alt="image-20231126110517528" style="zoom:50%;" />

### 捕获组的引用

对捕获组的引用一般有以下几种：

1. 正则表达式中，对前面捕获组捕获的内容进行引用，称为[反向引用](#反向引用)
2. 正则表达式中，`(?(name)yes|no)`的条件判断结构
3. 在程序中，对捕获组捕获内容的引用

#### 反向引用

捕获组捕获到的内容，不仅可以在正则表达式外部通过程序进行引用，也可以在正则表达式内部进行引用，这种引用方式就是反向引用。

反向引用的作用通常是用来查找或限定重复，限定指定标识配对出现等等。

对于普通捕获组和命名捕获组的引用，语法如下：

- **普通捕获组反向引用**：`\k<number>`，通常简写为`\number`
- **命名捕获组反向引用**：`\k<name>`或者`\k'name'`

普通捕获组反向引用中number是十进制的数字，即捕获组的编号；命名捕获组反向引用中的name为命名捕获组的组名

# 简单案例

[常用正则表达式查询](https://www.jb51.net/tools/regexsc.htm)

- 用户名: `^[a-zA-Z0-9_-]{3,16}$`
- 时间(小时:分钟 24小时制): `((1|0?)[0-9]|2[0-3]):([0-5][0-9])`
- IP地址: `((2[0-4]\d | 25[0-5] | [01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)`

