---
title: 算法
tags: 算法
categories: 技术
abbrlink: b7e144d1
date: 2020-12-23 22:51:13
---

算法学习

<!-- more -->

[算法导论-麻省理工]: https://www.bilibili.com/video/BV1Tb411M7FA?from=search&amp;seid=12518312174180048412&amp;spm_id_from=333.337.0.0
[前人学习经验]: http://erdengk.top/archives/zuo-lao-shi-suan-fa-ke-xue-xi-jian-yi

# 算法入门

## 时间复杂度

**常数时间的操作：**一个操作如果和样本的数据量没有关系，每次都是固定时间内完成的操作，叫做**常数操作**

时间复杂度为一个算法流程中，常数操作数量的一个指标。常用O(读作big O)来表示。具体来说，先要对一个算法流程非常熟悉，然后去写出这个算法流程中，发生了多少常数操作，进而总结出常数操作数量的表达式。

表达式中，只要高阶项，不要低阶项的系数（阶：未知数的次方数），剩下的部分如果为f(N)，那么时间复杂度为O(f(N))。

**【评价一个算法流程的好坏】**:先看时间复杂度的指标，然后再分析不同数据样本下的实际运行时间，也就是“常数项时间”。

# 排序算法

- 概念

排序是计算机内经常进行的一种操作，其目的是将一组“无序”的数据元素调整为“有序”的数据元素。

- 排序数学定义：

假设含n个数据元素的序列为{ R1, R2, …, Rn}，其相应的关键字序列为{ K1, K2, …, Kn}这些关键字相互之间可以进行比较，即在它们之间存在着这样一个关系 ：

Kp1≤Kp2≤…≤Kpn

按此固有关系将上式记录序列重新排列为{ Rp1, Rp2, …，Rpn}的操作称作排序

- 排序的稳定性

如果在序列中有两个数据元素r[i]和r[j]，它们的关键字k[i] == k [j]，且在排序之前，对象r[i]排在r[j]前面。如果在排序之后，对象r[i]仍在r[j]前面，则称这个排序方法是稳定的，否则称这个排序方法是不稳定的。

 <img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/%E5%9B%BE%E7%89%8746.png" alt="img" style="zoom: 50%;" />

- 内排序和外排序
  1. 内排序：在排序过程中，待排序的所有记录全部都放置在内存中，排序分为：内排序和外排序。
  2. 外排序：由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行。

- 排序的审判
  1. 时间性能：关键性能差异体现在比较和交换的数量
  2. 辅助存储空间：为完成排序操作需要的额外的存储空间，必要时可以“空间换时间”
  3. 算法的实现复杂性：过于复杂的排序法会影响代码的可读性和可维护性，也可能影响排序的性能

- 总结
  1. 排序是数据元素从无序到有序的过程
  2. 排序具有稳定性，是选择排序算法的因素之一
  3. 比较和交换是排序的基本操作
  4. 多关键字排序与单关键字排序无本质区别
  5. 排序的时间性能是区分排序算法好坏的主要因素

### 冒泡排序

- 冒泡排序是一种效率低下的排序方法，在数据规模很小时，可以采用。数据规模比较大时，最好用其它排序方法。
- 上述例子对冒泡做了优化，添加了flag作为标记，记录序列是否已经有序，减少循环次数。

### 选择排序

<img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/%E5%9B%BE%E7%89%8747.png" alt="img"  />

### 插入排序

插入排序算法是一种简单的排序算法，也成为直接插入排序算法。它是一种稳定的排序算法，对局部有序的数据具有较高的效率。

插入排序算法是一个队少量元素进行排序的有效算法。比如，打牌是我们使用插入排序方法最多的日常生活例子。我们在摸牌时，一般会重复一下步骤。期初，我们手里没有牌，摸出第一张，随意放在左手上，以后每一次摸排，都会按照花色从小到大排列，直到所有的牌摸完。插入排序算法采用的类似思路，每一次从无序序列中拿出一个数据，将它放到已排序的序序列的正确位置，如此重复，直到所有的无序序列中的数据都找到了正确位置。







# 字符串匹配算法

## KMP算法

一种改进的字符串匹配算法,利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的,将时间复杂度从`O(m*n)`变成`O(m+n)`

**next数组**含义为存放子串对应下标前存在的最长相等前后缀的长度(相等前后缀不能是字符串本身)

[视频讲解跳转](https://www.bilibili.com/video/BV1AY4y157yL)

### 生成next数组函数

**[递推思维]**: 通过已经掌握的信息,来避免进行重复的运算

```c
//生成next数组(next数组含义为存放子串对应下标前存在的最长相等前后缀的长度)
void generateNext(char* str,int* next)
{
    int strLen = strlen(str);
    int prefixLocate = 0;//前缀末尾指针,也可以表示相等前后缀长度
    for (int i = 1; i < strLen; i++)//i表示准备填写的next数组下标,跳过0是因为kkmpSearch函数中针对0下标不使用next数组的值
    {
        if(str[i]==str[prefixLocate])//前后相等情况
        {
            prefixLocate++;
            next[i] = prefixLocate;//相等就将累计的相等前缀长度赋给next对应位置
            i++;
        }
        else//遇到前后不相等情况
        {
            if (prefixLocate == 0)//相等前后缀长度为0
            {
                next[i]=0;
                i++;
            }
            else//相等前后缀长度不为0,可以利用之前的相等前后缀递推
            {
                prefixLocate=next[prefixLocate-1];//递推思维的关键代码
            }
        }
    }
}
```

**更简洁的版本**

任何位置匹配到的同时+1,就继续匹配下一个,同时把当前匹配的数量写入next[i+1]

```cpp

void getNext(const char* pat,vector<int>& next)
{
    next[0] = -1;
    int i = 0, j = -1;
    while (i < strlen(pat) - 1) {
        if (j == -1 || pat[i] == pat[j]) {
            ++i;
            ++j;
            next[i] = j;
        }
        else {
            j = next[j];
        }
    }
}
```

### kmp搜索函数

借助于next数组

```c
int kmpSearch(char* str,char* subStr)
{
    //生成next数组
    int strLen = strlen(str);
    //std::cout<<"主串为:"<<str<<std::endl;
    //std::cout<<"主串长度为:"<<strLen<<std::endl;
    int subStrLen = strlen(subStr);
    //std::cout<<"子串为:"<<subStr<<std::endl;
    //std::cout<<"子串长度为:"<<subStrLen<<std::endl;
    int* next = new int[subStrLen];
    memset(next,0,subStrLen);
    generateNext(subStr,next); 
    //展示next数组=====================
    /*std::cout<<"分析得到的next数组为"<<std::endl;
    for (int i = 0; i < subStrLen; i++)
    {
        cout<<next[i]<<" ";
    }
    std::cout<<std::endl;*/
    //==================================
    //开始查找
    int j=0;//子串下标
    int i=0;//主串下标
   while(i<strLen)
   {
        //匹配的话,主串与子串下标相加
        if(subStr[j]==str[i])
        {
            i++;j++;
        }    
        else if(j>0)//子串非第一个就不匹配,更新子串下标
        {
            j = next[j-1];
        }
        else//子串第一个就不匹配
        {
            i++;
        }
        if(j==subStrLen)//全都相等就跳出循环,返回找到的下标
        {
            delete [] next;
            return i-j;
        }
   }
    delete [] next;
    return -1;
}
```

## BM算法

字符串匹配BM算法,全称是`Boyer-Moore`算法,其核心思想是:在模式串中某个字符与主串不能匹配的时候,将模式串往后**多滑动几位**,以此提高匹配的效率

为了能够一次性多滑动几位,在真正进行字符串匹配之前,先进行了一系列预处理操作,遵循 **坏字符规则** 和 **好后缀规则**

### 坏字符规则

按模式串倒序匹配的过程中,把匹配失败时主串中的字符,叫做坏字符,然后在模式串中查找坏字符,若找到匹配字符,则将模式串中的匹配字符和坏字符对齐,否则直接将模式串滑动到坏字符之后的一位,再重复进行上述过程.

把坏字符在模式串中的位置记为 si 值，如果 坏字符 在 模式串 中存在，将坏字符在模式串中的下标记作 xi 值，若不存在 xi 记作 -1，移动的位数就等于 si-xi 值。

把坏字符在模式串中的位置记为 si 值，如果 坏字符 在 模式串 中存在，将坏字符在模式串中的下标记作 xi 值，若不存在 xi 记作 -1，移动的位数就等于 si-xi 值。

注意：单纯采用坏字符的策略，计算出来的移动位数有可能是负数，因此 BM 算法还需要使用好后缀规则来避免这种情况。因此，**在该算法中可以省略坏字符规则，却不能省略好后缀规则。**

### 好后缀规则

按模式串 倒序匹配 过程中，失配点之后模式串中 匹配成功的那段字符-U ，为好后缀。好后缀规则在于，考虑能否根据 已经匹配成功 的字符，直接推算出下次移动的位置。

> 理论依据：如果 `好后缀-U` 在模式串找不到 另一个 匹配子串，只要 `U-整体` 还参与匹配，就肯定无法匹配，因为已经确定模式串中没有与和 `U-整体` 相同的字符串。但若 `U-的部分后缀` 和 `模式串的前缀` 有 重合 且相等，则有可能会完全匹配。



上图是 只 基于 好后缀规则 的匹配过程，涉及 后缀整体匹配 和 后缀子串和模式串前缀 的匹配。而下图则是 坏字符+好后缀 两种规则的匹配方式，具体选哪种取决于可移动的最大距离。

## Sunday算法

>   Sunday算法实际上是一种对BM算法的改进，其基本思路与BM算法相似。但是与BM算法不同的是，Sunday算法的比较是从模式串的开头进行比较的，并且Sunday算法在不匹配情况发生时，模式串跳转的幅度更大，所以从这一点上来说，Sunday算法的效率甚至比BM算法更高。

### 原理

从左到右比对,当发现比对失败时候(w),观察与模式串对齐的最后一位字符的下一位字符（本例中就是文本串中的D）是否出现在模式串中。

这一做法的意图是：如果文本串中，与模式串对齐位置上的下一位字符，也就是文本串中的D并没有出现在文本串中的话，那么就可以确定，从失配字符W向后，一直到字符D中间的这段内容与模式串肯定是不可能匹配了，所以我们可以直接跳过这段内容，直接将模式串跳转到字符D后面的位置进行对齐，然后重新开始比较。

<img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202304011925190.png" alt="image-20230401191518703" style="zoom: 50%;" />

  依然以上图为例，在进行模式串跳转之后，我们发现文本串中的_与模式串中的F首先就是不匹配的：

![image-20230401193314291](https://raw.githubusercontent.com/che77a38/blogImage2/main/202304011933178.png)

但是此时在文本串中，与模式串对齐的下一位字符T在模式串中出现过：

<img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202304011933817.png" alt="image-20230401193339668" style="zoom:50%;" />

  此时，我们将与模式串对齐的下一位字符与模式串中出现的位置对齐，然后继续进行比较：

<img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/202304011934699.png" alt="image-20230401193429201" style="zoom:50%;" />

### 编码

坏字表:记录了是否有某个字符(-1表示没有该字符),又记录了字符最后出现的位置.

```cpp
int sunday(const char *text, const char *pattern) {
	#define BASE 256
	int n = strlen(text), m, last_pos[BASE];
	//last_pos的每一个索引表示一个字符，因为字符本身就能通过ascll码表示为整数。
	//last_pos的值表示pattern中的元素在末尾的哪一位出现

	for (int i = 0; i < BASE; i++) last_pos[i] = -1; //初始化坏字表为-1
	for (m = 0; pattern[m]; m++) last_pos[pattern[m]] = m; //m为字串到\0的长度
	for (int i = 0; i + m <= n; i += (m - last_pos[text[i + m]])) {
		//如果没匹配成功，那么text的索引i向后移动 m - last_pos[text[i + m]] 位，m为模式串的长度

		int flag = 1;
		for (int j = 0; j < m; j++) {
			if (text[i + j] == pattern[j]) continue;
			flag = 0;
			break;
		}
		if (flag) return i;
	}
	return -1;
}
```

该算法也常用于特征码查询.(下面代码为[转载](https://blog.csdn.net/jinwei29/article/details/121265942),未测试)

```cpp
#include <iostream>
using namespace std;
#include <windows.h>
#include <psapi.h>
 #include <ctime>
 #include <string>
 #include<algorithm>
 std::string DeleteStringSpace(std::string str)
{
    str.erase(std::remove(str.begin(), str.end(), ' '), str.end()); // 删除所有空格
    return str;
}
 DWORD aobScan(HANDLE hProcess, HMODULE hModule, string 特征码,int CallOffset=0,DWORD* outCallAddre=0,int BaseAddreOffset=0, DWORD* outBaseAddr=0)
	{//进程PID，模块句柄，特征码，CallOffset：找call偏移-上负下正，BaseAddreOffset：找基址偏移；偏移是从特征码地址算起
		string tzm = DeleteStringSpace(特征码);//删除特征码所有空格
		int tzmLen = tzm.length() / 2;//特征码长度
		if (tzm.length() % 2 != 0)/*特征码长度不能为单数*/ return 0;
		byte* tzmByte = new byte[tzmLen];//定义一个字节变量并开辟指定长度的内存空间
		int 通配符首次位置 = StringToByte(tzm, tzmByte);
 
		MODULEINFO mMoudleInfo;
		GetModuleInformation(hProcess, hModule, &mMoudleInfo, sizeof(mMoudleInfo));
		DWORD  ModuleBeginAddr = (DWORD)hModule;//模块开始地址
		DWORD  ModuleSize =mMoudleInfo.SizeOfImage;//模块大小
		DWORD  ModuleEndAddr = ModuleBeginAddr + ModuleSize;//模块结束地址
 
		BYTE *pMemBuffer = NULL;//存放读取的内存数据的缓冲区		
		MEMORY_BASIC_INFORMATION mbi;//内存信息
		clock_t nBeginTime = clock();//记录起始搜索时间
 
		while (ModuleBeginAddr < ModuleEndAddr)//结束条件
		{//开始扫描内存
			memset(&mbi, 0, sizeof(MEMORY_BASIC_INFORMATION));//查询地址空间中内存地址的信息
			if (VirtualQueryEx(hProcess, (LPCVOID)ModuleBeginAddr, &mbi, sizeof(mbi)) == 0)break;;
			
			if (MEM_COMMIT == mbi.State && PAGE_READWRITE == mbi.Protect || PAGE_EXECUTE_READWRITE == mbi.Protect)
			{//过滤内存空间, 根据内存的状态和保护属性进行过滤
				if (pMemBuffer) {// 申请动态内存
					delete[] pMemBuffer; pMemBuffer = NULL;
				}
				pMemBuffer = new BYTE[mbi.RegionSize];
				if (!ReadProcessMemory(hProcess, (LPCVOID)ModuleBeginAddr, pMemBuffer, mbi.RegionSize, 0))continue;
				UINT deviation = SundayCmp(pMemBuffer, mbi.RegionSize, tzmByte, tzmLen, 通配符首次位置);
				if (-1 != deviation)//deviation是偏移
				{//-1为没有找到 
					clock_t nEndTime = clock();//记录结束时间
					printf(" %x  用时：%d 毫秒\r\n", ModuleBeginAddr + deviation, nEndTime - nBeginTime);
					if (0!=CallOffset)
					{//如果是找call
						DWORD temp; 
						memcpy(&temp, &pMemBuffer[deviation  + CallOffset + 1], 4);//拷贝出对应地址上的机器码，复制4个字节
						printf(" 返回call： %X  用时：%d 毫秒\r\n", ModuleBeginAddr + deviation+ CallOffset + temp +5, nEndTime - nBeginTime);
						*outCallAddre= ModuleBeginAddr + deviation + CallOffset + temp +5;//下一条指令地址(也就是目标地址 + 5)
					}
					if (0!=BaseAddreOffset)
					{//如果是找基址
						DWORD temp;
						memcpy(outBaseAddr, &pMemBuffer[deviation + BaseAddreOffset], 4);//拷贝出对应地址上的机器码，复制4个字节
						printf(" 返回基址： %X \r\n", outBaseAddr);//
					}
					return ModuleBeginAddr + deviation;//返回特征码地址
				}
			}
			ModuleBeginAddr += mbi.RegionSize; //取下一块内存地址
		}
		return -1;//没找到返回
	}
 
 
 int StringToByte(string &markCode,byte* pMarkCode)
	{//带通配符的string字符串转byte字节数组
		int markCodeLen = markCode.length() / 2;
		int 通配符第1次出现的位置 = 0;
		//pMarkCode = new BYTE[markCodeLen];
		for (int i = 0; i < markCodeLen; i++)
		{
			string tempStr = markCode.substr(i * 2, 2);
			if (tempStr == "??")
			{
				pMarkCode[i] = 0x3F;
				if (通配符第1次出现的位置 == 0) 通配符第1次出现的位置 = i;
			}
			else {
				pMarkCode[i] = strtoul(tempStr.c_str(), 0, 16);
			}
		}
		return 通配符第1次出现的位置;
	}
 
 int SundayCmp(byte* dest, int destLen, byte* pattern, int patternLen, int 通配符第1次出现的位置)
	{
		int nOffset = 0;//偏移量
		int i = 0, j = 0, nCount = 0;//数组下标：内存、特征码、返回地址
 
		int Shift[0xFF + 1] = { 0 };//Sunday算法模板数组赋值，+1防止特征码出现FF时越界
		for (int i = 0; i < 通配符第1次出现的位置; i++) {
			Shift[pattern[i]] = i + 1;
		}
 
		while (j < patternLen)
		{//以特征码长度进行循环
			if (dest[i] == pattern[j] || pattern[j] == 0x3F)//0x3F代表通配符
			{//如果相等
				i++; j++;
			}
			else
			{
				nOffset = i - j + 通配符第1次出现的位置;
				if (nOffset > destLen - patternLen)/*判断偏移量是否大于缓冲区*/ break;
				if (Shift[dest[nOffset]])
				{//判断 Shift模板数组 里有没有 内存偏移后的值，有则回溯，否则+1
					i = nOffset - Shift[dest[nOffset]] + 1;
					j = 0;
				}
				else
				{
					i = nOffset + 1;
					j = 0;
				}
			}
		}
		if (j == patternLen)
		{//计算找到的目标地址：//特征码地址 = 当前内存块基址 + i偏移 - 特征码长度
			return  i - patternLen;
		}
		return -1;
	}
```

