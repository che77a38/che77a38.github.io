---
title: 算法
date: 2020-12-23 22:51:13
tags: 算法
categories: 技术

---

算法学习

<!-- more -->

[算法导论-麻省理工]: https://www.bilibili.com/video/BV1Tb411M7FA?from=search&amp;seid=12518312174180048412&amp;spm_id_from=333.337.0.0
[前人学习经验]: http://erdengk.top/archives/zuo-lao-shi-suan-fa-ke-xue-xi-jian-yi

# 算法入门

## 时间复杂度

**常数时间的操作：**一个操作如果和样本的数据量没有关系，每次都是固定时间内完成的操作，叫做**常数操作**

时间复杂度为一个算法流程中，常数操作数量的一个指标。常用O(读作big O)来表示。具体来说，先要对一个算法流程非常熟悉，然后去写出这个算法流程中，发生了多少常数操作，进而总结出常数操作数量的表达式。

表达式中，只要高阶项，不要低阶项的系数（阶：未知数的次方数），剩下的部分如果为f(N)，那么时间复杂度为O(f(N))。

**【评价一个算法流程的好坏】**:先看时间复杂度的指标，然后再分析不同数据样本下的实际运行时间，也就是“常数项时间”。



# 排序算法

- 概念

排序是计算机内经常进行的一种操作，其目的是将一组“无序”的数据元素调整为“有序”的数据元素。

- 排序数学定义：

假设含n个数据元素的序列为{ R1, R2, …, Rn}，其相应的关键字序列为{ K1, K2, …, Kn}这些关键字相互之间可以进行比较，即在它们之间存在着这样一个关系 ：

Kp1≤Kp2≤…≤Kpn

按此固有关系将上式记录序列重新排列为{ Rp1, Rp2, …，Rpn}的操作称作排序

- 排序的稳定性

如果在序列中有两个数据元素r[i]和r[j]，它们的关键字k[i] == k [j]，且在排序之前，对象r[i]排在r[j]前面。如果在排序之后，对象r[i]仍在r[j]前面，则称这个排序方法是稳定的，否则称这个排序方法是不稳定的。

 <img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/%E5%9B%BE%E7%89%8746.png" alt="img" style="zoom: 50%;" />

- 内排序和外排序
  1. 内排序：在排序过程中，待排序的所有记录全部都放置在内存中，排序分为：内排序和外排序。
  2. 外排序：由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行。

- 排序的审判
  1. 时间性能：关键性能差异体现在比较和交换的数量
  2. 辅助存储空间：为完成排序操作需要的额外的存储空间，必要时可以“空间换时间”
  3. 算法的实现复杂性：过于复杂的排序法会影响代码的可读性和可维护性，也可能影响排序的性能

- 总结
  1. 排序是数据元素从无序到有序的过程
  2. 排序具有稳定性，是选择排序算法的因素之一
  3. 比较和交换是排序的基本操作
  4. 多关键字排序与单关键字排序无本质区别
  5. 排序的时间性能是区分排序算法好坏的主要因素

### 冒泡排序

- 冒泡排序是一种效率低下的排序方法，在数据规模很小时，可以采用。数据规模比较大时，最好用其它排序方法。
- 上述例子对冒泡做了优化，添加了flag作为标记，记录序列是否已经有序，减少循环次数。

### 选择排序

<img src="https://raw.githubusercontent.com/che77a38/blogImage2/main/%E5%9B%BE%E7%89%8747.png" alt="img"  />

### 插入排序

插入排序算法是一种简单的排序算法，也成为直接插入排序算法。它是一种稳定的排序算法，对局部有序的数据具有较高的效率。

插入排序算法是一个队少量元素进行排序的有效算法。比如，打牌是我们使用插入排序方法最多的日常生活例子。我们在摸牌时，一般会重复一下步骤。期初，我们手里没有牌，摸出第一张，随意放在左手上，以后每一次摸排，都会按照花色从小到大排列，直到所有的牌摸完。插入排序算法采用的类似思路，每一次从无序序列中拿出一个数据，将它放到已排序的序序列的正确位置，如此重复，直到所有的无序序列中的数据都找到了正确位置。









# KMP算法

一种改进的字符串匹配算法,利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的,将时间复杂度从`O(m*n)`变成`O(m+n)`

**next数组**含义为存放子串对应下标前存在的最长相等前后缀的长度(相等前后缀不能是字符串本身)

[视频讲解跳转](https://www.bilibili.com/video/BV1AY4y157yL)

## 生成next数组函数

**[递推思维]**: 通过已经掌握的信息,来避免进行重复的运算

```c
//生成next数组(next数组含义为存放子串对应下标前存在的最长相等前后缀的长度)
void generateNext(char* str,int* next)
{
    int strLen = strlen(str);
    int prefixLocate = 0;//前缀末尾指针,也可以表示相等前后缀长度
    for (int i = 1; i < strLen; i++)//i表示准备填写的next数组下标,跳过0是因为kkmpSearch函数中针对0下标不使用next数组的值
    {
        if(str[i]==str[prefixLocate])//前后相等情况
        {
            prefixLocate++;
            next[i] = prefixLocate;//相等就将累计的相等前缀长度赋给next对应位置
            i++;
        }
        else//遇到前后不相等情况
        {
            if (prefixLocate == 0)//相等前后缀长度为0
            {
                next[i]=0;
                i++;
            }
            else//相等前后缀长度不为0,可以利用之前的相等前后缀递推
            {
                prefixLocate=next[prefixLocate-1];//递推思维的关键代码
            }
        }
    }
}
```

## kmp搜索函数

借助于next数组

```c
int kmpSearch(char* str,char* subStr)
{
    //生成next数组
    int strLen = strlen(str);
    //std::cout<<"主串为:"<<str<<std::endl;
    //std::cout<<"主串长度为:"<<strLen<<std::endl;
    int subStrLen = strlen(subStr);
    //std::cout<<"子串为:"<<subStr<<std::endl;
    //std::cout<<"子串长度为:"<<subStrLen<<std::endl;
    int* next = new int[subStrLen];
    memset(next,0,subStrLen);
    generateNext(subStr,next); 
    //展示next数组=====================
    /*std::cout<<"分析得到的next数组为"<<std::endl;
    for (int i = 0; i < subStrLen; i++)
    {
        cout<<next[i]<<" ";
    }
    std::cout<<std::endl;*/
    //==================================
    //开始查找
    int j=0;//子串下标
    int i=0;//主串下标
   while(i<strLen)
   {
        //匹配的话,主串与子串下标相加
        if(subStr[j]==str[i])
        {
            i++;j++;
        }    
        else if(j>0)//子串非第一个就不匹配,更新子串下标
        {
            j = next[j-1];
        }
        else//子串第一个就不匹配
        {
            i++;
        }
        if(j==subStrLen)//全都相等就跳出循环,返回找到的下标
        {
            delete [] next;
            return i-j;
        }
   }
    delete [] next;
    return -1;
}
```

