---
title: 算法
tags: 算法
categories: 技术
abbrlink: b7e144d1
mathjax: true
date: 2020-12-23 22:51:13
---

算法学习

<!-- more -->

[算法导论-麻省理工]: https://www.bilibili.com/video/BV1Tb411M7FA?from=search&amp;seid=12518312174180048412&amp;spm_id_from=333.337.0.0
[前人学习经验]: http://erdengk.top/archives/zuo-lao-shi-suan-fa-ke-xue-xi-jian-yi

# 算法入门

## 时间复杂度

<img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2//202312182212066.png" alt="image-20231218221243795" style="zoom: 25%;" />

> 时间复杂度是衡量算法执行时间的一个指标，它表示算法运行时间随输入规模增长的趋势。通常使用大O符号表示，描述算法在输入规模增大时的渐进行为。
> 
> 举个例子，冒泡排序算法的时间复杂度是 $O(n^2)$，这意味着算法的运行时间与输入规模的平方成正比。也就是说，当输入规模翻倍时，算法的运行时间会变为原来的四倍。
> 
> 时间复杂度可以有多种不同的衡量方式。一种常见的方式是计算算法执行的操作次数。另一种方式是测量算法在特定计算机上运行所需的时间。
> 
> 时间复杂度在算法设计中非常重要，因为它可以帮助确定算法的效率。时间复杂度较高的算法可能不适用于大规模数据集，因为它们可能需要太长的运行时间。
> 
> 有许多技巧可以改善算法的时间复杂度。一种常见的方法是使用分治策略，将问题分解为更小的子问题，以便更高效地解决。另一种方法是使用动态规划，将子问题的结果存储起来，避免重复计算。
> 
> 时间复杂度是一个复杂的主题，没有一种通用的方法适用于所有算法。然而，通过了解不同的时间复杂度衡量方式，并使用适当的技巧改善算法的时间复杂度，可以设计出适用于各种问题的高效算法。

**常数时间的操作：**一个操作如果和样本的数据量没有关系，每次都是固定时间内完成的操作，叫做**常数操作**

时间复杂度为一个算法流程中，常数操作数量的一个指标。常用O(读作big O)来表示。具体来说，先要对一个算法流程非常熟悉，然后去写出这个算法流程中，发生了多少常数操作，进而总结出常数操作数量的表达式。

表达式中，只要高阶项，不要低阶项的系数（阶：未知数的次方数），剩下的部分如果为f(N)，那么时间复杂度为O(f(N))。

**【评价一个算法流程的好坏】**:先看时间复杂度的指标，然后再分析不同数据样本下的实际运行时间，也就是“常数项时间”。

## 空间复杂度

与时间复杂度相似,但针对空间

# 排序算法

- 概念

排序是计算机内经常进行的一种操作，其目的是将一组“无序”的数据元素调整为“有序”的数据元素。

- 排序数学定义：

假设含n个数据元素的序列为{ R1, R2, …, Rn}，其相应的关键字序列为{ K1, K2, …, Kn}这些关键字相互之间可以进行比较，即在它们之间存在着这样一个关系 ：

Kp1≤Kp2≤…≤Kpn

按此固有关系将上式记录序列重新排列为{ Rp1, Rp2, …，Rpn}的操作称作排序

- 排序的稳定性

如果在序列中有两个数据元素r[i]和r[j]，它们的关键字k[i] == k [j]，且在排序之前，对象r[i]排在r[j]前面。如果在排序之后，对象r[i]仍在r[j]前面，则称这个排序方法是稳定的，否则称这个排序方法是不稳定的。

 <img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/%E5%9B%BE%E7%89%8746.png" alt="img" style="zoom: 50%;" />

- 内排序和外排序
  1. 内排序：在排序过程中，待排序的所有记录全部都放置在内存中，排序分为：内排序和外排序。
  2. 外排序：由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行。
- 排序的审判
  1. 时间性能：关键性能差异体现在比较和交换的数量
  2. 辅助存储空间：为完成排序操作需要的额外的存储空间，必要时可以“空间换时间”
  3. 算法的实现复杂性：过于复杂的排序法会影响代码的可读性和可维护性，也可能影响排序的性能
- 总结
  1. 排序是数据元素从无序到有序的过程
  2. 排序具有稳定性，是选择排序算法的因素之一
  3. 比较和交换是排序的基本操作
  4. 多关键字排序与单关键字排序无本质区别
  5. 排序的时间性能是区分排序算法好坏的主要因素

比较具备优势的排序算法:

1. 快速排序（Quick Sort）：快速排序是一种基于分治思想的排序算法，通过选择一个基准元素，将数组分为两个子数组，并递归地对子数组进行排序。快速排序的平均时间复杂度为O(nlogn)，在大多数情况下具有较高的效率。(快速排序与下文的排序算法不是一个东西)
2. 归并排序（Merge Sort）：归并排序也是一种分治算法，它将数组递归地分成两个子数组，然后将两个有序子数组合并成一个有序数组。归并排序的时间复杂度为O(nlogn)，并且具有稳定性。
3. 堆排序（Heap Sort）：堆排序利用堆这种数据结构进行排序，通过构建最大堆或最小堆来实现排序。堆排序的时间复杂度为O(nlogn)，并且具有**原地排序**的特点。

需要注意的是，这些算法的性能取决于输入数据的规模和特征。对于小规模的数据集，简单的排序算法如插入排序和冒泡排序可能更高效。对于已经部分有序的数据集，插入排序和冒泡排序也可能比其他算法更快。

C++标准库中的`std::sort`函数使用了一种高效的排序算法（通常是快速排序或归并排序）

### 冒泡排序

- 冒泡排序是一种效率低下的排序方法，在数据规模很小时，可以采用。数据规模比较大时，最好用其它排序方法。
- 上述例子对冒泡做了优化，添加了flag作为标记，记录序列是否已经有序，减少循环次数。

### 选择排序

<img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/%E5%9B%BE%E7%89%8747.png" alt="img"  />

### 插入排序

插入排序算法是一种简单的排序算法，也成为直接插入排序算法。它是一种稳定的排序算法，对局部有序的数据具有较高的效率。

插入排序算法是一个队少量元素进行排序的有效算法。比如，打牌是我们使用插入排序方法最多的日常生活例子。我们在摸牌时，一般会重复一下步骤。期初，我们手里没有牌，摸出第一张，随意放在左手上，以后每一次摸排，都会按照花色从小到大排列，直到所有的牌摸完。插入排序算法采用的类似思路，每一次从无序序列中拿出一个数据，将它放到已排序的序序列的正确位置，如此重复，直到所有的无序序列中的数据都找到了正确位置。

# 查找算法

## 二分查找

**无重复元素** 的 **升序** 排列数组中的插入查找

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

```cpp
int searchInsert(vector<int> &nums, int target)
    {
        int left = 0, right = nums.size() - 1;
        while (left <= right)
        {
            int mid = left + (right - left) / 2;

            if (nums[mid] == target)
                return mid;
            else if (nums[mid] < target)
                left = mid + 1;//灵魂就在于这个+1和下面的-1
            else
                right = mid - 1;
        }
        return left;
    }
```

- 时间复杂度：O(log⁡n)，其中 n 为数组的长度。二分查找所需的时间复杂度为 O(log⁡n)
- 空间复杂度：O(1)。我们只需要常数空间存放若干变量

# 字符串匹配算法

## KMP算法

一种改进的字符串匹配算法,利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的,将时间复杂度从`O(m*n)`变成`O(m+n)`

**next数组**含义为存放子串对应下标前存在的最长相等前后缀的长度(相等前后缀不能是字符串本身)

![视频讲解跳转|720x360](https://www.bilibili.com/video/BV1AY4y157yL)

### 生成next数组函数

**[递推思维]**: 通过已经掌握的信息,来避免进行重复的运算

```c
//生成next数组(next数组含义为存放子串对应下标前存在的最长相等前后缀的长度)
void generateNext(char* str,int* next)
{
    int strLen = strlen(str);
    int prefixLocate = 0;//前缀末尾指针,也可以表示相等前后缀长度
    for (int i = 1; i < strLen; i++)//i表示准备填写的next数组下标,跳过0是因为kkmpSearch函数中针对0下标不使用next数组的值
    {
        if(str[i]==str[prefixLocate])//前后相等情况
        {
            prefixLocate++;
            next[i] = prefixLocate;//相等就将累计的相等前缀长度赋给next对应位置
            i++;
        }
        else//遇到前后不相等情况
        {
            if (prefixLocate == 0)//相等前后缀长度为0
            {
                next[i]=0;
                i++;
            }
            else//相等前后缀长度不为0,可以利用之前的相等前后缀递推
            {
                prefixLocate=next[prefixLocate-1];//递推思维的关键代码
            }
        }
    }
}
```

**更简洁的版本**

任何位置匹配到的同时+1,就继续匹配下一个,同时把当前匹配的数量写入next[i+1]

```cpp

void getNext(const char* pat,vector<int>& next)
{
    next[0] = -1;
    int i = 0, j = -1;
    while (i < strlen(pat) - 1) {
        if (j == -1 || pat[i] == pat[j]) {
            ++i;
            ++j;
            next[i] = j;
        }
        else {
            j = next[j];
        }
    }
}
```

### kmp搜索函数

借助于next数组

```c
int kmpSearch(char* str,char* subStr)
{
    //生成next数组
    int strLen = strlen(str);
    //std::cout<<"主串为:"<<str<<std::endl;
    //std::cout<<"主串长度为:"<<strLen<<std::endl;
    int subStrLen = strlen(subStr);
    //std::cout<<"子串为:"<<subStr<<std::endl;
    //std::cout<<"子串长度为:"<<subStrLen<<std::endl;
    int* next = new int[subStrLen];
    memset(next,0,subStrLen);
    generateNext(subStr,next); 
    //展示next数组=====================
    /*std::cout<<"分析得到的next数组为"<<std::endl;
    for (int i = 0; i < subStrLen; i++)
    {
        cout<<next[i]<<" ";
    }
    std::cout<<std::endl;*/
    //==================================
    //开始查找
    int j=0;//子串下标
    int i=0;//主串下标
   while(i<strLen)
   {
        //匹配的话,主串与子串下标相加
        if(subStr[j]==str[i])
        {
            i++;j++;
        }    
        else if(j>0)//子串非第一个就不匹配,更新子串下标
        {
            j = next[j-1];
        }
        else//子串第一个就不匹配
        {
            i++;
        }
        if(j==subStrLen)//全都相等就跳出循环,返回找到的下标
        {
            delete [] next;
            return i-j;
        }
   }
    delete [] next;
    return -1;
}
```

## BM算法

字符串匹配BM算法,全称是`Boyer-Moore`算法,其核心思想是:在模式串中某个字符与主串不能匹配的时候,将模式串往后**多滑动几位**,以此提高匹配的效率

为了能够一次性多滑动几位,在真正进行字符串匹配之前,先进行了一系列预处理操作,遵循 **坏字符规则** 和 **好后缀规则**

### 坏字符规则

按模式串倒序匹配的过程中,把匹配失败时主串中的字符,叫做坏字符,然后在模式串中查找坏字符,若找到匹配字符,则将模式串中的匹配字符和坏字符对齐,否则直接将模式串滑动到坏字符之后的一位,再重复进行上述过程.

把坏字符在模式串中的位置记为 si 值，如果 坏字符 在 模式串 中存在，将坏字符在模式串中的下标记作 xi 值，若不存在 xi 记作 -1，移动的位数就等于 si-xi 值。

把坏字符在模式串中的位置记为 si 值，如果 坏字符 在 模式串 中存在，将坏字符在模式串中的下标记作 xi 值，若不存在 xi 记作 -1，移动的位数就等于 si-xi 值。

注意：单纯采用坏字符的策略，计算出来的移动位数有可能是负数，因此 BM 算法还需要使用好后缀规则来避免这种情况。因此，**在该算法中可以省略坏字符规则，却不能省略好后缀规则。**

### 好后缀规则

按模式串 倒序匹配 过程中，失配点之后模式串中 匹配成功的那段字符-U ，为好后缀。好后缀规则在于，考虑能否根据 已经匹配成功 的字符，直接推算出下次移动的位置。

> 理论依据：如果 `好后缀-U` 在模式串找不到 另一个 匹配子串，只要 `U-整体` 还参与匹配，就肯定无法匹配，因为已经确定模式串中没有与和 `U-整体` 相同的字符串。但若 `U-的部分后缀` 和 `模式串的前缀` 有 重合 且相等，则有可能会完全匹配。



上图是 只 基于 好后缀规则 的匹配过程，涉及 后缀整体匹配 和 后缀子串和模式串前缀 的匹配。而下图则是 坏字符+好后缀 两种规则的匹配方式，具体选哪种取决于可移动的最大距离。

## Sunday算法

>   Sunday算法实际上是一种对BM算法的改进，其基本思路与BM算法相似。但是与BM算法不同的是，Sunday算法的比较是从模式串的开头进行比较的，并且Sunday算法在不匹配情况发生时，模式串跳转的幅度更大，所以从这一点上来说，Sunday算法的效率甚至比BM算法更高。

### 原理

从左到右比对,当发现比对失败时候(w),观察与模式串对齐的最后一位字符的下一位字符（本例中就是文本串中的D）是否出现在模式串中。

这一做法的意图是：如果文本串中，与模式串对齐位置上的下一位字符，也就是文本串中的D并没有出现在文本串中的话，那么就可以确定，从失配字符W向后，一直到字符D中间的这段内容与模式串肯定是不可能匹配了，所以我们可以直接跳过这段内容，直接将模式串跳转到字符D后面的位置进行对齐，然后重新开始比较。

<img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202304011925190.png" alt="image-20230401191518703" style="zoom: 50%;" />

  依然以上图为例，在进行模式串跳转之后，我们发现文本串中的_与模式串中的F首先就是不匹配的：

![image-20230401193314291](https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202304011933178.png)

但是此时在文本串中，与模式串对齐的下一位字符T在模式串中出现过：

<img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202304011933817.png" alt="image-20230401193339668" style="zoom:50%;" />

  此时，我们将与模式串对齐的下一位字符与模式串中出现的位置对齐，然后继续进行比较：

<img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202304011934699.png" alt="image-20230401193429201" style="zoom:50%;" />

### 编码

坏字表:记录了是否有某个字符(-1表示没有该字符),又记录了字符最后出现的位置.

```cpp
int sunday(const char *text, const char *pattern) {
	#define BASE 256
	int n = strlen(text), m, last_pos[BASE];
	//last_pos的每一个索引表示一个字符，因为字符本身就能通过ascll码表示为整数。
	//last_pos的值表示pattern中的元素在末尾的哪一位出现

	for (int i = 0; i < BASE; i++) last_pos[i] = -1; //初始化坏字表为-1
	for (m = 0; pattern[m]; m++) last_pos[pattern[m]] = m; //m为字串到\0的长度
	for (int i = 0; i + m <= n; i += (m - last_pos[text[i + m]])) {
		//如果没匹配成功，那么text的索引i向后移动 m - last_pos[text[i + m]] 位，m为模式串的长度

		int flag = 1;
		for (int j = 0; j < m; j++) {
			if (text[i + j] == pattern[j]) continue;
			flag = 0;
			break;
		}
		if (flag) return i;
	}
	return -1;
}
```

该算法也常用于特征码查询.(下面代码为[转载](https://blog.csdn.net/jinwei29/article/details/121265942),未测试)

```cpp
#include <iostream>
using namespace std;
#include <windows.h>
#include <psapi.h>
 #include <ctime>
 #include <string>
 #include<algorithm>
 std::string DeleteStringSpace(std::string str)
{
    str.erase(std::remove(str.begin(), str.end(), ' '), str.end()); // 删除所有空格
    return str;
}
 DWORD aobScan(HANDLE hProcess, HMODULE hModule, string 特征码,int CallOffset=0,DWORD* outCallAddre=0,int BaseAddreOffset=0, DWORD* outBaseAddr=0)
	{//进程PID，模块句柄，特征码，CallOffset：找call偏移-上负下正，BaseAddreOffset：找基址偏移；偏移是从特征码地址算起
		string tzm = DeleteStringSpace(特征码);//删除特征码所有空格
		int tzmLen = tzm.length() / 2;//特征码长度
		if (tzm.length() % 2 != 0)/*特征码长度不能为单数*/ return 0;
		byte* tzmByte = new byte[tzmLen];//定义一个字节变量并开辟指定长度的内存空间
		int 通配符首次位置 = StringToByte(tzm, tzmByte);
 
		MODULEINFO mMoudleInfo;
		GetModuleInformation(hProcess, hModule, &mMoudleInfo, sizeof(mMoudleInfo));
		DWORD  ModuleBeginAddr = (DWORD)hModule;//模块开始地址
		DWORD  ModuleSize =mMoudleInfo.SizeOfImage;//模块大小
		DWORD  ModuleEndAddr = ModuleBeginAddr + ModuleSize;//模块结束地址
 
		BYTE *pMemBuffer = NULL;//存放读取的内存数据的缓冲区		
		MEMORY_BASIC_INFORMATION mbi;//内存信息
		clock_t nBeginTime = clock();//记录起始搜索时间
 
		while (ModuleBeginAddr < ModuleEndAddr)//结束条件
		{//开始扫描内存
			memset(&mbi, 0, sizeof(MEMORY_BASIC_INFORMATION));//查询地址空间中内存地址的信息
			if (VirtualQueryEx(hProcess, (LPCVOID)ModuleBeginAddr, &mbi, sizeof(mbi)) == 0)break;;
			
			if (MEM_COMMIT == mbi.State && PAGE_READWRITE == mbi.Protect || PAGE_EXECUTE_READWRITE == mbi.Protect)
			{//过滤内存空间, 根据内存的状态和保护属性进行过滤
				if (pMemBuffer) {// 申请动态内存
					delete[] pMemBuffer; pMemBuffer = NULL;
				}
				pMemBuffer = new BYTE[mbi.RegionSize];
				if (!ReadProcessMemory(hProcess, (LPCVOID)ModuleBeginAddr, pMemBuffer, mbi.RegionSize, 0))continue;
				UINT deviation = SundayCmp(pMemBuffer, mbi.RegionSize, tzmByte, tzmLen, 通配符首次位置);
				if (-1 != deviation)//deviation是偏移
				{//-1为没有找到 
					clock_t nEndTime = clock();//记录结束时间
					printf(" %x  用时：%d 毫秒\r\n", ModuleBeginAddr + deviation, nEndTime - nBeginTime);
					if (0!=CallOffset)
					{//如果是找call
						DWORD temp; 
						memcpy(&temp, &pMemBuffer[deviation  + CallOffset + 1], 4);//拷贝出对应地址上的机器码，复制4个字节
						printf(" 返回call： %X  用时：%d 毫秒\r\n", ModuleBeginAddr + deviation+ CallOffset + temp +5, nEndTime - nBeginTime);
						*outCallAddre= ModuleBeginAddr + deviation + CallOffset + temp +5;//下一条指令地址(也就是目标地址 + 5)
					}
					if (0!=BaseAddreOffset)
					{//如果是找基址
						DWORD temp;
						memcpy(outBaseAddr, &pMemBuffer[deviation + BaseAddreOffset], 4);//拷贝出对应地址上的机器码，复制4个字节
						printf(" 返回基址： %X \r\n", outBaseAddr);//
					}
					return ModuleBeginAddr + deviation;//返回特征码地址
				}
			}
			ModuleBeginAddr += mbi.RegionSize; //取下一块内存地址
		}
		return -1;//没找到返回
	}
 
 
 int StringToByte(string &markCode,byte* pMarkCode)
	{//带通配符的string字符串转byte字节数组
		int markCodeLen = markCode.length() / 2;
		int 通配符第1次出现的位置 = 0;
		//pMarkCode = new BYTE[markCodeLen];
		for (int i = 0; i < markCodeLen; i++)
		{
			string tempStr = markCode.substr(i * 2, 2);
			if (tempStr == "??")
			{
				pMarkCode[i] = 0x3F;
				if (通配符第1次出现的位置 == 0) 通配符第1次出现的位置 = i;
			}
			else {
				pMarkCode[i] = strtoul(tempStr.c_str(), 0, 16);
			}
		}
		return 通配符第1次出现的位置;
	}
 
 int SundayCmp(byte* dest, int destLen, byte* pattern, int patternLen, int 通配符第1次出现的位置)
	{
		int nOffset = 0;//偏移量
		int i = 0, j = 0, nCount = 0;//数组下标：内存、特征码、返回地址
 
		int Shift[0xFF + 1] = { 0 };//Sunday算法模板数组赋值，+1防止特征码出现FF时越界
		for (int i = 0; i < 通配符第1次出现的位置; i++) {
			Shift[pattern[i]] = i + 1;
		}
 
		while (j < patternLen)
		{//以特征码长度进行循环
			if (dest[i] == pattern[j] || pattern[j] == 0x3F)//0x3F代表通配符
			{//如果相等
				i++; j++;
			}
			else
			{
				nOffset = i - j + 通配符第1次出现的位置;
				if (nOffset > destLen - patternLen)/*判断偏移量是否大于缓冲区*/ break;
				if (Shift[dest[nOffset]])
				{//判断 Shift模板数组 里有没有 内存偏移后的值，有则回溯，否则+1
					i = nOffset - Shift[dest[nOffset]] + 1;
					j = 0;
				}
				else
				{
					i = nOffset + 1;
					j = 0;
				}
			}
		}
		if (j == patternLen)
		{//计算找到的目标地址：//特征码地址 = 当前内存块基址 + i偏移 - 特征码长度
			return  i - patternLen;
		}
		return -1;
	}
```

# 贪心算法

> 贪心算法，又称贪婪法，是寻找最优解问题的常用方法。这种方法模式一般将求解过程分成若干个步骤，但每个步骤都应用贪心原则，选取当前状态下最好或最优的选择（局部最有利的选择），并以此希望最后堆叠出的结果也是最好或最优的解。
>
> 这就好像一个贪婪的人，他事事都想要眼前看到最好的那个，看不到长远的东西，也不为最终的结果和将来着想，贪图眼前局部的利益最大化，有点走一步看一步的感觉。
>
> 例如，假设你开了间小店，不能电子支付，钱柜里的货币只有25分、10分、5分和1分四种硬币，如果你是售货员且要找给客户41分钱的硬币，如何安排才能找给客人的钱既正确且硬币的个数又最少？这就是一个典型的贪心算法的应用场景。
>
> 然而，贪心算法不能保证最后求得的解是最优的，同时，贪心算法只能求满足某些约束条件的可行解的范围。如果一个问题的最优解只能用蛮力法穷举得到，则贪心法不失为寻找问题近似最优解的一种较好的方法。**贪心算法的时间复杂度通常比较低，但不一定能够得到全局最优解**。
>
> 总的来说，贪心算法是一种基于贪心策略的算法，它在每一步选择中都采取在当前状态下最好或最优的选择，从而希望导致结果是最好或最优的。贪心算法通常适用于求解最优化问题，如**最小生成树、最短路径、背包问题**等

# 排列组合公式

记忆有点模糊,故写在此处以做温习

排列组合公式推导:

![排列组合公式推导|720x360](https://www.bilibili.com/video/BV1uT411U7Ui)

[简单理解](https://www.zhihu.com/question/26094736)

[更多公式推导](https://www.cnblogs.com/1024th/p/10623541.html)

## 排列公式

排列需要考虑顺序

Arrangement 排列 或 Permutation 排列

从n个中取m个排列的个数
$$
A_{n}^{m}=\frac{n!}{(n-m)!}
$$

> 实际计算中，往往不用阶乘。**从大的数字开始往小乘，乘“小的数字那么多”个**

### 去重

例：`1.2.3.4.5`有`5!`种排序方式，而`1.1.3.4.5`的排序方式有`5!/2!`种:

“5！”意味着将`1.1.3.4.5`视作5个不同的元素，而这与实际不符，若两个“1”是不同的，交换后是2种序；但它们相同啊，所以“5!”计算出的结果，是将实际情况重复计算了2次，那么除以2就是正确答案了。

> 同理：`1.1.2.3.4.4.4.5`可组成多少个8位数？答：`8! / (2! x 3!)`

## 组合公式

Combination 组合

组合不需要考虑排序

从n个中取m个组合的个数
$$
C_n^m=\frac{n!}{(n-m)!m!}
$$

> 实际计算中，往往不用阶乘。从大的数字开始往小乘，乘“小的数字那么多”个，再除以“小的数字开始往小乘，乘小的数字那么多个”。

## 排列与组合的关系

$$
C_n^m=\frac{\mathrm{A}_n^m}{\mathrm{A}_m^m}=\frac{n(n-1)(n-2)\cdots(n-m+1)}{m!}=\frac{n!}{m!(n-m)!}
$$

# 动态规划

[爬楼梯问题](https://leetcode.cn/problems/climbing-stairs/solutions/?envType=study-plan-v2&envId=top-100-liked)

动态规划是运筹学的一个分支,求解决策过程最优化的一种思想

本质就是:给定一个大问题,把它拆成一个个子问题,直到子问题可以直接解决.然后把子问题的答案保存起来,以减少重复计算.再根据子问题答案反推,得到大问题解题的一种方法

动态规划是通过额外空间避免重复计算来加速计算过程,由于用到其余空间来保存计算结果,因此也称之为记忆化搜索(Recursion with Memoization),本质上是用空间换时间,也有人叫他"带备忘录的递归",或者递归树的剪枝(pruning).因为整个递归树不需要全部访问到,仿佛有些枝叶被剪掉了.上面说的递归也可以是迭代,动态规划不一定得是递归

# 令人惊叹的平方根算法

## 平方根快速计算算法

[二分法和牛顿迭代法都可以用来计算平方根](https://www.cnblogs.com/bluettt/p/13025259.html)

[另外，还有一种被称为“神奇的方法”的算法，它使用了一个特殊的常数和牛顿迭代法来快速计算平方根](https://zhuanlan.zhihu.com/p/98501407)。

![神奇方法视频详解|720x360](https://www.bilibili.com/video/BV18j411i7bp)

# PID控制算法

> PID控制是一种线性控制，它将给定值(t)与实际输出值y(t)的偏差的比例(P),积分(I),微分(D)通过线性组合形成控制量，对被控对象进行控制。
>
> 控制系统通常根据有没有反馈会分为开环系统和闭环系统，在闭环系统的控制中，PID算法非常强大
>
> 工业应用上占了95%的应用比例,使用起来简单,无需精确建模
>
> 其三个部分分别为
>
> - Proportion  比例
> - integration  积分
> - differential  微分
>
> PID适用于二阶以内的线性系统   (线性指满足齐次性和叠加性,2阶以内是指系统动态方程中导数的最高次数在2以内)
>
> 针对高阶系统 可以化为 二阶系统
>
> 针对非线性系统 可以通过 李雅普诺夫线性化 近似为线性系统

<img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2//202312121453911.png" alt="image-20231212145322088" style="zoom: 67%;" />

`PID`算法可以自动对控制系统进行准确且迅速的校正，因此被广泛地应用于工业控制系统   [参考](https://zhuanlan.zhihu.com/p/168751613)

## PID公式

下面过程出自[此博客](https://zhuanlan.zhihu.com/p/168751613)

PID控制的完整公式实际上是:(e是误差)
$$
C=\frac{1}{P}(e+\frac{1}{T_{i}}\int_{0}^{t}e{dt}+T_{d}\frac{de}{dt})
$$
实际上常用的是:
$$
C=k_{p}e+k_{i}\int_{0}^{t}edt+k_{d}\frac{de}{dt}
$$
离散化后如下:
$$
\begin{aligned}&\text{比例项: }K_pe(t)\xrightarrow{\textbf{离散化}} K _ p e _ k \\\text{ 积分项: }&K_i\int_0^{t_k}e(\tau)d\tau\xrightarrow{\text{离散化}} K _ i \sum _ { i = 1 }^{k}e(i)\Delta t\\&\text{微分项: }K_d\frac{de(t_k)}{dt}\xrightarrow{\text{离散化}} K _ d \frac { e ( k ) - e ( k - 1 ) }{ \Delta t}\end{aligned}
$$
离散化后为:
$$
u(k)=K_pe_k+K_i\sum_{i=1}^ke(i)\Delta t+K_d\frac{e(k)-e(k-1)}{\Delta t}
$$
根据$\Delta u(k)=u(k)-u(k-1)$可得到增量式PID的离散公式如下:
$$
\Delta u(k)=K_p(e(k)-e(k-1))+K_ie(k)+K_d\left(e(k)-2e(k-1)+e(k-2)\right)
$$

- $k_{p}$  比例增益:决定减少误差的速度的参数
- $k_{i}$  积分增益:取决于之前所有误差的累积.消除了稳态误差,但也可能引入震荡
- $k_{d}$  微分增益:取决于误差变化速度.增加阻尼减弱震荡效果增加稳定性:当偏差变化过快，微分环节会输出较大的负数，作为抑制输出继续上升，从而抑制过冲。



在真正使用PID控制算法的时候:最好还要做到:积分限幅,积分分离,微分先行

## PID代码

pid.h

```cpp
#pragma once
class PIDImpl;
class PID
{
    public:
        // Kp - 比例增益
        // Ki - 积分增益
        // Kd - 微分增益
        // dt - 循环间隔时间
        // max - 受控变量的最大值
        // min - 受控变量的最小值
        
        //用指定的循环间隔时间（dt），最大和最小的受控变量值（max和min），以及比例、微分和积分增益（Kp，Kd和Ki）初始化PID控制器。
        PID( double dt, double max, double min, double Kp, double Kd, double Ki );

        // 根据设定点和当前过程值计算并返回受控变量
        double calculate( double setpoint, double pv );
        ~PID();

    private:
        PIDImpl *pimpl;
};

class PIDImpl
{
    public:
        PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki );
        ~PIDImpl();
        double calculate( double setpoint, double pv );

    private:
        double _dt;
        double _max;
        double _min;
        double _Kp;
        double _Kd;
        double _Ki;
        double _pre_error;
        double _integral;
};
```

pid.cpp

```cpp
#include <iostream>
#include <cmath>
using namespace std;
#include "pid.h"


PID::PID( double dt, double max, double min, double Kp, double Kd, double Ki )
{
    pimpl = new PIDImpl(dt,max,min,Kp,Kd,Ki);
}
double PID::calculate( double setpoint, double pv )
{
    return pimpl->calculate(setpoint,pv);
}
PID::~PID() 
{
    delete pimpl;
}


/**
 * Implementation
 */
PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
    _dt(dt),
    _max(max),
    _min(min),
    _Kp(Kp),
    _Kd(Kd),
    _Ki(Ki),
    _pre_error(0),
    _integral(0)
{
}

double PIDImpl::calculate( double setpoint, double pv )
{
    
    // 计算误差
    double error = setpoint - pv;

    // 比例项
    double Pout = _Kp * error;

    // 积分项
    _integral += error * _dt;
    double Iout = _Ki * _integral;

    // 微分项
    double derivative = (error - _pre_error) / _dt;
    double Dout = _Kd * derivative;

    // 计算总输出
    double output = Pout + Iout + Dout;

    // 限制在最大/最小值范围内
    if( output > _max )
        output = _max;
    else if( output < _min )
        output = _min;

    // 保存当前误差为上次误差
    _pre_error = error;

    return output;
}

PIDImpl::~PIDImpl()
{
}
```

测试代码

```cpp
		PID pid2 = PID(0.1, 100, -100, 0.1, 0.01, 0.5);
    double val = 20;
    for (int i = 0; i < 100; i++) {
        double inc = pid2.calculate(0, val);
        printf("val:% 7.3f inc:% 7.3f\n", val, inc);
        val += inc;
    }
    return 0;
```

# 卡尔曼滤波

卡尔曼滤波（Kalman Filtering）是一种用于估计系统状态的最优滤波算法。它基于对系统的动态模型和测量模型进行建模，通过递归地更新状态估计值，提供对系统状态的最优估计和预测。

# 一些算法技巧

## 异或运算

- 0 ⊕ 0 = 0
- 1 ⊕ 0 = 1
- 0 ⊕ 1 = 1
- 1 ⊕ 1 = 0

1. 任何数和0做异或运算，结果仍然是原来的数，即:${a\oplus0=a}$
2. 任何数和其自身做异或运算，结果是0，即:${a\oplus a=0}$
3. 异或运算满足交换律和结合律，即:$a\oplus b\oplus a=b\oplus a\oplus a=b\oplus(a\oplus a)=b\oplus0=b$

针对[leetcode该题](https://leetcode.cn/problems/single-number/description/)

> 给你一个 **非空** 整数数组 `nums` ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

解法如下:

```cpp
int singleNumber(vector<int>& nums) {
        int res=0;
        for (int i = 0; i < nums.size(); i++)
        {
            res^=nums[i];
        }
        return res;
    }
```

## Boyer-Moore投票算法

如果一个数组有大于一半的数相同，那么任意删去两个不同的数字，新数组还是会有相同的性质

思路详解:

> “同归于尽消杀法” ：
>
> 由于多数超过50%, 比如100个数，那么多数至少51个，剩下少数是49个。
>
> 1. 第一个到来的士兵，直接插上自己阵营的旗帜占领这块高地，此时领主 winner 就是这个阵营的人，现存兵力 count = 1。
> 2. 如果新来的士兵和前一个士兵是同一阵营，则集合起来占领高地，领主不变，winner 依然是当前这个士兵所属阵营，现存兵力 count++；
> 3. 如果新来到的士兵不是同一阵营，则前方阵营派一个士兵和它同归于尽。 此时前方阵营兵力count --。（即使双方都死光，这块高地的旗帜 winner 依然不变，因为已经没有活着的士兵可以去换上自己的新旗帜）
> 4. 当下一个士兵到来，发现前方阵营已经没有兵力，新士兵就成了领主，winner 变成这个士兵所属阵营的旗帜，现存兵力 count ++。
>
> 就这样各路军阀一直以这种以一敌一同归于尽的方式厮杀下去，直到少数阵营都死光，那么最后剩下的几个必然属于多数阵营，winner 就是多数阵营。（多数阵营 51个，少数阵营只有49个，死剩下的2个就是多数阵营的人）

[针对题型](https://leetcode.cn/problems/majority-element/description/)

最优解法如下:

```cpp
int majorityElement(vector<int>& nums) {
        int winner=1e9+1;
        int score=0;
        for(int i=0;i<nums.size();i++)
        {
            if(nums[i]!=winner)
            {
                if(score>0)
                    score--;
                else
                    winner=nums[i];
            }
            else
                score++;
        }
        return winner;
    }
```

## 快慢指针

链表中如何在一次遍历中找到中间节点,可以使用快慢指针

> 慢指针一次走一步，快指针一次走两步，快慢指针同时出发。当快指针移动到链表的末尾时，慢指针恰好到链表的中间。**通过慢指针将链表分为两部分**

适用于所有链表的比例定位问题

### Floyd判圈算法

问题：如何检测一个链表是否有环，如果有，那么如何确定环的起点？如何确定环的长度？

> **「Floyd 判圈算法」（又称龟兔赛跑算法）**
>
> Floyd判圈算法(Floyd Cycle Detection Algorithm)，又称龟兔赛跑算法(Tortoise and Hare Algorithm)，是一个可以在有限状态机、迭代函数或者链表上判断是否存在环，求出该环的起点与长度的算法。该算法据高德纳称由美国科学家罗伯特·弗洛伊德发明。
>
> 假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。
>

原理理解:

![Floyd算法原理|720x360](https://www.youtube.com/watch?v=PvrxZaH_eZ4)

参阅上面视频,公式推导得到以下定理:

<img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2//202312261550430.png" alt="image-20231226154955021" style="zoom:67%;" />

1. 有限时间内都从起点出发,快慢指针必然相遇且相遇点在环上:一定会相遇是基于有一个指针每个节点都走到了
2. 在环上相遇的等速指针必定在环的入口处相遇  ==推导=>  [1找到的相遇点]和起点的等速指针将在环的入口处相遇

<img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2//202312261458055.jpeg" alt="imageTmp" style="zoom:33%;" />

- 判断是否有环

定义两个指针p1与p2，起始时，都指向链表的起点A，p1每次移动1个长度，p2每次移动2个长度。如果p2在移到链表的尾端时，并未与p1相遇，表明链表中不存在环。如果p1与p2相遇在环上的某一点C，表明链表有环。

- 环的长度

将指针p1固定在相遇位置C，从C点移动p2，每次移动1个长度，并用变量`cnt`计数。当p2再次与p1相遇时，此时`cnt`的值就是环的长度。

- 环的起点

环的起点即图中点B，将指针p1指向链表的起始位置A，指针p2仍在位置C，指针p1与p2每次均移动一个单位，p1与p2再次相遇的位置就是环的起点位置点B。

还有更高效率的做法:Brent的移动的兔子和传送的乌龟,[参阅此链接](https://zhuanlan.zhihu.com/p/413900856)



# 巧妙的递归解法

## 对称二叉树

[题目参考](https://leetcode.cn/problems/symmetric-tree/description/)

递归解法:

```cpp
		//比较两棵树是否对称二叉树		
		bool check(TreeNode *p, TreeNode *q)
    {
        if (!p && !q)
            return true;
        if (!p || !q)
            return false;
     		//p和q都不为NULL才可能走到这里
        return p->val == q->val && check(p->left, q->right) && check(p->right, q->left);
    }
		//判断树是否是二叉树
    bool isSymmetric(TreeNode *root)
    {
        return check(root, root);
    }
```

该题思路的重点在于将一棵树,当成两棵树来比较

图解如下:

<img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2//202312271758349.png" alt="image-20231227175839296" style="zoom: 25%;" /><img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2//202312271754984.png" alt="image-20231227175442449" style="zoom: 25%;" /><img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2//202312271758320.png" alt="image-20231227175855828" style="zoom: 25%;" /><img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2//202312271800043.png" alt="image-20231227180002117" style="zoom:25%;" />

------

改成迭代方式代码如下:  (比较抽象)

> 引入一个队列，这是把递归程序改写成迭代程序的常用方法。初始化时我们把根节点入队两次。每次提取两个结点并比较它们的值（队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像），然后将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。
>

```cpp
class Solution {
public:
    bool check(TreeNode *u, TreeNode *v) {
        queue <TreeNode*> q;
        q.push(u); q.push(v);
        while (!q.empty()) {
            u = q.front(); q.pop();
            v = q.front(); q.pop();
            if (!u && !v) continue;
            if ((!u || !v) || (u->val != v->val)) return false;

            q.push(u->left); 
            q.push(v->right);

            q.push(u->right); 
            q.push(v->left);
        }
        return true;
    }

    bool isSymmetric(TreeNode* root) {
        return check(root, root);
    }
};
```

