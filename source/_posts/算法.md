---
title: 算法
tags: 算法
categories: 技术
abbrlink: b7e144d1
mathjax: true
date: 2020-12-23 22:51:13

---

算法是指解决问题的方法(或过程),是若干指令的有穷序列

**算法的本质就是「穷举」**

> 算法的本质都是穷举二（多）叉树，有机会的话通过剪枝或者备忘录的方式减少冗余计算，提高效率

<!-- more -->

利用计算机的速度,解决现实中的抽象问题

穷举要做到两点

- 无遗漏
- 无冗余

遗漏会导致算法错误,冗余会拖慢算法运行速度

算法的难点在于两类问题

- 如何穷举(递归算法往往解决的是这类问题)

- 如何聪明的穷举

  比如后文 Union Find 并查集算法详解,告诉你一种高效计算连通分量的技巧，理论上说，想判断两个节点是否连通，用DFS/BFS 暴力搜索（穷举）肯定可以做到，但人家 Union Find 算法硬是用数组模拟树结构，给你把连通性相关的操作复杂度给干到`O(1)`了。
  再比如贪心算法技巧，所谓贪心算法就是在题目中发现一些规律（专业点叫贪心选择性质），使得你不用完整穷举所有解就可以得出答案。
  动态规划好歹是无冗余地穷举所有解，然后找一个最值，贪心算法倒好，都不用穷举所有解就可以找到答案，所以后文贪心算法解决跳跃游戏 中贪心算法的效率比动态规划还高。
  再比如大名鼎鼎的KMP算法，KMP 算法的本质是聪明地缓存并复用一些信息，减少了冗余计算，后文 KMP 字符匹配算法 就是使用计算机的思路实现的 KMP 算法。

> 顺便强调下，「算法工程师」做的这个「算法」，和「数据结构与算法」中的这个「算法」完全是两码事
>
> **对前者来说，重点在数学建模和调参经验，计算机真就只是拿来做计算的工具而已；而后者的重点是计算机思维，需要你能够站在计算机的视角，抽象、化简实际问题，然后用合理的数据结构去解决问题。**
>
> 所以，你千万别以为学好了数据结构和算法就能去做算法工程师，也不要以为只要不做算法工程师就不需要学习数据结构和算法。坦白说，大部分开发岗位工作中都是基于现成的开发框架做事，不怎么会碰到底层数据结构和算法相关的问题，但另一个事实是，只要找技术相关的岗位，数据结构和算法的考察是绕不开的，因为这块知识点是公认的程序员基本功。
>
> 为了区分，不妨称算法工程师研究的算法为「**数学算法**」，称刷题面试的算法为「计算机算法」，此篇内容主要聚焦的是「**计算机算**
> **法**」。
>
> 「计算机算法」的思维恰恰相反：有没有什么数学公式就交给你们人类去推导吧，如果能找到一些巧妙的定理那最好，但如果找不
> 到，那就穷举呗，反正只要复杂度允许，没有什么答案是穷举不出来的

- [算法导论-麻省理工](https://www.bilibili.com/video/BV1Tb411M7FA?from=search&amp;seid=12518312174180048412&amp;spm_id_from=333.337.0.0)
- [前人学习经验](http://erdengk.top/archives/zuo-lao-shi-suan-fa-ke-xue-xi-jian-yi)
- [大佬非常全面的博客](https://labuladong.github.io/algo/home/)

# 算法入门

## 时间复杂度

<img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2//202312182212066.png" alt="image-20231218221243795" style="zoom: 25%;" />

> 时间复杂度是衡量算法执行时间的一个指标，它表示算法运行时间随输入规模增长的趋势。通常使用大O符号表示，描述算法在输入规模增大时的渐进行为。
> 
> 举个例子，冒泡排序算法的时间复杂度是 $O(n^2)$，这意味着算法的运行时间与输入规模的平方成正比。也就是说，当输入规模翻倍时，算法的运行时间会变为原来的四倍。
> 
> 时间复杂度可以有多种不同的衡量方式。一种常见的方式是计算算法执行的操作次数。另一种方式是测量算法在特定计算机上运行所需的时间。
> 
> 时间复杂度在算法设计中非常重要，因为它可以帮助确定算法的效率。时间复杂度较高的算法可能不适用于大规模数据集，因为它们可能需要太长的运行时间。
> 
> 有许多技巧可以改善算法的时间复杂度。一种常见的方法是使用分治策略，将问题分解为更小的子问题，以便更高效地解决。另一种方法是使用动态规划，将子问题的结果存储起来，避免重复计算。
> 
> 时间复杂度是一个复杂的主题，没有一种通用的方法适用于所有算法。然而，通过了解不同的时间复杂度衡量方式，并使用适当的技巧改善算法的时间复杂度，可以设计出适用于各种问题的高效算法。

**常数时间的操作：**一个操作如果和样本的数据量没有关系，每次都是固定时间内完成的操作，叫做**常数操作**

时间复杂度为一个算法流程中，常数操作数量的一个指标。常用O(读作big O)来表示。具体来说，先要对一个算法流程非常熟悉，然后去写出这个算法流程中，发生了多少常数操作，进而总结出常数操作数量的表达式。

表达式中，只要高阶项，不要低阶项的系数（阶：未知数的次方数），剩下的部分如果为f(N)，那么时间复杂度为O(f(N))。

**【评价一个算法流程的好坏】**:先看时间复杂度的指标，然后再分析不同数据样本下的实际运行时间，也就是“常数项时间”。

## 空间复杂度

与时间复杂度相似,但针对空间

# 算法概述

- 递归与分治Divide and Conquer
- 动态规划Dynamic Programming
- 贪心算法Greedy
- 回溯算法Backtrack
- 分支限界法Branch and Bound
- 随机算法
- 近似算法

算法第一步是[问题建模](#问题建模)

## 问题建模

问题类型:

- 计数问题
- 构造问题
- 判定问题(二元的,yes or no)
- 最优化问题

问题建模:

1. 输入`input`:定义问题空间(即特定对象集合)
2. 输出`output`:定义解空间
3. 约束`constraint`:定义约束函数
4. 目标`objective function`:定义目标函数

问题实例:`instance of a problem`:问题模型的实例化,即**一个给定输入的实际问题**

### 图灵机

> 1936年，Alan M. Turing （1912-1954）提出了一种在理论计算机科学中广泛采用的抽象计算机
> 它是通用数字计算机的理论原型。图灵机可制造出一种十分简单但计算能力极强的计算机装置。

用有限的指令和有限的存储空间可算尽一切可算之物。

一台图灵机是一个七元组

图灵机=有限状态自动机+无限纸带 =>  算尽一切可算之物

# 排序算法

- 概念

排序是计算机内经常进行的一种操作，其目的是将一组“无序”的数据元素调整为“有序”的数据元素。

- 排序数学定义：

假设含n个数据元素的序列为{ R1, R2, …, Rn}，其相应的关键字序列为{ K1, K2, …, Kn}这些关键字相互之间可以进行比较，即在它们之间存在着这样一个关系 ：

Kp1≤Kp2≤…≤Kpn

按此固有关系将上式记录序列重新排列为{ Rp1, Rp2, …，Rpn}的操作称作排序

- 排序的稳定性

如果在序列中有两个数据元素r[i]和r[j]，它们的关键字k[i] == k [j]，且在排序之前，对象r[i]排在r[j]前面。如果在排序之后，对象r[i]仍在r[j]前面，则称这个排序方法是稳定的，否则称这个排序方法是不稳定的。

 <img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/%E5%9B%BE%E7%89%8746.png" alt="img" style="zoom: 50%;" />

- 内排序和外排序
  1. 内排序：在排序过程中，待排序的所有记录全部都放置在内存中，排序分为：内排序和外排序。
  2. 外排序：由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行。
- 排序的审判
  1. 时间性能：关键性能差异体现在比较和交换的数量
  2. 辅助存储空间：为完成排序操作需要的额外的存储空间，必要时可以“空间换时间”
  3. 算法的实现复杂性：过于复杂的排序法会影响代码的可读性和可维护性，也可能影响排序的性能
- 总结
  1. 排序是数据元素从无序到有序的过程
  2. 排序具有稳定性，是选择排序算法的因素之一
  3. 比较和交换是排序的基本操作
  4. 多关键字排序与单关键字排序无本质区别
  5. 排序的时间性能是区分排序算法好坏的主要因素

其他的一些排序算法:

1. [快速排序](#快速排序)（Quick Sort）：快速排序是一种基于分治思想的排序算法，通过选择一个基准元素，将数组分为两个子数组，并递归地对子数组进行排序。快速排序的平均时间复杂度为O(nlogn)，在大多数情况下具有较高的效率。(快速排序与下文的排序算法不是一个东西)
2. [归并排序](#归并排序)（Merge Sort）：归并排序也是一种分治算法，它将数组递归地分成两个子数组，然后将两个有序子数组合并成一个有序数组。归并排序的时间复杂度为O(nlogn)，并且具有稳定性。
3. [堆排序](#堆排序)（Heap Sort）：堆排序利用堆这种数据结构进行排序，通过构建最大堆或最小堆来实现排序。堆排序的时间复杂度为O(nlogn)，并且具有**原地排序**的特点。

需要注意的是，这些算法的性能取决于输入数据的规模和特征。对于小规模的数据集，简单的排序算法如插入排序和冒泡排序可能更高效。对于已经部分有序的数据集，插入排序和冒泡排序也可能比其他算法更快。

C++标准库中的`std::sort`函数使用了一种高效的排序算法（通常是快速排序或归并排序）

![sort](https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202401121114843.png)

### 冒泡排序

时间复杂度是$O(n^2)$

- 冒泡排序是一种效率低下的排序方法，在数据规模很小时，可以采用。数据规模比较大时，最好用其它排序方法。
- 上述例子对冒泡做了优化，添加了flag作为标记，记录序列是否已经有序，减少循环次数。

### 选择排序

时间复杂度是$O(n^2)$

<img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/%E5%9B%BE%E7%89%8747.png" alt="img"  />

### 插入排序

插入排序算法是一种简单的排序算法，也成为直接插入排序算法。它是一种稳定的排序算法，对局部有序的数据具有较高的效率。

插入排序算法是一个队少量元素进行排序的有效算法。比如，打牌是我们使用插入排序方法最多的日常生活例子。我们在摸牌时，一般会重复一下步骤。期初，我们手里没有牌，摸出第一张，随意放在左手上，以后每一次摸排，都会按照花色从小到大排列，直到所有的牌摸完。插入排序算法采用的类似思路，每一次从无序序列中拿出一个数据，将它放到已排序的序序列的正确位置，如此重复，直到所有的无序序列中的数据都找到了正确位置。

插入排序（Insertion Sort）的时间复杂度是$O(n^2)$。在最坏的情况下，需要比较和移动元素的次数是n(n-1)/2次，其中n是待排序数组的长度。

### 快速排序

时间复杂度为O(nlogn)

![快排流程动画|720x360](https://www.bilibili.com/video/BV1pd4y1z7gf)

下面代码是使用交换法实现的快排

```cpp
void quickSort(int arr[],int left,int right)
{
    if(left>=right)
        return;//递归结束条件
    //双指针
    int i=left;
    int j=right;
    int key=arr[left];//选取第一个数为基准数
    while(i<j){
        //不断往右移动左指针,找到第一个大于基准数的数
        while(i<j&&arr[j]>=key)
        {
            j--;
        }
        //不断往左移动右指针,找到第一个小于基准数的数
        while(i<j&&arr[i]<=key)
        {
            i++;
        }
        if(i<j)//意思就是i==j的时候不交换,会走向循环跳出
            swap(arr[i], arr[j]);//交换arr中i和j指针指向的值
    }
    swap(arr[i], arr[left]);
    //一轮基准值定位已经结束
    //该递归处理两边的数组了(此时i==j了,用哪个无所谓)
    quickSort(arr,left,i-1);
    quickSort(arr,j+1,right);
}
```

### 归并排序

时间复杂度为O(nlogn)

### 堆排序

时间复杂度为O(nlogn)

堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。

> 基本思想
>
> 利用大顶堆(小顶堆)堆顶记录的是最大关键字(最小关键字)这一特性，使得每次从无序中选择最大记录(最小记录)变得简单。

倒序对每个父节点进行下潜操作,通过这个操作使得混乱数组具备堆序性,如下流程

<img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202401141635053.gif" alt="堆排序" style="zoom: 33%;" />

反复调用`pop_heap`函数来实现，每次将最大元素移动到范围的末尾,就可以实现堆排序

`pop_heap`函数的实现参考下面流程: 

<img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202401141703357.gif" alt="pop" style="zoom:33%;" />

[[数据结构#堆|堆的详解点击跳转]]

[[stl#堆相关算法|stl中也有提供各种现成函数]]

### 计数排序

计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。

① 找出待排序的数组中最大和最小的元素
② 统计数组中每个值为i的元素出现的次数，存入数组C的第i项
③ 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）
④ 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1

<img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202401122024954.gif" alt="计数排序" style="zoom:67%;" />

平均时间复杂度：O(n + k)
最佳时间复杂度：O(n + k)
最差时间复杂度：O(n + k)
空间复杂度：O(n + k)

# 查找算法

## 二分查找

**无重复元素** 的 **升序** 排列数组中的插入查找

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

```cpp
int searchInsert(vector<int> &nums, int target)
    {
        int left = 0, right = nums.size() - 1;
        while (left <= right)
        {
            int mid = left + (right - left) / 2;

            if (nums[mid] == target)
                return mid;
            else if (nums[mid] < target)
                left = mid + 1;//灵魂就在于这个+1和下面的-1
            else
                right = mid - 1;
        }
        return left;
    }
```

- 时间复杂度：O(log⁡n)，其中 n 为数组的长度。二分查找所需的时间复杂度为 O(log⁡n)
- 空间复杂度：O(1)。我们只需要常数空间存放若干变量

# 字符串匹配算法

## KMP算法

一种改进的字符串匹配算法,利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的,将时间复杂度从`O(m*n)`变成`O(m+n)`

**next数组**含义为存放子串对应下标前存在的最长相等前后缀的长度(相等前后缀不能是字符串本身)

![视频讲解跳转|720x360](https://www.bilibili.com/video/BV1AY4y157yL)

### 生成next数组函数

**[递推思维]**: 通过已经掌握的信息,来避免进行重复的运算

```c
//生成next数组(next数组含义为存放子串对应下标前存在的最长相等前后缀的长度)
void generateNext(char* str,int* next)
{
    int strLen = strlen(str);
    int prefixLocate = 0;//前缀末尾指针,也可以表示相等前后缀长度
    for (int i = 1; i < strLen; i++)//i表示准备填写的next数组下标,跳过0是因为kkmpSearch函数中针对0下标不使用next数组的值
    {
        if(str[i]==str[prefixLocate])//前后相等情况
        {
            prefixLocate++;
            next[i] = prefixLocate;//相等就将累计的相等前缀长度赋给next对应位置
            i++;
        }
        else//遇到前后不相等情况
        {
            if (prefixLocate == 0)//相等前后缀长度为0
            {
                next[i]=0;
                i++;
            }
            else//相等前后缀长度不为0,可以利用之前的相等前后缀递推
            {
                prefixLocate=next[prefixLocate-1];//递推思维的关键代码
            }
        }
    }
}
```

**更简洁的版本**

任何位置匹配到的同时+1,就继续匹配下一个,同时把当前匹配的数量写入next[i+1]

```cpp

void getNext(const char* pat,vector<int>& next)
{
    next[0] = -1;
    int i = 0, j = -1;
    while (i < strlen(pat) - 1) {
        if (j == -1 || pat[i] == pat[j]) {
            ++i;
            ++j;
            next[i] = j;
        }
        else {
            j = next[j];
        }
    }
}
```

### kmp搜索函数

借助于next数组

```c
int kmpSearch(char* str,char* subStr)
{
    //生成next数组
    int strLen = strlen(str);
    //std::cout<<"主串为:"<<str<<std::endl;
    //std::cout<<"主串长度为:"<<strLen<<std::endl;
    int subStrLen = strlen(subStr);
    //std::cout<<"子串为:"<<subStr<<std::endl;
    //std::cout<<"子串长度为:"<<subStrLen<<std::endl;
    int* next = new int[subStrLen];
    memset(next,0,subStrLen);
    generateNext(subStr,next); 
    //展示next数组=====================
    /*std::cout<<"分析得到的next数组为"<<std::endl;
    for (int i = 0; i < subStrLen; i++)
    {
        cout<<next[i]<<" ";
    }
    std::cout<<std::endl;*/
    //==================================
    //开始查找
    int j=0;//子串下标
    int i=0;//主串下标
   while(i<strLen)
   {
        //匹配的话,主串与子串下标相加
        if(subStr[j]==str[i])
        {
            i++;j++;
        }    
        else if(j>0)//子串非第一个就不匹配,更新子串下标
        {
            j = next[j-1];
        }
        else//子串第一个就不匹配
        {
            i++;
        }
        if(j==subStrLen)//全都相等就跳出循环,返回找到的下标
        {
            delete [] next;
            return i-j;
        }
   }
    delete [] next;
    return -1;
}
```

## BM算法

字符串匹配BM算法,全称是`Boyer-Moore`算法,其核心思想是:在模式串中某个字符与主串不能匹配的时候,将模式串往后**多滑动几位**,以此提高匹配的效率

为了能够一次性多滑动几位,在真正进行字符串匹配之前,先进行了一系列预处理操作,遵循 **坏字符规则** 和 **好后缀规则**

### 坏字符规则

按模式串倒序匹配的过程中,把匹配失败时主串中的字符,叫做坏字符,然后在模式串中查找坏字符,若找到匹配字符,则将模式串中的匹配字符和坏字符对齐,否则直接将模式串滑动到坏字符之后的一位,再重复进行上述过程.

把坏字符在模式串中的位置记为 si 值，如果 坏字符 在 模式串 中存在，将坏字符在模式串中的下标记作 xi 值，若不存在 xi 记作 -1，移动的位数就等于 si-xi 值。

把坏字符在模式串中的位置记为 si 值，如果 坏字符 在 模式串 中存在，将坏字符在模式串中的下标记作 xi 值，若不存在 xi 记作 -1，移动的位数就等于 si-xi 值。

注意：单纯采用坏字符的策略，计算出来的移动位数有可能是负数，因此 BM 算法还需要使用好后缀规则来避免这种情况。因此，**在该算法中可以省略坏字符规则，却不能省略好后缀规则。**

### 好后缀规则

按模式串 倒序匹配 过程中，失配点之后模式串中 匹配成功的那段字符-U ，为好后缀。好后缀规则在于，考虑能否根据 已经匹配成功 的字符，直接推算出下次移动的位置。

> 理论依据：如果 `好后缀-U` 在模式串找不到 另一个 匹配子串，只要 `U-整体` 还参与匹配，就肯定无法匹配，因为已经确定模式串中没有与和 `U-整体` 相同的字符串。但若 `U-的部分后缀` 和 `模式串的前缀` 有 重合 且相等，则有可能会完全匹配。



上图是 只 基于 好后缀规则 的匹配过程，涉及 后缀整体匹配 和 后缀子串和模式串前缀 的匹配。而下图则是 坏字符+好后缀 两种规则的匹配方式，具体选哪种取决于可移动的最大距离。

## Sunday算法

>   Sunday算法实际上是一种对BM算法的改进，其基本思路与BM算法相似。但是与BM算法不同的是，Sunday算法的比较是从模式串的开头进行比较的，并且Sunday算法在不匹配情况发生时，模式串跳转的幅度更大，所以从这一点上来说，Sunday算法的效率甚至比BM算法更高。

### 原理

从左到右比对,当发现比对失败时候(w),观察与模式串对齐的最后一位字符的下一位字符（本例中就是文本串中的D）是否出现在模式串中。

这一做法的意图是：如果文本串中，与模式串对齐位置上的下一位字符，也就是文本串中的D并没有出现在文本串中的话，那么就可以确定，从失配字符W向后，一直到字符D中间的这段内容与模式串肯定是不可能匹配了，所以我们可以直接跳过这段内容，直接将模式串跳转到字符D后面的位置进行对齐，然后重新开始比较。

<img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202304011925190.png" alt="image-20230401191518703" style="zoom: 50%;" />

  依然以上图为例，在进行模式串跳转之后，我们发现文本串中的_与模式串中的F首先就是不匹配的：

![image-20230401193314291](https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202304011933178.png)

但是此时在文本串中，与模式串对齐的下一位字符T在模式串中出现过：

<img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202304011933817.png" alt="image-20230401193339668" style="zoom:50%;" />

  此时，我们将与模式串对齐的下一位字符与模式串中出现的位置对齐，然后继续进行比较：

<img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202304011934699.png" alt="image-20230401193429201" style="zoom:50%;" />

### 编码

坏字表:记录了是否有某个字符(-1表示没有该字符),又记录了字符最后出现的位置.

```cpp
int sunday(const char *text, const char *pattern) {
	#define BASE 256
	int n = strlen(text), m, last_pos[BASE];
	//last_pos的每一个索引表示一个字符，因为字符本身就能通过ascll码表示为整数。
	//last_pos的值表示pattern中的元素在末尾的哪一位出现

	for (int i = 0; i < BASE; i++) last_pos[i] = -1; //初始化坏字表为-1
	for (m = 0; pattern[m]; m++) last_pos[pattern[m]] = m; //m为字串到\0的长度
	for (int i = 0; i + m <= n; i += (m - last_pos[text[i + m]])) {
		//如果没匹配成功，那么text的索引i向后移动 m - last_pos[text[i + m]] 位，m为模式串的长度

		int flag = 1;
		for (int j = 0; j < m; j++) {
			if (text[i + j] == pattern[j]) continue;
			flag = 0;
			break;
		}
		if (flag) return i;
	}
	return -1;
}
```

该算法也常用于特征码查询.(下面代码为[转载](https://blog.csdn.net/jinwei29/article/details/121265942),未测试)

```cpp
#include <iostream>
using namespace std;
#include <windows.h>
#include <psapi.h>
 #include <ctime>
 #include <string>
 #include<algorithm>
 std::string DeleteStringSpace(std::string str)
{
    str.erase(std::remove(str.begin(), str.end(), ' '), str.end()); // 删除所有空格
    return str;
}
 DWORD aobScan(HANDLE hProcess, HMODULE hModule, string 特征码,int CallOffset=0,DWORD* outCallAddre=0,int BaseAddreOffset=0, DWORD* outBaseAddr=0)
	{//进程PID，模块句柄，特征码，CallOffset：找call偏移-上负下正，BaseAddreOffset：找基址偏移；偏移是从特征码地址算起
		string tzm = DeleteStringSpace(特征码);//删除特征码所有空格
		int tzmLen = tzm.length() / 2;//特征码长度
		if (tzm.length() % 2 != 0)/*特征码长度不能为单数*/ return 0;
		byte* tzmByte = new byte[tzmLen];//定义一个字节变量并开辟指定长度的内存空间
		int 通配符首次位置 = StringToByte(tzm, tzmByte);
 
		MODULEINFO mMoudleInfo;
		GetModuleInformation(hProcess, hModule, &mMoudleInfo, sizeof(mMoudleInfo));
		DWORD  ModuleBeginAddr = (DWORD)hModule;//模块开始地址
		DWORD  ModuleSize =mMoudleInfo.SizeOfImage;//模块大小
		DWORD  ModuleEndAddr = ModuleBeginAddr + ModuleSize;//模块结束地址
 
		BYTE *pMemBuffer = NULL;//存放读取的内存数据的缓冲区		
		MEMORY_BASIC_INFORMATION mbi;//内存信息
		clock_t nBeginTime = clock();//记录起始搜索时间
 
		while (ModuleBeginAddr < ModuleEndAddr)//结束条件
		{//开始扫描内存
			memset(&mbi, 0, sizeof(MEMORY_BASIC_INFORMATION));//查询地址空间中内存地址的信息
			if (VirtualQueryEx(hProcess, (LPCVOID)ModuleBeginAddr, &mbi, sizeof(mbi)) == 0)break;;
			
			if (MEM_COMMIT == mbi.State && PAGE_READWRITE == mbi.Protect || PAGE_EXECUTE_READWRITE == mbi.Protect)
			{//过滤内存空间, 根据内存的状态和保护属性进行过滤
				if (pMemBuffer) {// 申请动态内存
					delete[] pMemBuffer; pMemBuffer = NULL;
				}
				pMemBuffer = new BYTE[mbi.RegionSize];
				if (!ReadProcessMemory(hProcess, (LPCVOID)ModuleBeginAddr, pMemBuffer, mbi.RegionSize, 0))continue;
				UINT deviation = SundayCmp(pMemBuffer, mbi.RegionSize, tzmByte, tzmLen, 通配符首次位置);
				if (-1 != deviation)//deviation是偏移
				{//-1为没有找到 
					clock_t nEndTime = clock();//记录结束时间
					printf(" %x  用时：%d 毫秒\r\n", ModuleBeginAddr + deviation, nEndTime - nBeginTime);
					if (0!=CallOffset)
					{//如果是找call
						DWORD temp; 
						memcpy(&temp, &pMemBuffer[deviation  + CallOffset + 1], 4);//拷贝出对应地址上的机器码，复制4个字节
						printf(" 返回call： %X  用时：%d 毫秒\r\n", ModuleBeginAddr + deviation+ CallOffset + temp +5, nEndTime - nBeginTime);
						*outCallAddre= ModuleBeginAddr + deviation + CallOffset + temp +5;//下一条指令地址(也就是目标地址 + 5)
					}
					if (0!=BaseAddreOffset)
					{//如果是找基址
						DWORD temp;
						memcpy(outBaseAddr, &pMemBuffer[deviation + BaseAddreOffset], 4);//拷贝出对应地址上的机器码，复制4个字节
						printf(" 返回基址： %X \r\n", outBaseAddr);//
					}
					return ModuleBeginAddr + deviation;//返回特征码地址
				}
			}
			ModuleBeginAddr += mbi.RegionSize; //取下一块内存地址
		}
		return -1;//没找到返回
	}
 
 
 int StringToByte(string &markCode,byte* pMarkCode)
	{//带通配符的string字符串转byte字节数组
		int markCodeLen = markCode.length() / 2;
		int 通配符第1次出现的位置 = 0;
		//pMarkCode = new BYTE[markCodeLen];
		for (int i = 0; i < markCodeLen; i++)
		{
			string tempStr = markCode.substr(i * 2, 2);
			if (tempStr == "??")
			{
				pMarkCode[i] = 0x3F;
				if (通配符第1次出现的位置 == 0) 通配符第1次出现的位置 = i;
			}
			else {
				pMarkCode[i] = strtoul(tempStr.c_str(), 0, 16);
			}
		}
		return 通配符第1次出现的位置;
	}
 
 int SundayCmp(byte* dest, int destLen, byte* pattern, int patternLen, int 通配符第1次出现的位置)
	{
		int nOffset = 0;//偏移量
		int i = 0, j = 0, nCount = 0;//数组下标：内存、特征码、返回地址
 
		int Shift[0xFF + 1] = { 0 };//Sunday算法模板数组赋值，+1防止特征码出现FF时越界
		for (int i = 0; i < 通配符第1次出现的位置; i++) {
			Shift[pattern[i]] = i + 1;
		}
 
		while (j < patternLen)
		{//以特征码长度进行循环
			if (dest[i] == pattern[j] || pattern[j] == 0x3F)//0x3F代表通配符
			{//如果相等
				i++; j++;
			}
			else
			{
				nOffset = i - j + 通配符第1次出现的位置;
				if (nOffset > destLen - patternLen)/*判断偏移量是否大于缓冲区*/ break;
				if (Shift[dest[nOffset]])
				{//判断 Shift模板数组 里有没有 内存偏移后的值，有则回溯，否则+1
					i = nOffset - Shift[dest[nOffset]] + 1;
					j = 0;
				}
				else
				{
					i = nOffset + 1;
					j = 0;
				}
			}
		}
		if (j == patternLen)
		{//计算找到的目标地址：//特征码地址 = 当前内存块基址 + i偏移 - 特征码长度
			return  i - patternLen;
		}
		return -1;
	}
```

# 贪心算法

> 贪心算法，又称贪婪法，是寻找最优解问题的常用方法。这种方法模式一般将求解过程分成若干个步骤，但每个步骤都应用贪心原则，选取当前状态下最好或最优的选择（局部最有利的选择），并以此希望最后堆叠出的结果也是最好或最优的解。
>
> 这就好像一个贪婪的人，他事事都想要眼前看到最好的那个，看不到长远的东西，也不为最终的结果和将来着想，贪图眼前局部的利益最大化，有点走一步看一步的感觉。
>
> 例如，假设你开了间小店，不能电子支付，钱柜里的货币只有25分、10分、5分和1分四种硬币，如果你是售货员且要找给客户41分钱的硬币，如何安排才能找给客人的钱既正确且硬币的个数又最少？这就是一个典型的贪心算法的应用场景。
>
> 然而，贪心算法不能保证最后求得的解是最优的，同时，贪心算法只能求满足某些约束条件的可行解的范围。如果一个问题的最优解只能用蛮力法穷举得到，则贪心法不失为寻找问题近似最优解的一种较好的方法。**贪心算法的时间复杂度通常比较低，但不一定能够得到全局最优解**。
>
> 总的来说，贪心算法是一种基于贪心策略的算法，它在每一步选择中都采取在当前状态下最好或最优的选择，从而希望导致结果是最好或最优的。贪心算法通常适用于求解最优化问题，如**最小生成树、最短路径、背包问题**等

# 排列组合公式

记忆有点模糊,故写在此处以做温习

排列组合公式推导:

![排列组合公式推导|720x360](https://www.bilibili.com/video/BV1uT411U7Ui)

[简单理解](https://www.zhihu.com/question/26094736)

[更多公式推导](https://www.cnblogs.com/1024th/p/10623541.html)

## 排列公式

排列需要考虑顺序

Arrangement 排列 或 Permutation 排列

从n个中取m个排列的个数
$$
A_{n}^{m}=\frac{n!}{(n-m)!}
$$

> 实际计算中，往往不用阶乘。**从大的数字开始往小乘，乘“小的数字那么多”个**

### 去重

例：`1.2.3.4.5`有`5!`种排序方式，而`1.1.3.4.5`的排序方式有`5!/2!`种:

“5！”意味着将`1.1.3.4.5`视作5个不同的元素，而这与实际不符，若两个“1”是不同的，交换后是2种序；但它们相同啊，所以“5!”计算出的结果，是将实际情况重复计算了2次，那么除以2就是正确答案了。

> 同理：`1.1.2.3.4.4.4.5`可组成多少个8位数？答：`8! / (2! x 3!)`

## 组合公式

Combination 组合

组合不需要考虑排序

从n个中取m个组合的个数
$$
C_n^m=\frac{n!}{(n-m)!m!}
$$

> 实际计算中，往往不用阶乘。从大的数字开始往小乘，乘“小的数字那么多”个，再除以“小的数字开始往小乘，乘小的数字那么多个”。

## 排列与组合的关系

$$
C_n^m=\frac{\mathrm{A}_n^m}{\mathrm{A}_m^m}=\frac{n(n-1)(n-2)\cdots(n-m+1)}{m!}=\frac{n!}{m!(n-m)!}
$$

# 动态规划

> 动态规划是运筹学的一个分支,**求解决策过程最优值**的一种思想
>
> **求解最优解的时候需要想到动态规划**

本质就是:给定一个大问题,把它拆成一个个子问题,直到子问题可以直接解决.然后把子问题的答案保存起来,以减少重复计算.再根据子问题答案反推,得到大问题解题的一种方法

> 动态规划中最重要的两个概念
>
> - 重叠子问题
> - 最优子结构
>
> **重叠子问题**：动态规划会将每个求解过的子问题的解**记录**下来，这样当下一次碰到同样的子问题时，就可以**直接使用**之前记录的结果，而不是重复计算。**（虽然动态规划使用这种方式来提高计算效率，但不能说这种做法就是动态规划的核心）**
>
> 如果一个问题可以被分解成若干个子问题，且这些子问题会重复出现，那么称这个问题拥有 **重叠子问题（Overlapping Subproblems）**。
>
> 如果一个问题的最优解可以由其子问题的最优解有效地构造出来，那么称这个问题拥有 **最优子结构（Optimal Substructure）**。最优子结构保证了动态规划中原问题的最优解可以由子问题的最优解推导而来
>
> **一个问题必须拥有重叠子问题和最优子结构，才能使用动态规划去解决**

动态规划通过额外空间避免重复计算来加速计算过程,由于用到其余空间来保存计算结果,因此也称之为记忆化搜索(Recursion with Memoization),本质上是用空间换时间,也有人叫他"带备忘录的递归",或者递归树的剪枝(pruning).因为整个递归树不需要全部访问到,仿佛有些枝叶被剪掉了.上面说的递归也可以是迭代,动态规划不一定得是递归

动态规划的两种写法:

- **递推写法**：**自底向上（Bottom-up Approach）**，即从边界开始，不断向上解决问题，直到解决了目标问题；
- **递归写法**：**自顶向下（Top-down Approach）**，即从目标问题开始，将它分解成子问题的组合，直到分解至边界为至。

标准的动态规划实例:[爬楼梯问题](https://leetcode.cn/problems/climbing-stairs/solutions/?envType=study-plan-v2&envId=top-100-liked)

## 动态规划与其他思想的差异

### 分治算法与动态规划——重叠子问题

- 相同点：
  将问题分解成子问题，然后合并子问题的解得到原问题的解。
- 不同点：
  **分治法**解决的问题不拥有重叠子问题，解决的问题不一定是最优化问题；
  **动态规划**解决的问题拥有重叠子问题，解决的问题一定是最优化问题。

### [贪心算法](#贪心算法)与动态规划——最优子结构

- 相同点
  都要求原问题必须拥有**最优子结构**。
- 不同点
  **贪心**的计算方式类似于”自顶向下“，但是并不等待**所有子问题**求解完毕后再选择使用哪一个，而是通过一种策略**直接选择**一个子问题去求解，没被选择的子问题就不会再去求解了。
  **动态规划**的计算方式有”自顶向下“和”自底向上“两种，都是从边界开始向上得到目标问题的解。也就是说，它总是会考虑**所有子问题**，并选择继承能得到最优结果的那个，对暂时没有被继承的子问题，由于重叠子问题的存在，后期可能会再次考虑它们，因此还有机会成为全局最优的一部分，不需要放弃。

[53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/description/)这题同时有贪心算法解法和动态规划解法(官方解释中有视频两种方式的视频讲解)

思路:

- [贪心算法](#贪心算法):若当前指针所指元素之前的和小于0，则丢弃当前元素之前的数列.维护两个值:当前和,之前和
- 动态规划:若前一个元素大于0，则将其加到当前元素上.这样实际上存储的就是一个不确定左边界到当前边界的最大和,时间复杂度不如贪心算法

# 令人惊叹的平方根算法

## 平方根快速计算算法

[二分法和牛顿迭代法都可以用来计算平方根](https://www.cnblogs.com/bluettt/p/13025259.html)

[另外，还有一种被称为“神奇的方法”的算法，它使用了一个特殊的常数和牛顿迭代法来快速计算平方根](https://zhuanlan.zhihu.com/p/98501407)。

![神奇方法视频详解|720x360](https://www.bilibili.com/video/BV18j411i7bp)



# 闭环控制算法



## PID控制算法

> PID控制是一种线性控制，它将给定值(t)与实际输出值y(t)的偏差的比例(P),积分(I),微分(D)通过线性组合形成控制量，对被控对象进行控制。
>
> 控制系统通常根据有没有反馈会分为开环系统和闭环系统，在闭环系统的控制中，PID算法非常强大
>
> 工业应用上占了95%的应用比例,使用起来简单,无需精确建模
>
> 其三个部分分别为
>
> - Proportion  比例   比例组件根据过程距设定点的距离按比例施加作用力
> - integration  积分   积分组件会努力将过程返回到设定点,误差存在的时间越长,量越大,积分输出越大
> - differential  微分   微分组件着眼于过程远离设定点的速度,相当于预测未来的误差来调整输出
>
> PID适用于二阶以内的线性系统   (线性指满足齐次性和叠加性,2阶以内是指系统动态方程中导数的最高次数在2以内)
>
> 针对高阶系统 可以化为 二阶系统
>
> 针对非线性系统 可以通过 李雅普诺夫线性化 近似为线性系统

<img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2//202312121453911.png" alt="image-20231212145322088" style="zoom: 67%;" />

`PID`算法可以自动对控制系统进行准确且迅速的校正，因此被广泛地应用于工业控制系统   [参考](https://zhuanlan.zhihu.com/p/168751613)

### PID公式

下面过程出自[此博客](https://zhuanlan.zhihu.com/p/168751613)

PID控制的完整公式实际上是:(e是误差)
$$
C=\frac{1}{P}(e+\frac{1}{T_{i}}\int_{0}^{t}e{dt}+T_{d}\frac{de}{dt})
$$
实际上常用的是:
$$
C=k_{p}e+k_{i}\int_{0}^{t}edt+k_{d}\frac{de}{dt}
$$
离散化后如下:
$$
\begin{aligned}&\text{比例项: }K_pe(t)\xrightarrow{\textbf{离散化}} K _ p e _ k \\\text{ 积分项: }&K_i\int_0^{t_k}e(\tau)d\tau\xrightarrow{\text{离散化}} K _ i \sum _ { i = 1 }^{k}e(i)\Delta t\\&\text{微分项: }K_d\frac{de(t_k)}{dt}\xrightarrow{\text{离散化}} K _ d \frac { e ( k ) - e ( k - 1 ) }{ \Delta t}\end{aligned}
$$
分别看

- 比例项  $K_pe_k$

  $e_k$表示x点的状态值与目标状态值的偏差(如图$e_x$就是$e_k$)

  <img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202404221555611.png" alt="image-20240422155515897" style="zoom:25%;" />

- 积分项  $K_i\sum_{i=1}^ke(i)\Delta t$

  $\sum_{i=1}^ke(i)\Delta t$表示为下图三个颜色块的面积之和

  <img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202404221558924.png" alt="image-20240422155832526" style="zoom:25%;" />

- 微分项   $K_d\frac{e(k)-e(k-1)}{\Delta t}$

  $\frac{e(k)-e(k-1)}{\Delta t}$表示下图中点的微分

  <img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202404221602080.png" alt="image-20240422160219761" style="zoom:25%;" />

  

离散化后得到PID的离散表达式:
$$
u(k)=K_pe_k+K_i\sum_{i=1}^ke(i)\Delta t+K_d\frac{e(k)-e(k-1)}{\Delta t}
$$
由于$\Delta t$是固定值,将$\Delta t$归入K中就得到了位置式PID

<img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202404221608502.png" alt="image-20240422160800161" style="zoom: 50%;" />

根据$\Delta u(k)=u(k)-u(k-1)$可得到增量式PID的离散公式如下:
$$
\Delta u(k)=K_p(e(k)-e(k-1))+K_ie(k)+K_d\left(e(k)-2e(k-1)+e(k-2)\right)
$$

- $k_{p}$  比例增益:决定减少误差的速度的参数
- $k_{i}$  积分增益:取决于之前所有误差的累积.消除了稳态误差,但也可能引入震荡
- $k_{d}$  微分增益:取决于误差变化速度.增加阻尼减弱震荡效果增加稳定性:当偏差变化过快，微分环节会输出较大的负数，作为抑制输出继续上升，从而抑制过冲。

位置式PID和增量式PID本质是同一个公式

在真正使用PID控制算法的时候:最好还要做到:积分限幅,积分分离,微分先行

### PID代码

pid.h

```cpp
#pragma once
class PIDImpl;
class PID
{
    public:
        // Kp - 比例增益
        // Ki - 积分增益
        // Kd - 微分增益
        // dt - 循环间隔时间
        // max - 受控变量的最大值
        // min - 受控变量的最小值
        
        //用指定的循环间隔时间（dt），最大和最小的受控变量值（max和min），以及比例、微分和积分增益（Kp，Kd和Ki）初始化PID控制器。
        PID( double dt, double max, double min, double Kp, double Kd, double Ki );

        // 根据设定点和当前过程值计算并返回受控变量
        double calculate( double setpoint, double pv );
        ~PID();

    private:
        PIDImpl *pimpl;
};

class PIDImpl
{
    public:
        PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki );
        ~PIDImpl();
        double calculate( double setpoint, double pv );

    private:
        double _dt;
        double _max;
        double _min;
        double _Kp;
        double _Kd;
        double _Ki;
        double _pre_error;
        double _integral;
};
```

pid.cpp

```cpp
#include <iostream>
#include <cmath>
using namespace std;
#include "pid.h"


PID::PID( double dt, double max, double min, double Kp, double Kd, double Ki )
{
    pimpl = new PIDImpl(dt,max,min,Kp,Kd,Ki);
}
double PID::calculate( double setpoint, double pv )
{
    return pimpl->calculate(setpoint,pv);
}
PID::~PID() 
{
    delete pimpl;
}


/**
 * Implementation
 */
PIDImpl::PIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :
    _dt(dt),
    _max(max),
    _min(min),
    _Kp(Kp),
    _Kd(Kd),
    _Ki(Ki),
    _pre_error(0),
    _integral(0)
{
}

double PIDImpl::calculate( double setpoint, double pv )
{
    
    // 计算误差
    double error = setpoint - pv;

    // 比例项
    double Pout = _Kp * error;

    // 积分项
    _integral += error * _dt;
    double Iout = _Ki * _integral;

    // 微分项
    double derivative = (error - _pre_error) / _dt;
    double Dout = _Kd * derivative;

    // 计算总输出
    double output = Pout + Iout + Dout;

    // 限制在最大/最小值范围内
    if( output > _max )
        output = _max;
    else if( output < _min )
        output = _min;

    // 保存当前误差为上次误差
    _pre_error = error;

    return output;
}

PIDImpl::~PIDImpl()
{
}
```

测试代码

```cpp
		PID pid2 = PID(0.1, 100, -100, 0.1, 0.01, 0.5);
    double val = 20;
    for (int i = 0; i < 100; i++) {
        double inc = pid2.calculate(0, val);
        printf("val:% 7.3f inc:% 7.3f\n", val, inc);
        val += inc;
    }
    return 0;
```

### 现成的pid算法

- Boost库里有PID控制器的封装。Boost::PID是基于boost::ublas的PID算法实现,提供基本的PID功能。
- Arduino库内的PID.h头文件封装了PID控制器类,支持增量式PID算法。
- OpenCV库中的cv::PIDController类实现了离散PID控制器。
- GNU科学库GSL中的gsl_control_pid_ss函数提供了单点离散PID控制。
- Eigen库中有BasicPIDControllers类实现基本PID控制。

## 模糊控制算法

Fuzzy Logic Control(FLC)

模糊化是根据特定输入值的拟合程度,将特定输入值转换为模糊集某种程度的隶属度的过程

隶属函数描述特定输入或输出变量,这些隶属函数可以用图形表示

<img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202405070853189.png" alt="image-20240507085315482" style="zoom: 25%;" />

这些隶属函数有助于量化基于语言变量,而不是精确数值做出决策所涉及的模糊逻辑

## 模型预测控制

Model Predictive Control(MPC)

是一种反馈控制技术,基于数学模型预测系统未来行为的控制算法

作为许多工业应用中强大且广泛使用的控制策略

## 其他控制算法

- 自适应控制算法
- 神经网络控制算法

# 卡尔曼滤波

卡尔曼滤波（Kalman Filtering）是一种用于估计系统状态的最优滤波算法。它基于对系统的动态模型和测量模型进行建模，通过递归地更新状态估计值，提供对系统状态的最优估计和预测。

> 卡尔曼滤波在以下情况需要使用
>
> 1. 当系统受到噪声干扰时，需要准确估计系统的状态。 
> 2. 当系统具有复杂的动态模型或多个传感器测量值时，需要融合这些信息来得到更准确的状态估计。 
> 3. 当系统需要快速响应和准确跟踪目标时，卡尔曼滤波可以提供更优秀的性能。 
> 4. 当系统需要实时进行状态估计，并且需要考虑系统的动态特性和测量误差时，卡尔曼滤波是一个有效的选择。

# 巴特沃斯滤波器

# LQR控制器

# 工业上的平滑算法

在工业上，当传感器测得的数据波动非常大时，常用的方法之一是数据平滑处理。以下是几种常见的数据平滑方法：

1. **移动平均法**：计算一定时间窗口内的数据平均值，用平均值替代原始数据点。移动平均法可以有效地减少数据的波动，使数据更加平滑。

2. **指数加权移动平均法**：与简单移动平均法不同，指数加权移动平均法给予最近数据点更大的权重，使得平均值更加灵活地跟随数据的变化。

3. **滤波器**：使用数字滤波器对数据进行滤波处理，常见的滤波器包括低通滤波器和中值滤波器等。滤波器可以有效地去除数据中的噪声和波动。

4. **数据插值**：通过插值算法对数据进行插值处理，填补数据中的缺失或异常值，使得数据更加平滑。

# 样条插值

[知乎详解参考](https://www.zhihu.com/tardis/zm/art/269230598?source_id=1005)

> 用途:
>
> - 根据数据做预测,或则根据局部情况估计整体分布
> - 图形化呈现计算结果
>
> 缺点:不能给出明确函数关系,一般用于对数据的概括性描述,从中发现分布特征
>
> 样条名词解析:
>
> "样条"这个术语源自于造船业，用来描述在木船的曲线形状中使用的一种柔软且易弯曲的木条。在数学和计算机科学领域，"样条"被引入用来描述一种平滑且连续的插值函数。因此，"样条插值"指的是通过连接相邻数据点的一系列曲线段来逼近数据的插值方法，以实现平滑的曲线拟合。 在样条插值中，通常会使用多项式函数来拟合相邻数据点之间的曲线段，以确保在数据点处函数值的连续性和平滑性。样条插值方法在数据处理、图像处理和数值分析等领域广泛应用，可以有效地处理数据的平滑和插值问题。

不用给出具体的函数关系,根据已有数据预测其他数据即可的情况可以使用**样条插值算法**

根据实际应用对于“平滑”的要求，通常会有以下不同的约束：

1. 要求生成的参考曲线是连续的；
2. 在1的基础上，要求参考曲线的速度是连续的；
3. 在1和2的基础上，要参考曲线的加速度是连续的；

> 速度是位置对时间的导数，加速度是速度对时间的导数，加速度对时间的导数我们称之为jerk。

在多项式插值里面，给定多项式的阶次越高，能拟合的函数曲线就越复杂，但越高阶次的多项式对于计算资源的要求越多。因此对于这3个要求，我们可以分别用不同阶次的多项式函数来拟合，实际应用时根据需求选择合适的方法。

> 下面的公式讲解如下:$a_0$,$a_1$是待确定的常量参数。$t_0$表示初始时刻， $a_0$表示初始时刻的位置， $a_1$表示斜率，也就是速度，这里为常量。因此，给定下一个时刻 $t_1$处的位置 q($t_1$), $t_f$表示分割点时间

1. 线性插值（一阶，恒定速度）

   线性插值，顾名思义，就是使用线性的方法来进行插值。即将给定的数据点依次用线段连起来，点与点之间运动的速度是恒定值。
   $$
   q(t)=a_0+a_1(t-t_0)
   $$
   得出常数为:
   $$
   \left\{\begin{array}{l}a_0=q_0\\a_1=(q_1-q_0)/(t_1-t_0)\end{array}\right.
   $$
   <img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202404230830700.png" alt="image-20240423082957322" style="zoom:33%;" />

2. 抛物线插值（二阶，恒定加速度）

   抛物线差值（Parabolic Spline）是二阶多项式插值方法。与线性插值法将各个数据点用线段连起来不同，抛物线插值方法是用二次曲线将各个数据点连接起来，在连接处使用平滑的曲线来过渡，而避免速度不连续导致的“急剧拐弯”。抛物线差值的特征是具有恒定的加速度/减速度，一般是由两个二阶多项式的组合来得到。为什么是两个二阶多项式呢？因为一个用于“加速阶段”，一个用于“减速阶段”。“加速阶段”和“减速阶段”的分割点叫flex point。

   - 加速阶段
     $$
     q_a(t)=a_0+a_1(t-t_0)+a_2(t-t_0)^2,\quad t\in[t_0,t_f]
     $$

   - 减速阶段
     $$
     q_b(t)=a_3+a_4\left(t-t_f\right)+a_5\left(t-t_f\right)^2\quad t\in[t_f,t_1]
     $$

   - 

   常数公式略

   <img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202404230830917.png" alt="image-20240423083052298" style="zoom:33%;" />

3. 三次多项式插值（三阶，加速度可变）

   三次多项式插值方法（Cubic Spline）是一种常用的插值方法，其位置和速度曲线是连续的，加速度是可变的，但加速度不一定连续。考虑2个数据点之间插值的情况，其数学表达式为：
   $$
   q(t)=a_0+a_1\left(t-t_0\right)+a_2(t-t_0)^2+a_3(t-t_0)^3,\quad t_0\leq t\leq t_1
   $$
   两种计算情况

   - 给定了初始时刻$t_0$和最终时刻$t_1$处的位置与速度信息($q_0,q_1,v_0,v_1$),设$h=q_1-q_0,T=t_1-t_0$,则参数可以使用一下公式计算:
     $$
     \left.\left\{\begin{array}{l}a_0=q_0\\a_1=\mathrm{v}_0\\a_2=\frac{3h-(2\mathrm{v}_0+\mathrm{v}_1)T}{T^2}\\a_3=\frac{-2h+(\mathrm{v}_0+\mathrm{v}_1)T}{T^3}.\end{array}\right.\right.
     $$
     对于给定 n 个一系列数据点进行插值的情况，只需要对所有相邻的两个数据点使用上述公式即可依次计算得到整条插值曲线。

   - 给定了每一个点的位置信息$(\begin{array}{c}q_0,q_1,\ldots,q_n\end{array})$,但中间点的速度未给定

     这种情况,整条曲线最开始的起点和最终的终点速度需要直接给定，一般为零,$v_0=v_1=0$.中间各个数据点的速度可以通过启发式方法得到，即通过求解位置对时间的导数得到，那么对于第k个中间点，我们有：
     $$
     \left.v_k=\left\{\begin{array}{ll}0,\quad sign(d_k)\neq sign(d_{k+1})\\\frac12(d_k+d_{k+1}),\quad sign(d_k)=sign(d_{k+1})\end{array}\right.\right.
     $$
     其中$d_k=(q_k-q_{k-1})/(t_k-t_{k-1})$,表示曲线的导数或斜率,sign()为符号函数,返回1或-1

     > 直观理解:考察第k个数据点,若其导数在该点进行了符号反转,则该点速度为0,否则该点速度为其导数

   <img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202404230831975.png" alt="image-20240423083157317" style="zoom:33%;" />

   可以看到，位置曲线是“平滑”的，速度曲线是连续的，加速度曲线是可变的，但是不连续。这样，对于高速控制的场合来说，控制器的输入仍然会存在阶跃，导致不连续的情况。

4. 五次多项式插值（五阶，加速度连续）

   略,[更多详情参考此处](https://www.zhihu.com/tardis/zm/art/269230598?source_id=1005)

   <img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202404230836012.png" alt="image-20240423083602333" style="zoom:33%;" />

   可以看出，位置、速度、加速度三条曲线都是连续的，并且位置和速度还是“平滑”的,如果加速度曲线也要求是平滑的，那么就需要更高阶次的多项式插值方法了，例如七阶多项式插值。

5. 七次及更高阶次的多项式插值

各种方法插值的对比图

![image-20240423083925159](https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202404230839844.png)

[相关开源代码Python及Matlab的Github仓库](https://github.com/chauby/PolynomialInterpolation)

n次拉格朗日插值多项式:  太复杂,但能推出一个统一的多项式

分段线性插值:  针对每两个点,分段进行线性插值

**三次样条插值**的Matlab语法

```matlab
#matlab语法
interp1(x0,y0,x,'spline')
#或
spline(x0,y0,x)
```

**分段三次多项式插值**

<img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202404221417951.png" alt="image-20240422141726395" style="zoom:50%;" />

# 数值分析:曲线拟合算法和函数逼近

与插值方法最大的区别在于最终要得到具体的函数关系 

![相关教程参考|720x360](https://www.bilibili.com/video/BV1HL4y1q7BV)

在数值积分中，除了使用梯形简单计算积分外,还可以使用插值或拟合技术来构造多项式来逼近被积函数。这里简单介绍一下常用的方法： 

1. **插值法**：插值法通过已知数据点来构造通过这些点的多项式函数。常见的插值方法包括拉格朗日插值和牛顿插值。在辛普森法则中，我们可以通过子区间的左端点、右端点和中点处的函数值来构造一个二次多项式，从而近似代替被积函数。 
2. **拟合法**：拟合法通过已知数据点来拟合一个多项式函数，使得这个多项式函数与原函数在这些点上尽可能接近。常见的拟合方法包括最小二乘法和最小二乘多项式拟合。在数值积分中，我们可以使用拟合技术来构造一个简单的多项式函数来逼近被积函数。

# 图算法

- DFS 深度优先搜索
- BFS 广度优先搜索

<img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202401291217810.gif" alt="bfsanddfs" style="zoom: 67%;" />

BFS 可以用来求**最短路径问题**

DFS 常用来处理[全排列问题](#全排列)

> 这里提一嘴:深度优先遍历、递归、栈，它们三者的关系，我个人以为它们背后统一的逻辑都是「后进先出」
>
> 图算法本质上是二叉树算法的延续

## Union Find并查集算法

# 回溯算法

> **回溯法** 采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：
>
> **回溯算法本质就是一种暴力穷举算法**,虽然效率低,但是简单
>
> 回溯算法一般不会让你求最值,而是用于罗列所有无重叠的子结果
>
> - 回溯算法和dfs的区别:
>
>   DFS 是一个劲的往某一个方向搜索，而回溯算法建立在 DFS 基础之上的，但不同的是在搜索过程中，达到结束条件后，恢复状态，回溯上一层，再次搜索。因此回溯算法与 DFS 的区别就是有无状态重置
>
> - 何时使用回溯算法:
>
>   当问题需要 "回头"，以此来查找出所有的解的时候，使用回溯算法。即满足结束条件或者发现不是正确路径的时候(走不通)，要撤销选择，回退到上一个状态，继续尝试，直到找出所有解为止
>
> - 

- 找到一个可能存在的正确的答案；
- 在尝试了所有可能的分步方法后宣告该问题没有答案。

「回溯算法」强调了「深度优先遍历」思想的用途，用一个 不断变化 的变量，在尝试各种可能的过程中，搜索需要的结果。强调了 回退 操作对于搜索的合理性。

```cpp
//回溯算法框架伪代码
List<Value> result;
void backtrack(路径,选择列表){
    if(满足结束条件){
        result.add(路径);
        return;
    }
    for(选择:选择列表){
        做选择;
        backtrack(路径,选择列表);
        撤销选择;
    }
}
```

递归之后需要做和递归之前相同的逆向操作,实例可以参考[全排列问题](#全排列)

> 可以使用**排列树**和**子集树**来理解回溯算法      [子集树参考78.子集](https://leetcode.cn/problems/subsets/?envType=study-plan-v2&envId=top-100-liked)     [排列树参考46.全排列](https://leetcode.cn/problems/permutations/description/?envType=study-plan-v2&envId=top-100-liked)
>
> 下图中:最上方为**N叉树**,左下角为**子集树**,右下角为**排列树**

![tree](https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202402061312311.png)

![该视频讲解得非常透彻|720x360](https://www.bilibili.com/video/BV1YZ4y1H7TU)

# 一些算法技巧

## 异或运算

- 0 ⊕ 0 = 0
- 1 ⊕ 0 = 1
- 0 ⊕ 1 = 1
- 1 ⊕ 1 = 0

1. 任何数和0做异或运算，结果仍然是原来的数，即:${a\oplus0=a}$
2. 任何数和其自身做异或运算，结果是0，即:${a\oplus a=0}$
3. 异或运算满足交换律和结合律，即:$a\oplus b\oplus a=b\oplus a\oplus a=b\oplus(a\oplus a)=b\oplus0=b$

针对[leetcode该题](https://leetcode.cn/problems/single-number/description/)

> 给你一个 **非空** 整数数组 `nums` ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

解法如下:

```cpp
int singleNumber(vector<int>& nums) {
        int res=0;
        for (int i = 0; i < nums.size(); i++)
        {
            res^=nums[i];
        }
        return res;
    }
```

## Boyer-Moore投票算法

如果一个数组有大于一半的数相同，那么任意删去两个不同的数字，新数组还是会有相同的性质(即数组有大于一半的数相同)

思路详解:

> **同归于尽消杀法** ：
>
> 由于多数超过50%, 比如100个数，那么多数至少51个，剩下少数是49个。
>
> 1. 第一个到来的士兵，直接插上自己阵营的旗帜占领这块高地，此时领主 winner 就是这个阵营的人，现存兵力 count = 1。
> 2. 如果新来的士兵和前一个士兵是同一阵营，则集合起来占领高地，领主不变，winner 依然是当前这个士兵所属阵营，现存兵力 count++；
> 3. 如果新来到的士兵不是同一阵营，则前方阵营派一个士兵和它同归于尽。 此时前方阵营兵力count --。（即使双方都死光，这块高地的旗帜 winner 依然不变，因为已经没有活着的士兵可以去换上自己的新旗帜）
> 4. 当下一个士兵到来，发现前方阵营已经没有兵力，新士兵就成了领主，winner 变成这个士兵所属阵营的旗帜，现存兵力 count ++。
>
> 就这样各路军阀一直以这种以一敌一同归于尽的方式厮杀下去，直到少数阵营都死光，那么最后剩下的几个必然属于多数阵营，winner 就是多数阵营。（多数阵营 51个，少数阵营只有49个，死剩下的2个就是多数阵营的人）

[针对题型](https://leetcode.cn/problems/majority-element/description/)

最优解法如下:

```cpp
int majorityElement(vector<int>& nums) {
        int winner=1e9+1;
        int score=0;
        for(int i=0;i<nums.size();i++)
        {
            if(nums[i]!=winner)
            {
                if(score>0)
                    score--;
                else
                    winner=nums[i];
            }
            else
                score++;
        }
        return winner;
    }
```

## 快慢指针

链表中如何在一次遍历中找到中间节点,可以使用快慢指针

> 慢指针一次走一步，快指针一次走两步，快慢指针同时出发。当快指针移动到链表的末尾时，慢指针恰好到链表的中间。**通过慢指针将链表分为两部分**

适用于所有链表的比例定位问题

### Floyd判圈算法

问题：如何检测一个链表是否有环，如果有，那么如何确定环的起点？如何确定环的长度？

> **「Floyd 判圈算法」（又称龟兔赛跑算法）**
>
> Floyd判圈算法(Floyd Cycle Detection Algorithm)，又称龟兔赛跑算法(Tortoise and Hare Algorithm)，是一个可以在有限状态机、迭代函数或者链表上判断是否存在环，求出该环的起点与长度的算法。该算法据高德纳称由美国科学家罗伯特·弗洛伊德发明。
>
> 假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。
>

原理理解:

![Floyd算法原理|720x360](https://www.youtube.com/watch?v=PvrxZaH_eZ4)

参阅上面视频,公式推导得到以下定理:

<img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202312261550430.png" alt="image-20231226154955021" style="zoom:67%;" />

1. 有限时间内都从起点出发,快慢指针必然相遇且相遇点在环上:一定会相遇是基于有一个指针每个节点都走到了
2. 在环上相遇的等速指针必定在环的入口处相遇  ==推导=>  [1找到的相遇点]和起点的等速指针将在环的入口处相遇

<img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2//202312261458055.jpeg" alt="imageTmp" style="zoom:33%;" />

<img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/龟兔赛跑算法.gif" style="zoom:50%;" />

- 判断是否有环

定义两个指针p1与p2，起始时，都指向链表的起点A，p1每次移动1个长度，p2每次移动2个长度。如果p2在移到链表的尾端时，并未与p1相遇，表明链表中不存在环。如果p1与p2相遇在环上的某一点C，表明链表有环。

- 环的长度

将指针p1固定在相遇位置C，从C点移动p2，每次移动1个长度，并用变量`cnt`计数。当p2再次与p1相遇时，此时`cnt`的值就是环的长度。

- 环的起点

环的起点即图中点B，将指针p1指向链表的起始位置A，指针p2仍在位置C，指针p1与p2每次均移动一个单位，p1与p2再次相遇的位置就是环的起点位置点B。

还有更高效率的做法:Brent的移动的兔子和传送的乌龟,[参阅此链接](https://zhuanlan.zhihu.com/p/413900856)

## 链表中的哑节点

哑节点的意义:

1. 简化插入和删除操作：哑节点可以作为链表的起始节点，使得插入和删除操作在任意位置都可以统一处理。无论是在链表头部、中间还是尾部插入或删除节点，都不需要特殊处理边界情况。

2. 处理空链表：当链表为空时，哑节点可以作为链表的唯一节点，避免了对空链表的额外判断和处理。这样，在处理链表时，不需要单独考虑链表为空的情况。

3. 简化遍历操作：哑节点可以作为链表的起始节点，使得遍历链表时不需要对头节点进行特殊处理。遍历操作可以从哑节点的下一个节点开始，一直遍历到链表的末尾。

4. 提高代码的一致性和可读性：通过使用哑节点，链表的操作可以统一处理，减少了重复的代码和特殊情况的处理，使得代码更加简洁、一致和易于理解。

需要注意的是，哑节点并不存储实际的数据，它的存在仅仅是为了简化链表的操作。在实际应用中，根据具体的需求和场景，可以选择在链表的头部或尾部添加哑节点。

使用哑节点的[问题](https://leetcode.cn/problems/merge-two-sorted-lists/description/)代码案例:

```cpp
ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        //新建哑节点作为结果链表返回
        ListNode* res=new ListNode(-1);
        //动态指针永远指向结果链表最后一个位置
        ListNode* curRes=res;
        while(list1&&list2){//只要有一个链表走到末尾,就退出循环
            if(list1->val>list2->val)
            {
                curRes->next=list2;
                list2=list2->next;
            }
            else
            {
                curRes->next=list1;
                list1=list1->next;
            }
            curRes=curRes->next;
        }
        curRes->next=list1==NULL?list2:list1;//补上未空链表
        return res->next;
    }
```

## 前缀和

可以将`求子数组的和为k`问题转化为`求解两个前缀和之差等于k`的问题,通过这种方式在某些题型中可以降低一维

[题型参考](https://leetcode.cn/problems/subarray-sum-equals-k/description/)

解法如下:

```cpp
/*
        参考:前缀和 + 哈希表优化
        将求子数组的和为k问题转化为求解两个前缀和之差等于k的情况
        使用一个哈希表来存储每个前缀和出现的次数
        对于任意的两个下标i和j（i < j），如果prefixSum[j] - prefixSum[i] = k，即从第i个位置到第j个位置的元素之和等于k，那么说明从第i+1个位置到第j个位置的连续子数组的和为k，此时计数+1。
        通过遍历数组，计算每个位置的前缀和，并使用一个哈希表来存储每个前缀和出现的次数。在遍历的过程中，我们检查是否存在prefixSum[j] - k的前缀和，如果存在，说明从某个位置到当前位置的连续子数组的和为k，我们将对应的次数累加到结果中。
        93/93 cases passed (76 ms)
        Your runtime beats 56.29 % of cpp submissions
        Your memory usage beats 44.43 % of cpp submissions (41 MB)
    */
    int subarraySum(vector<int> &nums, int k)
    {
        unordered_map<int,int> prefixSum;//// key为前缀和,value为该和出现的次数
        prefixSum[0]=1;//// 初始化：前缀和为0出现的次数为1:如果没有这个初始化，那么sum-k=0时，map中没有0，判断为false，就会漏掉这种情况
        int sum=0;
        int res=0;
        for (int i=0;i<nums.size();i++)
        {
            sum+=nums[i];
            //判断是是否存在和为k的值
            if(prefixSum.find(sum-k)!=prefixSum.end())
                res+=prefixSum[sum-k];
            // if(prefixSum.find(sum)==prefixSum.end())
            //     prefixSum[sum]=1;
            // else
            //     prefixSum[sum]+=1;
            //上面注释的代码实际上一句就搞定了
            prefixSum[sum]++;
        }
        return res;
    }
```

## 差分数组

## 荷兰国旗问题

> Dutch National Flag Problem 荷兰国旗问题，该问题由荷兰计算机科学家Dijkstra所提出

怎么对一组数做划分,左边都小于他,右边都大于他,中间都等于他(不要求有序,只要求对数组进行划分)

![iShot_2024-01-17_12.01.13_magic](https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202401171202150.png)

参考leetcode的[75. 颜色分类](https://leetcode.cn/problems/sort-colors/)

解决代码如下:

```cpp
//双指针,转移+修正
void sortColors(vector<int>& nums) {
        int p0=0;
        int p2=nums.size()-1;
        for(int i =0;i<=p2;i++)
        {
            if (nums[i]==0)
            {
                swap(nums[i],nums[p0]);
                p0++;
            }
            else if(nums[i] == 2)
            {
                swap(nums[i],nums[p2]);
                p2--;
                i--;
            }
        }
    }
```

# 巧妙的递归解法思路盘点

## 对称二叉树

[题目参考](https://leetcode.cn/problems/symmetric-tree/description/)

递归解法:

```cpp
		//比较两棵树是否对称二叉树		
		bool check(TreeNode *p, TreeNode *q)
    {
        if (!p && !q)
            return true;
        if (!p || !q)
            return false;
     		//p和q都不为NULL才可能走到这里
        return p->val == q->val && check(p->left, q->right) && check(p->right, q->left);
    }
		//判断树是否是二叉树
    bool isSymmetric(TreeNode *root)
    {
        return check(root, root);
    }
```

该题思路的重点在于将一棵树,当成两棵树来比较

图解如下:

<img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2//202312271758349.png" alt="image-20231227175839296" style="zoom: 25%;" /><img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2//202312271754984.png" alt="image-20231227175442449" style="zoom: 25%;" /><img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2//202312271758320.png" alt="image-20231227175855828" style="zoom: 25%;" /><img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2//202312271800043.png" alt="image-20231227180002117" style="zoom:25%;" />

------

改成迭代方式代码如下:  (比较抽象)

> 引入一个队列，这是把递归程序改写成迭代程序的常用方法。初始化时我们把根节点入队两次。每次提取两个结点并比较它们的值（队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像），然后将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。
>

```cpp
class Solution {
public:
    bool check(TreeNode *u, TreeNode *v) {
        queue <TreeNode*> q;
        q.push(u); q.push(v);
        while (!q.empty()) {
            u = q.front(); q.pop();
            v = q.front(); q.pop();
            if (!u && !v) continue;
            if ((!u || !v) || (u->val != v->val)) return false;

            q.push(u->left); 
            q.push(v->right);

            q.push(u->right); 
            q.push(v->left);
        }
        return true;
    }

    bool isSymmetric(TreeNode* root) {
        return check(root, root);
    }
};
```

## 全排列

[46.全排列](#https://leetcode.cn/problems/permutations/description/)

伪代码

<img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2//202401091704999.png" alt="image-20240109170435720"  />

遍历流程

<img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2//202401091714375.gif" alt="全排列" style="zoom: 33%;" />

代码

```cpp
vector<vector<int>> permute(vector<int> &nums)
    {
        dfs(nums, 0);
        return res;
    }
vector<vector<int>> res;
void dfs(vector<int> nums, int x)
    {
        if (x == nums.size() - 1)
        {
            res.push_back(nums); // 添加排列方案
            return;
        }
        for (int i = x; i < nums.size(); i++)
        {
            // 这里使用交换的原因是因为交换不会破坏本身的元素种类,并且最后一个元素可以天然得到保留,妙不可言
            swap(nums[i], nums[x]); // 交换，将 nums[i] 固定在第 x 位
            dfs(nums, x + 1);       // 开启固定第 x + 1 位元素
            swap(nums[i], nums[x]); // 恢复交换(配合循环画龙点睛)
        }
    }
```

此代码后面使用交换的方式,避免了"检测是否已经重复处理过"的时间复杂度

## 子集

[78.子集](https://leetcode.cn/problems/subsets/description/)

这一题找了半天都没有找到递归规律,看了题解才明白,遂记录下来

- 开始假设输出子集为空子集
- 遍历数组，对于数组中的每一个整数，每一步都向输出子集中所有子集添加这个整数，并生成新的子集。

<img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202402021724019.gif" alt="iShot_2024-02-02_16.55.51" style="zoom:50%;" />

gif最后少了一个3的子集,是bug

解法如下:

```cpp
vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> res={{}};
        for (int i = 0; i < nums.size(); i++)
        {
            vector<vector<int>> tmp = res;
            for(auto item:tmp){
                item.push_back(nums[i]);
                res.push_back(item);
            }   
        }
        return res;
    }
```

假设 nums 中的元素个数为n，则 nums 的子集个数为$2^n$。

时间复杂度：$O(n•2^n)$
空间复杂度：$O(n•2^n)$

# 巧妙的算法解决记录

## 15.三数之和

[15.三数之和](https://leetcode.cn/problems/3sum/description/)

```cpp
vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> res;
        sort(nums.begin(), nums.end());
        int size = nums.size();
        for (int k = 0; k < size; k++)
        {
            if(nums[k]>0)//因为 nums[j] >= nums[i] >= nums[k] > 0，即 3 个元素都大于 0 ，在此固定指针 k 之后不可能再找到结果了。
                break;
            if(k>0&&nums[k]==nums[k-1])//重复元素,跳过
                continue;
            int i = k+1;//第二指针
            int j = size - 1; // 第三指针
            while (i < j)
            {
                int sum = nums[k]+nums[i]+nums[j];
                if (sum > 0)
                {
                    do
                    {
                        j--;
                    } while (j>i&&nums[j]==nums[j+1]);
                    
                }
                else if (sum < 0)
                {
                    do
                    {
                        i++;
                    } while (j>i&&nums[i]==nums[i-1]);
                }
                else
                {
                    // 找到为0的值则插入
                    res.push_back(vector<int>{nums[k], nums[i], nums[j]});
                    do
                    {
                        i++;
                    } while (j>i&&nums[i]==nums[i-1]);
                    do
                    {
                        j--;
                    } while (j>i&&nums[j]==nums[j+1]);
                }
            }
        }
        return res;
    }
```

代码执行流程

<img src="https://cdn.jsdelivr.net/gh/che77a38/blogImage2/202401201059831.gif" alt="三数之和" style="zoom:50%;" />

[上面代码详解](https://leetcode.cn/problems/3sum/solutions/11525/3sumpai-xu-shuang-zhi-zhen-yi-dong-by-jyd/)

[详解参阅leetcode官方](https://leetcode.cn/problems/3sum/solutions/284681/san-shu-zhi-he-by-leetcode-solution/)

## 128.最长连续序列

[128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/description/)

记录的这个代码主要是精彩在一次遍历解决问题

> - 哈希map的key为:  数组中的数,
> - value为: 遍历到该元素时，如果 key 是某个连续区间的左/右端点，则 value 为该连续区间的长度；否则 value 值无意义
>
> 伪代码:
>
> 若数已在哈希表中：跳过不做处理
>
> 若是新数加入：
>
> ​     取出其左右相邻数已有的连续区间长度 left 和 right
>
> ​     计算当前数的区间长度为：cur_length = left + right + 1
>
> ​     根据 cur_length 更新最大长度 max_length 的值
>
> ​     更新区间两端点的长度值

本质上就是利用map的value来储存正在处理的数以及他左右的数的序列长度,也即是通过value来**动态叠加连续序列长度**

```cpp
int longestConsecutive(vector<int>& nums) {
        unordered_map<int,int> m;
        int result = 0;
        for( int n : nums ) {
            if( m.find(n) != m.end() ) continue;
            int left = m.find(n-1) == m.end() ? 0 : m[n-1];
            int right = m.find(n+1) == m.end() ? 0 : m[n+1];
            int len = left + right + 1;
            m[n] = 1;
            m[n-left] = m[n+right] = len;
            result = max(result, len);
        }
        return result;
    }
```

# 疑惑

[230题](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/description)使用中序morris遍历算法竟然报栈溢出错误?待解决







